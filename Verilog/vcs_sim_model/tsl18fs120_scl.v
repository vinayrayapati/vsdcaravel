////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ad01d0.v
// Description  	:  1-Bit Full Adder, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ad01d0 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_ADDR2_S #1 (S,A,B,CI);
U_ADDR2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0; 
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ad01d1.v
// Description  	:  1-Bit Full Adder, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ad01d1 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_ADDR2_S #1 (S,A,B,CI);
U_ADDR2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0; 
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ad01d2.v
// Description  	:  1-Bit Full Adder, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ad01d2 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_ADDR2_S #1 (S,A,B,CI);
U_ADDR2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0; 
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ad01d4.v
// Description  	:  1-Bit Full Adder, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ad01d4 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_ADDR2_S #1 (S,A,B,CI);
U_ADDR2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0; 
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif

// Model type   	: zero timing
// Filename     	: adiode.v
// Description  	:  ANTENNA PROTECTION DIODE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


// module adiode (I);

//    input I;
//    buf    E0(DeadEnd, I);

// endmodule
// `endcelldefine
// `disable_portfaults
// `nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: adp1d0.v
// Description          : 1-Bit Full Adder with Propagate, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module adp1d0 (A,B,CI,S,P,CO);

output  S,P,CO;
input   A,B,CI;

wire A_buf,B_buf,CI_buf;

buf (A_buf,A);
buf (B_buf,B);
buf (CI_buf,CI);

wire S_OUT = ((!CI_buf && !B_buf && A_buf) || (!CI_buf && B_buf && !A_buf) || (CI_buf && B_buf && A_buf) || (CI_buf && !B_buf && !A_buf));

buf #1 (S,S_OUT);
wire P_OUT = ((!B_buf && A_buf) || (B_buf && !A_buf));

buf #1 (P,P_OUT);
wire CO_OUT = ((B_buf && A_buf) || (CI_buf && B_buf) || (CI_buf && A_buf));

buf #1 (CO,CO_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
ifnone (A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
ifnone (B => P) = (default_rise,default_fall);

 (        CI +=> CO) = (default_rise,default_fall);
 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: adp1d1.v
// Description  	:  1-Bit Full Adder with Propagate, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module adp1d1 (A,B,CI,S,P,CO);

output  S,P,CO;
input   A,B,CI;

wire A_buf,B_buf,CI_buf;

buf (A_buf,A);
buf (B_buf,B);
buf (CI_buf,CI);

wire S_OUT = ((!CI_buf && !B_buf && A_buf) || (!CI_buf && B_buf && !A_buf) || (CI_buf && B_buf && A_buf) || (CI_buf && !B_buf && !A_buf));

buf #1 (S,S_OUT);
wire P_OUT = ((!B_buf && A_buf) || (B_buf && !A_buf));

buf #1 (P,P_OUT);
wire CO_OUT = ((B_buf && A_buf) || (CI_buf && B_buf) || (CI_buf && A_buf));

buf #1 (CO,CO_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
ifnone (A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
ifnone (B => P) = (default_rise,default_fall);

 (        CI +=> CO) = (default_rise,default_fall);
 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: adp1d2.v
// Description          : 1-Bit Full Adder with Propagate, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module adp1d2 (A,B,CI,S,P,CO);

output  S,P,CO;
input   A,B,CI;

wire A_buf,B_buf,CI_buf;

buf (A_buf,A);
buf (B_buf,B);
buf (CI_buf,CI);

wire S_OUT = ((!CI_buf && !B_buf && A_buf) || (!CI_buf && B_buf && !A_buf) || (CI_buf && B_buf && A_buf) || (CI_buf && !B_buf && !A_buf));

buf #1 (S,S_OUT);
wire P_OUT = ((!B_buf && A_buf) || (B_buf && !A_buf));

buf #1 (P,P_OUT);
wire CO_OUT = ((B_buf && A_buf) || (CI_buf && B_buf) || (CI_buf && A_buf));

buf #1 (CO,CO_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
ifnone (A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
ifnone (B => P) = (default_rise,default_fall);

 (        CI +=> CO) = (default_rise,default_fall);
 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: adp1d4.v
// Description  	:  1-Bit Full Adder with Propagate, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module adp1d4 (A,B,CI,S,P,CO);

output  S,P,CO;
input   A,B,CI;

wire A_buf,B_buf,CI_buf;

buf (A_buf,A);
buf (B_buf,B);
buf (CI_buf,CI);

wire S_OUT = ((!CI_buf && !B_buf && A_buf) || (!CI_buf && B_buf && !A_buf) || (CI_buf && B_buf && A_buf) || (CI_buf && !B_buf && !A_buf));

buf #1 (S,S_OUT);
wire P_OUT = ((!B_buf && A_buf) || (B_buf && !A_buf));

buf #1 (P,P_OUT);
wire CO_OUT = ((B_buf && A_buf) || (CI_buf && B_buf) || (CI_buf && A_buf));

buf #1 (CO,CO_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => P) = (default_rise,default_fall);
ifnone (A => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => P) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => P) = (default_rise,default_fall);
ifnone (B => P) = (default_rise,default_fall);

 (        CI +=> CO) = (default_rise,default_fall);
 (        A  +=> CO) = (default_rise,default_fall);
 (        B  +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ah01d0.v
// Description  	:  1-Bit Half Adder, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ah01d0 (A,B,S,CO);

output  S,CO;
input   A,B;

xor  #1  (S,B,A);
and  #1  (CO,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (B == 1'b0)
	(A => S) = (default_rise,default_fall);
if (B == 1'b1)
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if (A == 1'b0)
	(B => S) = (default_rise,default_fall);
if (A == 1'b1)
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);

 (        A +=> CO) = (default_rise,default_fall);
 (        B +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ah01d1.v
// Description  	:  1-Bit Half Adder, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ah01d1 (A,B,S,CO);

output  S,CO;
input   A,B;

xor  #1  (S,B,A);
and  #1  (CO,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (B == 1'b0)
	(A => S) = (default_rise,default_fall);
if (B == 1'b1)
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if (A == 1'b0)
	(B => S) = (default_rise,default_fall);
if (A == 1'b1)
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);

 (        A +=> CO) = (default_rise,default_fall);
 (        B +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ah01d2.v
// Description  	:  1-Bit Half Adder, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ah01d2 (A,B,S,CO);

output  S,CO;
input   A,B;

xor  #1  (S,B,A);
and  #1  (CO,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (B == 1'b0)
	(A => S) = (default_rise,default_fall);
if (B == 1'b1)
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if (A == 1'b0)
	(B => S) = (default_rise,default_fall);
if (A == 1'b1)
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);

 (        A +=> CO) = (default_rise,default_fall);
 (        B +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ah01d4.v
// Description  	:  1-Bit Half Adder, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module ah01d4 (A,B,S,CO);

output  S,CO;
input   A,B;

xor  #1  (S,B,A);
and  #1  (CO,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (B == 1'b0)
	(A => S) = (default_rise,default_fall);
if (B == 1'b1)
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if (A == 1'b0)
	(B => S) = (default_rise,default_fall);
if (A == 1'b1)
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);

 (        A +=> CO) = (default_rise,default_fall);
 (        B +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02d0.v
// Description          : 2-INPUT AND, 0.5X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an02d0 (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02d1.v
// Description  	:  2-INPUT AND, 1X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an02d1 (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02d2.v
// Description  	:  2-INPUT AND, 2X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an02d2 (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02d4.v
// Description  	:  2-INPUT AND, 4X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an02d4 (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02d7.v
// Description          : 2-INPUT AND, 7X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an02d7 (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an02da.v
// Description          : 2-INPUT AND, 10X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an02da (A1,A2,Z);

output  Z;
input   A1,A2;

and #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03d0.v
// Description          : 3-INPUT AND, 0.5X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an03d0 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03d1.v
// Description  	:  3-INPUT AND, 1X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an03d1 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03d2.v
// Description  	:  3-Input AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an03d2 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03d4.v
// Description  	:  3-Input AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an03d4 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03d7.v
// Description          : 3-Input AND, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an03d7 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an03da.v
// Description          : 3-Input AND, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an03da (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

and #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04d0.v
// Description          : 4-Input AND, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an04d0 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04d1.v
// Description  	:  4-Input AND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an04d1 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04d2.v
// Description  	:  4-Input AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an04d2 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04d4.v
// Description  	:  4-Input AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an04d4 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04d7.v
// Description  	:  4-Input AND, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an04d7 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an04da.v
// Description          : 4-Input AND, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module an04da (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

and #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_hl_z_hl=0,a2_lh_z_lh=0,
 a3_hl_z_hl=0,a3_lh_z_lh=0,a4_hl_z_hl=0,a4_lh_z_lh=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an12d1.v
// Description  	:  2-INPUT AND with 1 Inverted Input, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an12d1 (A1,A2,Z);

output  Z;
input   A1,A2;

wire not_A1;

not (not_A1,A1);
and #1 (Z,A2,not_A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh=0,a1_lh_z_hl=0,a1_hl_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A1 -=> Z) = (a1_hl_z_lh,a1_lh_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an12d2.v
// Description  	:  2-INPUT AND with 1 Inverted Input, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an12d2 (A1,A2,Z);

output  Z;
input   A1,A2;

wire not_A1;

not (not_A1,A1);
and #1 (Z,A2,not_A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh=0,a1_lh_z_hl=0,a1_hl_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A1 -=> Z) = (a1_hl_z_lh,a1_lh_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: an12d4.v
// Description  	:  2-INPUT AND with 1 Inverted Input, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module an12d4 (A1,A2,Z);

output  Z;
input   A1,A2;

wire not_A1;

not (not_A1,A1);
and #1 (Z,A2,not_A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh=0,a1_lh_z_hl=0,a1_hl_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A1 -=> Z) = (a1_hl_z_lh,a1_lh_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi211d1.v
// Description  	:  2/1/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi211d1 (C1,C2,B,A,ZN);

output  ZN;
input   C1,C2,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C2);
or (g_2_out,B,A,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_2=0,b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,
 c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi211d2.v
// Description  	:  2/1/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi211d2 (C1,C2,B,A,ZN);

output  ZN;
input   C1,C2,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C2);
or (g_2_out,B,A,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_2=0,b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,
 c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi211d4.v
// Description          : 2/1/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi211d4 (C1,C2,B,A,ZN);

output  ZN;
input   C1,C2,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C2);
or (g_2_out,B,A,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_2=0,b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,
 c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi21d1.v
// Description  	:  2/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi21d1 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_1_out;

and (g_1_out,B1,B2);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_2=0,b2_lh_zn_hl=0,b1_hl_zn_lh=0,
 b1_lh_zn_hl=0,b2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi21d2.v
// Description  	:  2/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi21d2 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_1_out;

and (g_1_out,B1,B2);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_2=0,b2_lh_zn_hl=0,b1_hl_zn_lh=0,
 b1_lh_zn_hl=0,b2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi21d4.v
// Description          : 2/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi21d4 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_1_out;

and (g_1_out,B1,B2);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_2=0,b2_lh_zn_hl=0,b1_hl_zn_lh=0,
 b1_lh_zn_hl=0,b2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi221d1.v
// Description  	:  2/2/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi221d1 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,b1_lh_zn_hl_1=0,c2_lh_zn_hl_1=0,c1_hl_zn_lh_1=0,
 a_hl_zn_lh_8=0,b2_lh_zn_hl_3=0,b1_hl_zn_lh_3=0,b2_hl_zn_lh_3=0,c1_lh_zn_hl_1=0,c2_hl_zn_lh_2=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_8,a_lh_zn_hl_1);
 (        B1 -=> ZN) = (b1_hl_zn_lh_3,b1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_3,b2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi221d2.v
// Description  	:  2/2/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi221d2 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_5=0,a_hl_zn_lh_5=0,b2_lh_zn_hl_2=0,b1_hl_zn_lh_2=0,
 b1_lh_zn_hl_2=0,b2_hl_zn_lh_2=0,c2_lh_zn_hl_1=0,c1_hl_zn_lh_1=0,c1_lh_zn_hl_2=0,c2_hl_zn_lh_2=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi221d4.v
// Description          : 2/2/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi221d4 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,b1_lh_zn_hl_1=0,c2_lh_zn_hl_1=0,c1_hl_zn_lh_1=0,
 a_hl_zn_lh_8=0,b2_lh_zn_hl_3=0,b1_hl_zn_lh_3=0,b2_hl_zn_lh_3=0,c1_lh_zn_hl_1=0,c2_hl_zn_lh_2=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_8,a_lh_zn_hl_1);
 (        B1 -=> ZN) = (b1_hl_zn_lh_3,b1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_3,b2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi2222d1.v
// Description  	:  2/2/2/2 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi2222d1 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_1_out,g_2_out,g_3_out,g_4_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
and (g_4_out,D2,D1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,
 b1_hl_zn_lh_1=0,b1_lh_zn_hl_1=0,b2_lh_zn_hl_2=0,b2_hl_zn_lh_2=0,c2_lh_zn_hl_10=0,
 c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,d2_lh_zn_hl_1=0,d1_hl_zn_lh_1=0,
 d1_lh_zn_hl_1=0,d2_hl_zn_lh_10=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_1,b1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_1);
 (        D1 -=> ZN) = (d1_hl_zn_lh_1,d1_lh_zn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi2222d2.v
// Description  	:  2/2/2/2 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi2222d2 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_1_out,g_2_out,g_3_out,g_4_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
and (g_4_out,D2,D1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,
 b2_lh_zn_hl_1=0,b1_lh_zn_hl_1=0,b1_hl_zn_lh_13=0,b2_hl_zn_lh_14=0,c2_lh_zn_hl_10=0,
 c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,d1_hl_zn_lh_1=0,d1_lh_zn_hl_1=0,
 d2_lh_zn_hl_2=0,d2_hl_zn_lh_10=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_14,b2_lh_zn_hl_1);
 (        B1 -=> ZN) = (b1_hl_zn_lh_13,b1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        D1 -=> ZN) = (d1_hl_zn_lh_1,d1_lh_zn_hl_1);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi2222d4.v
// Description          : 2/2/2/2 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi2222d4 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_1_out,g_2_out,g_3_out,g_4_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
and (g_4_out,D2,D1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,
 b1_hl_zn_lh_1=0,b1_lh_zn_hl_1=0,b2_lh_zn_hl_2=0,b2_hl_zn_lh_2=0,c2_lh_zn_hl_10=0,
 c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,d2_lh_zn_hl_1=0,d1_hl_zn_lh_1=0,
 d1_lh_zn_hl_1=0,d2_hl_zn_lh_10=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_1,b1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_1);
 (        D1 -=> ZN) = (d1_hl_zn_lh_1,d1_lh_zn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi222d1.v
// Description  	:  2/2/2 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi222d1 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_1=0,a2_lh_zn_hl_8=0,a1_hl_zn_lh_8=0,a1_lh_zn_hl_8=0,
 a2_hl_zn_lh_8=0,b1_lh_zn_hl_7=0,b1_hl_zn_lh_8=0,b2_lh_zn_hl_8=0,b2_hl_zn_lh_9=0,
 c1_lh_zn_hl_1=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_8,a2_lh_zn_hl_8);
 (        A1 -=> ZN) = (a1_hl_zn_lh_8,a1_lh_zn_hl_8);
 (        B1 -=> ZN) = (b1_hl_zn_lh_8,b1_lh_zn_hl_7);
 (        B2 -=> ZN) = (b2_hl_zn_lh_9,b2_lh_zn_hl_8);
 (        C2 -=> ZN) = (c2_hl_zn_lh_6,c2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi222d2.v
// Description  	:  2/2/2 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi222d2 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_5=0,a1_hl_zn_lh_5=0,a1_lh_zn_hl_5=0,a2_hl_zn_lh_5=0,
 b2_lh_zn_hl_4=0,b1_hl_zn_lh_4=0,b1_lh_zn_hl_4=0,b2_hl_zn_lh_5=0,c1_lh_zn_hl_1=0,
 c1_hl_zn_lh_5=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_5=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_5,a2_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_5,a1_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_5,b2_lh_zn_hl_4);
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_4);
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi222d4.v
// Description          : 2/2/2 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi222d4 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
and (g_3_out,C2,C1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_1=0,a2_lh_zn_hl_8=0,a1_hl_zn_lh_8=0,a1_lh_zn_hl_8=0,
 a2_hl_zn_lh_8=0,b1_lh_zn_hl_7=0,b1_hl_zn_lh_8=0,b2_lh_zn_hl_8=0,b2_hl_zn_lh_9=0,
 c1_lh_zn_hl_1=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_8,a2_lh_zn_hl_8);
 (        A1 -=> ZN) = (a1_hl_zn_lh_8,a1_lh_zn_hl_8);
 (        B1 -=> ZN) = (b1_hl_zn_lh_8,b1_lh_zn_hl_7);
 (        B2 -=> ZN) = (b2_hl_zn_lh_9,b2_lh_zn_hl_8);
 (        C2 -=> ZN) = (c2_hl_zn_lh_6,c2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi22d1.v
// Description  	:  2/2 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi22d1 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_1_out,g_2_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl_1=0,a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a2_hl_zn_lh_2=0,
 b1_hl_zn_lh_1=0,b1_lh_zn_hl_1=0,b2_lh_zn_hl_2=0,b2_hl_zn_lh_2=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_1,b1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi22d2.v
// Description  	:  2/2 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi22d2 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_1_out,g_2_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,
 b1_hl_zn_lh_1=0,b1_lh_zn_hl_1=0,b2_lh_zn_hl_2=0,b2_hl_zn_lh_2=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_1,b1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi22d4.v
// Description          : 2/2 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi22d4 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_1_out,g_2_out;

and (g_1_out,A2,A1);
and (g_2_out,B2,B1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl_1=0,a2_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a2_hl_zn_lh_2=0,
 b1_hl_zn_lh_1=0,b1_lh_zn_hl_1=0,b2_lh_zn_hl_2=0,b2_hl_zn_lh_2=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_1,b1_lh_zn_hl_1);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi311d1.v
// Description  	:  3/1/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi311d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
nor #1 (ZN,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_4=0,b_lh_zn_hl_4=0,b_hl_zn_lh_4=0,
 c3_lh_zn_hl=0,c2_hl_zn_lh=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_4,b_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi311d2.v
// Description  	:  3/1/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi311d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
nor #1 (ZN,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_4=0,a_hl_zn_lh_4=0,b_lh_zn_hl_4=0,b_hl_zn_lh_4=0,
 c3_lh_zn_hl=0,c2_hl_zn_lh=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
 (        B  -=> ZN) = (b_hl_zn_lh_4,b_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi311d4.v
// Description          : 3/1/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi311d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
nor #1 (ZN,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_4=0,b_lh_zn_hl_4=0,b_hl_zn_lh_4=0,
 c3_lh_zn_hl=0,c2_hl_zn_lh=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_4,b_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi31d1.v
// Description  	:  3/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi31d1 (B1,B2,B3,A,ZN);

output  ZN;
input   B1,B2,B3,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_4=0,b3_lh_zn_hl=0,b2_hl_zn_lh=0,
 b2_lh_zn_hl=0,b1_hl_zn_lh=0,b1_lh_zn_hl=0,b3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_2);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi31d2.v
// Description  	:  3/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi31d2 (B1,B2,B3,A,ZN);

output  ZN;
input   B1,B2,B3,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_4=0,a_hl_zn_lh_4=0,b3_lh_zn_hl=0,b2_hl_zn_lh=0,
 b2_lh_zn_hl=0,b1_hl_zn_lh=0,b1_lh_zn_hl=0,b3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi31d4.v
// Description          : 3/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi31d4 (B1,B2,B3,A,ZN);

output  ZN;
input   B1,B2,B3,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
nor #1 (ZN,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_4=0,b3_lh_zn_hl=0,b2_hl_zn_lh=0,
 b2_lh_zn_hl=0,b1_hl_zn_lh=0,b1_lh_zn_hl=0,b3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_2);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi321d1.v
// Description  	:  3/2/1 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi321d1 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C3,C2,C1);
and (g_2_out,B1,B2);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_hl_2=0,a_lh_zn_hl_11=0,a_hl_zn_lh_11=0,b2_lh_zn_hl_4=0,
 b1_hl_zn_lh_4=0,b2_hl_zn_lh_4=0,c3_lh_zn_hl_1=0,c2_hl_zn_lh_1=0,c2_lh_zn_hl_1=0,
 c1_hl_zn_lh_1=0,c1_lh_zn_hl_1=0,c3_hl_zn_lh_2=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_11,a_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_4,b2_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_1,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi321d2.v
// Description  	:  3/2/1 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi321d2 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C3,C2,C1);
and (g_2_out,B1,B2);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_11=0,a_hl_zn_lh_11=0,b2_lh_zn_hl_4=0,b1_hl_zn_lh_4=0,
 b1_lh_zn_hl_4=0,b2_hl_zn_lh_4=0,c3_lh_zn_hl_1=0,c2_hl_zn_lh_1=0,c2_lh_zn_hl_1=0,
 c1_hl_zn_lh_1=0,c1_lh_zn_hl_2=0,c3_hl_zn_lh_2=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_11,a_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_4,b2_lh_zn_hl_4);
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_1,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi321d4.v
// Description          : 3/2/1 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi321d4 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C3,C2,C1);
and (g_2_out,B1,B2);
nor #1 (ZN,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_hl_2=0,a_lh_zn_hl_11=0,a_hl_zn_lh_11=0,b2_lh_zn_hl_4=0,
 b1_hl_zn_lh_4=0,b2_hl_zn_lh_4=0,c3_lh_zn_hl_1=0,c2_hl_zn_lh_1=0,c2_lh_zn_hl_1=0,
 c1_hl_zn_lh_1=0,c1_lh_zn_hl_1=0,c3_hl_zn_lh_2=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_11,a_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_4,b2_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_1,c2_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh_1,c1_lh_zn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi322d1.v
// Description  	:  3/2/2 AND-OR-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi322d1 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1,C3);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_5=0,a1_lh_zn_hl_5=0,b2_lh_zn_hl_5=0,a1_hl_zn_lh_11=0,
 a2_hl_zn_lh_11=0,b1_hl_zn_lh_10=0,b1_lh_zn_hl_10=0,b2_hl_zn_lh_11=0,c1_lh_zn_hl_1=0,
 c1_hl_zn_lh_5=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_6=0,c3_lh_zn_hl_2=0,c3_hl_zn_lh_5=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_11,a2_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_11,a1_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_11,b2_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_10,b1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_6,c2_lh_zn_hl_2);
 (        C3 -=> ZN) = (c3_hl_zn_lh_5,c3_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi322d2.v
// Description  	:  3/2/2 AND-OR-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoi322d2 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1,C3);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_11=0,a1_hl_zn_lh_11=0,a1_lh_zn_hl_11=0,a2_hl_zn_lh_11=0,
 b2_lh_zn_hl_10=0,b1_hl_zn_lh_10=0,b1_lh_zn_hl_10=0,b2_hl_zn_lh_11=0,c1_lh_zn_hl_4=0,
 c1_hl_zn_lh_5=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_6=0,c3_lh_zn_hl_2=0,c3_hl_zn_lh_5=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_11,a2_lh_zn_hl_11);
 (        A1 -=> ZN) = (a1_hl_zn_lh_11,a1_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_11,b2_lh_zn_hl_10);
 (        B1 -=> ZN) = (b1_hl_zn_lh_10,b1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_4);
 (        C2 -=> ZN) = (c2_hl_zn_lh_6,c2_lh_zn_hl_2);
 (        C3 -=> ZN) = (c3_hl_zn_lh_5,c3_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoi322d4.v
// Description          : 3/2/2 AND-OR-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoi322d4 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1,C3);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
nor #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl_5=0,a1_lh_zn_hl_5=0,b2_lh_zn_hl_5=0,a1_hl_zn_lh_11=0,
 a2_hl_zn_lh_11=0,b1_hl_zn_lh_10=0,b1_lh_zn_hl_10=0,b2_hl_zn_lh_11=0,c1_lh_zn_hl_1=0,
 c1_hl_zn_lh_5=0,c2_lh_zn_hl_2=0,c2_hl_zn_lh_6=0,c3_lh_zn_hl_2=0,c3_hl_zn_lh_5=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh_11,a2_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_11,a1_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_11,b2_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_10,b1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh_6,c2_lh_zn_hl_2);
 (        C3 -=> ZN) = (c3_hl_zn_lh_5,c3_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim211d1.v
// Description  	:  2/1/1 AND-OR-INVERT with C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim211d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf && !A_buf && C2_buf) || (!B_buf && !A_buf && C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim211d2.v
// Description  	:  2/1/1 AND-OR-INVERT with C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim211d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf && !A_buf && C2_buf) || (!B_buf && !A_buf && C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim211d4.v
// Description  	:  2/1/1 AND-OR-INVERT with C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim211d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf && !A_buf && C2_buf) || (!B_buf && !A_buf && C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim21d1.v
// Description  	:  2/1 AND-OR-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim21d1 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B1_buf && !B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim21d2.v
// Description  	:  2/1 AND-OR-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim21d2 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B1_buf && !B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim21d4.v
// Description  	:  2/1 AND-OR-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim21d4 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B1_buf && !B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim22d1.v
// Description  	:  2/2 AND-OR-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim22d1 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire A1_buf,A2_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire Z_OUT = !((!B2_buf && !B1_buf) || (A2_buf && A1_buf));

buf #1 (Z,Z_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_hl_1=0,a1_hl_z_lh_1=0,a2_lh_z_hl_1=0,b1_hl_z_hl_1=0,
 b1_lh_z_lh_2=0,a2_hl_z_lh_3=0,b2_hl_z_hl_1=0,b2_lh_z_lh_3=0;
// Delays
 (        A1 -=> Z) = (a1_hl_z_lh_1,a1_lh_z_hl_1);
 (        A2 -=> Z) = (a2_hl_z_lh_3,a2_lh_z_hl_1);
 (        B1 +=> Z) = (b1_lh_z_lh_2,b1_hl_z_hl_1);
 (        B2 +=> Z) = (b2_lh_z_lh_3,b2_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim22d2.v
// Description  	:  2/2 AND-OR-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim22d2 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire A1_buf,A2_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire Z_OUT = !((!B2_buf && !B1_buf) || (A2_buf && A1_buf));

buf #1 (Z,Z_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_z_lh_1=0,a1_hl_z_lh_1=0,a2_hl_z_lh_1=0,b1_hl_z_hl_1=0,
 b2_lh_z_lh_1=0,a2_lh_z_hl_3=0,a1_lh_z_hl_3=0,b2_hl_z_hl_1=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh_1,b1_hl_z_hl_1);
 (        A1 -=> Z) = (a1_hl_z_lh_1,a1_lh_z_hl_3);
 (        A2 -=> Z) = (a2_hl_z_lh_1,a2_lh_z_hl_3);
 (        B2 +=> Z) = (b2_lh_z_lh_1,b2_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim22d4.v
// Description          : 2/2 AND-OR-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aoim22d4 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire A1_buf,A2_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire Z_OUT = !((!B2_buf && !B1_buf) || (A2_buf && A1_buf));

buf #1 (Z,Z_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_hl_1=0,a1_hl_z_lh_1=0,a2_lh_z_hl_1=0,b1_hl_z_hl_1=0,
 b1_lh_z_lh_2=0,a2_hl_z_lh_3=0,b2_hl_z_hl_1=0,b2_lh_z_lh_3=0;
// Delays
 (        A1 -=> Z) = (a1_hl_z_lh_1,a1_lh_z_hl_1);
 (        A2 -=> Z) = (a2_hl_z_lh_3,a2_lh_z_hl_1);
 (        B1 +=> Z) = (b1_lh_z_lh_2,b1_hl_z_hl_1);
 (        B2 +=> Z) = (b2_lh_z_lh_3,b2_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim2m11d1.v
// Description  	:  2/1/1 AND-OR-INVERT with B and C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim2m11d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((B_buf && !A_buf && C1_buf) || (B_buf && !A_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim2m11d2.v
// Description  	:  2/1/1 AND-OR-INVERT with B and C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim2m11d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((B_buf && !A_buf && C1_buf) || (B_buf && !A_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim2m11d4.v
// Description  	:  2/1/1 AND-OR-INVERT with B and C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim2m11d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((B_buf && !A_buf && C1_buf) || (B_buf && !A_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim311d1.v
// Description  	:  3/1/1 AND-OR-INVERT with C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim311d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf) || (A_buf) || (!C1_buf && !C3_buf && !C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim311d2.v
// Description  	:  3/1/1 AND-OR-INVERT with C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim311d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf) || (A_buf) || (!C1_buf && !C3_buf && !C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim311d4.v
// Description  	:  3/1/1 AND-OR-INVERT with C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim311d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf) || (A_buf) || (!C1_buf && !C3_buf && !C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 b_hl_zn_lh_1=0,c1_hl_zn_hl=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim31d1.v
// Description  	:  3/1 AND-OR-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim31d1 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B2_buf && !B1_buf && !B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0,b3_lh_zn_lh=0,b3_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim31d2.v
// Description  	:  3/1 AND-OR-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim31d2 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B2_buf && !B1_buf && !B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0,b3_lh_zn_lh=0,b3_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim31d4.v
// Description  	:  3/1 AND-OR-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim31d4 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = !((A_buf) || (!B2_buf && !B1_buf && !B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_lh=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_hl_zn_hl=0,
 b2_lh_zn_lh=0,b2_hl_zn_hl=0,b3_lh_zn_lh=0,b3_hl_zn_hl=0;
// Delays
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim3m11d1.v
// Description  	:  3/1/1 AND-OR-INVERT with B and C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim3m11d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf) || (!C1_buf && !C3_buf && !C2_buf) || (A_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim3m11d2.v
// Description  	:  3/1/1 AND-OR-INVERT with B and C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim3m11d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf) || (!C1_buf && !C3_buf && !C2_buf) || (A_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aoim3m11d4.v
// Description  	:  3/1/1 AND-OR-INVERT with B and C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aoim3m11d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf) || (!C1_buf && !C3_buf && !C2_buf) || (A_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_lh_1=0,a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_hl_1=0,
 c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_lh_zn_lh=0,c2_hl_zn_hl=0,c3_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aon211d1.v
// Description  	:  2/1/1 AND-OR-NAND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aon211d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A);
and (g_2_out,A,C2,C1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,
 c1_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,c2_hl_zn_lh=0;
// Delays
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aon211d2.v
// Description  	:  2/1/1 AND-OR-NAND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aon211d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A);
and (g_2_out,A,C2,C1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,
 c1_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,c2_hl_zn_lh=0;
// Delays
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aon211d4.v
// Description          : 2/1/1 AND-OR-NAND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aon211d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A);
and (g_2_out,A,C2,C1);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_zn_hl_2=0,b_hl_zn_lh_2=0,c2_lh_zn_hl=0,c1_hl_zn_lh=0,
 c1_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,c2_hl_zn_lh=0;
// Delays
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor211d1.v
// Description  	:  2/1/1 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor211d1 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C1);
or (g_2_out,B,A,C2);
and #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b_lh_z_lh_2=0,b_hl_z_hl_2=0,
 c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor211d2.v
// Description  	:  2/1/1 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor211d2 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C1);
or (g_2_out,B,A,C2);
and #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b_lh_z_lh_2=0,b_hl_z_hl_2=0,
 c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor211d4.v
// Description  	:  2/1/1 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor211d4 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A,C1);
or (g_2_out,B,A,C2);
and #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b_lh_z_lh_2=0,b_hl_z_hl_2=0,
 c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor21d1.v
// Description  	:  2/1 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor21d1 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,B1,B2);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b2_lh_z_lh=0,b1_hl_z_hl=0,
 b1_lh_z_lh=0,b2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor21d2.v
// Description  	:  2/1 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor21d2 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_1_out;

and (g_1_out,B1,B2);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b2_lh_z_lh=0,b1_hl_z_hl=0,
 b1_lh_z_lh=0,b2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor21d4.v
// Description  	:  2/1 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor21d4 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_1_out;

and (g_1_out,B1,B2);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_2=0,a_hl_z_hl_2=0,b2_lh_z_lh=0,b1_hl_z_hl=0,
 b1_lh_z_lh=0,b2_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor221d1.v
// Description  	:  2/2/1 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor221d1 (C2,C1,B2,B1,A,Z);

output  Z;
input   C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
or #1 (Z,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_5=0,a_hl_z_hl_5=0,b2_lh_z_lh_2=0,b1_hl_z_hl_2=0,
 b1_lh_z_lh_2=0,b2_hl_z_hl_2=0,c2_lh_z_lh_1=0,c1_hl_z_hl_1=0,c1_lh_z_lh_1=0,c2_hl_z_hl_2=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_5,a_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_2,b2_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_2,b1_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh_1,c2_hl_z_hl_2);
 (        C1 +=> Z) = (c1_lh_z_lh_1,c1_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor221d2.v
// Description  	:  2/2/1 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor221d2 (C2,C1,B2,B1,A,Z);

output  Z;
input   C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
or #1 (Z,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_5=0,a_hl_z_hl_5=0,b2_lh_z_lh_2=0,b1_hl_z_hl_2=0,
 b1_lh_z_lh_2=0,b2_hl_z_hl_2=0,c2_lh_z_lh_1=0,c1_hl_z_hl_1=0,c1_lh_z_lh_1=0,c2_hl_z_hl_2=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_5,a_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_2,b2_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_2,b1_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh_1,c2_hl_z_hl_2);
 (        C1 +=> Z) = (c1_lh_z_lh_1,c1_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor221d4.v
// Description          : 2/2/1 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aor221d4 (C2,C1,B2,B1,A,Z);

output  Z;
input   C2,C1,B2,B1,A;

wire g_1_out,g_2_out;

and (g_1_out,C1,C2);
and (g_2_out,B2,B1);
or #1 (Z,g_1_out,g_2_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_5=0,a_hl_z_hl_5=0,b2_lh_z_lh_2=0,b1_hl_z_hl_2=0,
 b1_lh_z_lh_2=0,b2_hl_z_hl_2=0,c2_lh_z_lh_1=0,c1_hl_z_hl_1=0,c1_lh_z_lh_1=0,c2_hl_z_hl_2=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_5,a_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_2,b2_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_2,b1_hl_z_hl_2);
 (        C2 +=> Z) = (c2_lh_z_lh_1,c2_hl_z_hl_2);
 (        C1 +=> Z) = (c1_lh_z_lh_1,c1_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor222d1.v
// Description  	:  2/2/2 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor222d1 (C2,C1,B2,B1,A2,A1,Z);

output  Z;
input   C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
or #1 (Z,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_5=0,a1_hl_z_hl_5=0,a1_lh_z_lh_5=0,a2_hl_z_hl_5=0,
 b2_lh_z_lh_4=0,b1_hl_z_hl_4=0,b1_lh_z_lh_4=0,b2_hl_z_hl_5=0,c1_lh_z_lh_4=0,
 c1_hl_z_hl_5=0,c2_lh_z_lh_2=0,c2_hl_z_hl_5=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_5,a2_hl_z_hl_5);
 (        A1 +=> Z) = (a1_lh_z_lh_5,a1_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_4,b2_hl_z_hl_5);
 (        B1 +=> Z) = (b1_lh_z_lh_4,b1_hl_z_hl_4);
 (        C1 +=> Z) = (c1_lh_z_lh_4,c1_hl_z_hl_5);
 (        C2 +=> Z) = (c2_lh_z_lh_2,c2_hl_z_hl_5);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor222d2.v
// Description  	:  2/2/2 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor222d2 (C2,C1,B2,B1,A2,A1,Z);

output  Z;
input   C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
or #1 (Z,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_5=0,a1_hl_z_hl_5=0,a1_lh_z_lh_5=0,a2_hl_z_hl_5=0,
 b2_lh_z_lh_4=0,b1_hl_z_hl_4=0,b1_lh_z_lh_4=0,b2_hl_z_hl_5=0,c1_lh_z_lh_4=0,
 c1_hl_z_hl_5=0,c2_lh_z_lh_2=0,c2_hl_z_hl_5=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_5,a2_hl_z_hl_5);
 (        A1 +=> Z) = (a1_lh_z_lh_5,a1_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_4,b2_hl_z_hl_5);
 (        B1 +=> Z) = (b1_lh_z_lh_4,b1_hl_z_hl_4);
 (        C1 +=> Z) = (c1_lh_z_lh_4,c1_hl_z_hl_5);
 (        C2 +=> Z) = (c2_lh_z_lh_2,c2_hl_z_hl_5);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor222d4.v
// Description          : 2/2/2 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aor222d4 (C2,C1,B2,B1,A2,A1,Z);

output  Z;
input   C2,C1,B2,B1,A2,A1;

wire g_1_out,g_2_out,g_3_out;

and (g_1_out,C2,C1);
and (g_2_out,B2,B1);
and (g_3_out,A2,A1);
or #1 (Z,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_5=0,a1_hl_z_hl_5=0,a1_lh_z_lh_5=0,a2_hl_z_hl_5=0,
 b2_lh_z_lh_4=0,b1_hl_z_hl_4=0,b1_lh_z_lh_4=0,b2_hl_z_hl_5=0,c1_lh_z_lh_4=0,
 c1_hl_z_hl_5=0,c2_lh_z_lh_2=0,c2_hl_z_hl_5=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_5,a2_hl_z_hl_5);
 (        A1 +=> Z) = (a1_lh_z_lh_5,a1_hl_z_hl_5);
 (        B2 +=> Z) = (b2_lh_z_lh_4,b2_hl_z_hl_5);
 (        B1 +=> Z) = (b1_lh_z_lh_4,b1_hl_z_hl_4);
 (        C1 +=> Z) = (c1_lh_z_lh_4,c1_hl_z_hl_5);
 (        C2 +=> Z) = (c2_lh_z_lh_2,c2_hl_z_hl_5);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor22d1.v
// Description  	:  2/2 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor22d1 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire g_1_out,g_2_out;

and (g_1_out,B2,B1);
and (g_2_out,A2,A1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_2=0,a1_hl_z_hl_2=0,a1_lh_z_lh_2=0,a2_hl_z_hl_2=0,
 b1_hl_z_hl_1=0,b1_lh_z_lh_1=0,b2_lh_z_lh_2=0,b2_hl_z_hl_2=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_2,a2_hl_z_hl_2);
 (        A1 +=> Z) = (a1_lh_z_lh_2,a1_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_1,b1_hl_z_hl_1);
 (        B2 +=> Z) = (b2_lh_z_lh_2,b2_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor22d2.v
// Description  	:  2/2 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor22d2 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire g_1_out,g_2_out;

and (g_1_out,B2,B1);
and (g_2_out,A2,A1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_2=0,a1_hl_z_hl_2=0,a1_lh_z_lh_2=0,a2_hl_z_hl_2=0,
 b2_lh_z_lh_1=0,b1_hl_z_hl_1=0,b1_lh_z_lh_1=0,b2_hl_z_hl_2=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_2,a2_hl_z_hl_2);
 (        A1 +=> Z) = (a1_lh_z_lh_2,a1_hl_z_hl_2);
 (        B2 +=> Z) = (b2_lh_z_lh_1,b2_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_1,b1_hl_z_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor22d4.v
// Description          : 2/2 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module aor22d4 (B2,B1,A2,A1,Z);

output  Z;
input   B2,B1,A2,A1;

wire g_1_out,g_2_out;

and (g_1_out,B2,B1);
and (g_2_out,A2,A1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_z_lh_2=0,a1_hl_z_hl_2=0,a1_lh_z_lh_2=0,a2_hl_z_hl_2=0,
 b1_hl_z_hl_1=0,b1_lh_z_lh_1=0,b2_lh_z_lh_2=0,b2_hl_z_hl_2=0;
// Delays
 (        A2 +=> Z) = (a2_lh_z_lh_2,a2_hl_z_hl_2);
 (        A1 +=> Z) = (a1_lh_z_lh_2,a1_hl_z_hl_2);
 (        B1 +=> Z) = (b1_lh_z_lh_1,b1_hl_z_hl_1);
 (        B2 +=> Z) = (b2_lh_z_lh_2,b2_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor311d1.v
// Description  	:  3/1/1 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor311d1 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
or #1 (Z,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_4=0,a_hl_z_hl_4=0,b_lh_z_lh_4=0,b_hl_z_hl_4=0,
 c3_lh_z_lh=0,c2_hl_z_hl=0,c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c3_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        B  +=> Z) = (b_lh_z_lh_4,b_hl_z_hl_4);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor311d2.v
// Description  	:  3/1/1 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor311d2 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
or #1 (Z,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_z_lh_2=0,a_lh_z_lh_4=0,a_hl_z_hl_4=0,b_hl_z_hl_4=0,
 c3_lh_z_lh=0,c2_hl_z_hl=0,c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c3_hl_z_hl=0;
// Delays
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_4);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor311d4.v
// Description  	:  3/1/1 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor311d4 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_1_out;

and (g_1_out,C1,C3,C2);
or #1 (Z,g_1_out,B,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_lh_z_lh_2=0,a_lh_z_lh_4=0,a_hl_z_hl_4=0,b_hl_z_hl_4=0,
 c3_lh_z_lh=0,c2_hl_z_hl=0,c2_lh_z_lh=0,c1_hl_z_hl=0,c1_lh_z_lh=0,c3_hl_z_hl=0;
// Delays
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_4);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor31d1.v
// Description  	:  3/1 AND-OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor31d1 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_4=0,a_hl_z_hl_4=0,b3_lh_z_lh=0,b2_hl_z_hl=0,
 b2_lh_z_lh=0,b1_hl_z_hl=0,b1_lh_z_lh=0,b3_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor31d2.v
// Description  	:  3/1 AND-OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor31d2 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_4=0,a_hl_z_hl_4=0,b3_lh_z_lh=0,b2_hl_z_hl=0,
 b2_lh_z_lh=0,b1_hl_z_hl=0,b1_lh_z_lh=0,b3_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: aor31d4.v
// Description  	:  3/1 AND-OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module aor31d4 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_1_out;

and (g_1_out,B2,B1,B3);
or #1 (Z,g_1_out,A);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_z_lh_4=0,a_hl_z_hl_4=0,b3_lh_z_lh=0,b2_hl_z_hl=0,
 b2_lh_z_lh=0,b1_hl_z_hl=0,b1_lh_z_lh=0,b3_hl_z_hl=0;
// Delays
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif

// Model type   	: zero timing
// Filename     	: bh01d1.v
// Description  	:  REPEATER CELL
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bh01d1 (I);

   inout I;

   buf (weak0, weak1) (I,I);

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbd1.v
// Description  	:  Non-inverting Balanced Buffer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbd1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbd2.v
// Description  	:  Non-inverting Balanced Buffer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbd2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbd3.v
// Description  	:  Non-inverting Balanced Buffer, 3X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbd3 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbd4.v
// Description  	:  Non-inverting Balanced Buffer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbd4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbd7.v
// Description  	:  Non-inverting Balanced Buffer, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbd7 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbda.v
// Description  	:  Non-inverting Balanced Buffer, 10 X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module bufbda (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbdf.v
// Description          : Non-inverting Balanced Buffer, 15 X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module bufbdf (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: bufbdk.v
// Description          : Non-inverting Balanced Buffer, 20 X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module bufbdk (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffd1.v
// Description  	:  Non-inverting Buffer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffd1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffd2.v
// Description  	:  Non-inverting Buffer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffd2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffd3.v
// Description  	:  Non-inverting Buffer, 3X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffd3 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffd4.v
// Description  	:  Non-inverting Buffer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffd4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffd7.v
// Description  	:  Non-inverting Buffer, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffd7 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buffda.v
// Description  	:  Non-inverting Buffer, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buffda (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buftd1.v
// Description  	:  Non-inverting 3-State Buffer with Output Enable Bar, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buftd1 (EN,I,Z);

output  Z;
input   EN,I;

bufif0 #1 (Z,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_z_lz=0,en_hl_z_zl=0,i_lh_z_lh=0,en_lh_z_hz=0,
 en_hl_z_zh=0,i_hl_z_hl=0;
// Delays
 (        EN  => Z) = (en_lh_z_lz,en_lh_z_hz,en_lh_z_lz,en_hl_z_zh,en_lh_z_hz,en_hl_z_zl);
 (        I  +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buftd2.v
// Description  	:  Non-inverting 3-State Buffer with Output Enable Bar, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buftd2 (EN,I,Z);

output  Z;
input   EN,I;

bufif0 #1 (Z,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_z_lz=0,en_hl_z_zl=0,i_lh_z_lh=0,en_lh_z_hz=0,
 en_hl_z_zh=0,i_hl_z_hl=0;
// Delays
 (        EN  => Z) = (en_lh_z_lz,en_lh_z_hz,en_lh_z_lz,en_hl_z_zh,en_lh_z_hz,en_hl_z_zl);
 (        I  +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buftd4.v
// Description  	:  Non-inverting 3-State Buffer with Output Enable Bar, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module buftd4 (EN,I,Z);

output  Z;
input   EN,I;

bufif0 #1 (Z,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_z_lz=0,en_hl_z_zl=0,i_lh_z_lh=0,en_lh_z_hz=0,
 en_hl_z_zh=0,i_hl_z_hl=0;
// Delays
 (        EN  => Z) = (en_lh_z_lz,en_lh_z_hz,en_lh_z_lz,en_hl_z_zh,en_lh_z_hz,en_hl_z_zl);
 (        I  +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buftd7.v
// Description          : Non-inverting 3-State Buffer with Output Enable Bar, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module buftd7 (EN,I,Z);

output  Z;
input   EN,I;

bufif0 #1 (Z,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_z_lz=0,en_hl_z_zl=0,i_lh_z_lh=0,en_lh_z_hz=0,
 en_hl_z_zh=0,i_hl_z_hl=0;
// Delays
 (        EN  => Z) = (en_lh_z_lz,en_lh_z_hz,en_lh_z_lz,en_hl_z_zh,en_lh_z_hz,en_hl_z_zl);
 (        I  +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: buftda.v
// Description          : Non-inverting 3-State Buffer with Output Enable Bar, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module buftda (EN,I,Z);

output  Z;
input   EN,I;

bufif0 #1 (Z,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_z_lz=0,en_hl_z_zl=0,i_lh_z_lh=0,en_lh_z_hz=0,
 en_hl_z_zh=0,i_hl_z_hl=0;
// Delays
 (        EN  => Z) = (en_lh_z_lz,en_lh_z_hz,en_lh_z_lz,en_hl_z_zh,en_lh_z_hz,en_hl_z_zl);
 (        I  +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: cg01d0.v
// Description  	:  1-Bit Carry Generator, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module cg01d0 (A,B,CI,CO);

output  CO;
input   A,B,CI;

U_AO3 #1 cg01d0_CO(CO, A, B, CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_co_lh_1=0,a_hl_co_hl_1=0,b_hl_co_hl_1=0,b_lh_co_lh_1=0,
 ci_hl_co_hl_1=0,ci_lh_co_lh_2=0;
// Delays
 (        A  +=> CO) = (a_lh_co_lh_1,a_hl_co_hl_1);
 (        B  +=> CO) = (b_lh_co_lh_1,b_hl_co_hl_1);
 (        CI +=> CO) = (ci_lh_co_lh_2,ci_hl_co_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: cg01d1.v
// Description  	:  1-Bit Carry Generator, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module cg01d1 (A,B,CI,CO);

output  CO;
input   A,B,CI;

U_AO3 #1 cg01d1_CO(CO, A, B, CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_co_lh_1=0,a_hl_co_hl_1=0,b_hl_co_hl_1=0,b_lh_co_lh_1=0,
 ci_hl_co_hl_1=0,ci_lh_co_lh_2=0;
// Delays
 (        A  +=> CO) = (a_lh_co_lh_1,a_hl_co_hl_1);
 (        B  +=> CO) = (b_lh_co_lh_1,b_hl_co_hl_1);
 (        CI +=> CO) = (ci_lh_co_lh_2,ci_hl_co_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: cg01d2.v
// Description  	:  1-Bit Carry Generator, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module cg01d2 (A,B,CI,CO);

output  CO;
input   A,B,CI;

U_AO3 #1 cg01d2_CO(CO, A, B, CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_co_lh_1=0,a_hl_co_hl_1=0,b_hl_co_hl_1=0,b_lh_co_lh_1=0,
 ci_hl_co_hl_1=0,ci_lh_co_lh_2=0;
// Delays
 (        A  +=> CO) = (a_lh_co_lh_1,a_hl_co_hl_1);
 (        B  +=> CO) = (b_lh_co_lh_1,b_hl_co_hl_1);
 (        CI +=> CO) = (ci_lh_co_lh_2,ci_hl_co_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: cg01d4.v
// Description  	:  1-Bit Carry Generator, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module cg01d4 (A,B,CI,CO);

output  CO;
input   A,B,CI;

U_AO3 #1 cg01d4_CO(CO, A, B, CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_co_lh_1=0,a_hl_co_hl_1=0,b_hl_co_hl_1=0,b_lh_co_lh_1=0,
 ci_hl_co_hl_1=0,ci_lh_co_lh_2=0;
// Delays
 (        A  +=> CO) = (a_lh_co_lh_1,a_hl_co_hl_1);
 (        B  +=> CO) = (b_lh_co_lh_1,b_hl_co_hl_1);
 (        CI +=> CO) = (ci_lh_co_lh_2,ci_hl_co_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: clk2d2.v
// Description  	:  Non-overlapping dual phase Clock Generator, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module clk2d2 (CLK,C,CN);

output  C,CN;
input   CLK;

not inst_1(CN,CLK);
buf inst_2(C,CLK);

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_cn_hl=0,clk_lh_c_lh=0,clk_hl_c_hl=0,clk_hl_cn_lh=0;
// Delays
 (        CLK -=> CN) = (clk_hl_cn_lh,clk_lh_cn_hl);
 (        CLK +=> C ) = (clk_lh_c_lh,clk_hl_c_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif

// Model type   	: zero timing
// Filename     	: cload1.v
// Description  	:  CLOCK LOAD
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module cload1 (I);

   input I;

   wire DeadEnd;

   buf    E0(DeadEnd, I);

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decfq1.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decfq1 (CPN,CDN,D,ENN,Q);

output  Q;
input   CPN,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_RB #1 (Q,CPN,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_RB_NO #1 (Q,d_CPN,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_N_RB_NO #1 (Q,CPN,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.25,tsu_enn_l_cpn=0.46,tsu_d_h_cpn=0.24,tsu_d_l_cpn=0.39,
 tsu_cdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_cdn_l=0.37,tpw_cpn_l=0.32,tpw_cpn_h=0.34,tpw_cdn_l=0.20,cpn_hl_q_lh=0,
 cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
$setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),th_cpn_cdn_l,tsu_cdn_h_cpn,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decfq2.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decfq2 (CPN,CDN,D,ENN,Q);

output  Q;
input   CPN,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_RB #1 (Q,CPN,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_RB_NO #1 (Q,d_CPN,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_N_RB_NO #1 (Q,CPN,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.25,tsu_enn_l_cpn=0.45,tsu_d_h_cpn=0.23,tsu_d_l_cpn=0.38,
 tsu_cdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_cdn_l=0.37,tpw_cpn_l=0.35,tpw_cpn_h=0.34,tpw_cdn_l=0.23,cpn_hl_q_lh=0,
 cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
$setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decfq4.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decfq4 (CPN,CDN,D,ENN,Q);

output  Q;
input   CPN,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_RB #1 (Q,CPN,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_RB_NO #1 (Q,d_CPN,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_N_RB_NO #1 (Q,CPN,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.25,tsu_enn_l_cpn=0.46,tsu_d_h_cpn=0.24,tsu_d_l_cpn=0.39,
 tsu_cdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_cdn_l=0.37,tpw_cpn_l=0.32,tpw_cpn_h=0.34,tpw_cdn_l=0.20,cpn_hl_q_lh=0,
 cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
$setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
$setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),th_cpn_cdn_l,tsu_cdn_h_cpn,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decrq1.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decrq1 (CP,CDN,D,ENN,Q);

output  Q;
input   CP,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_RB #1 (Q,CP,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_P_RB_NO #1 (Q,CP,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.40,tsu_enn_l_cp=0.46,tsu_d_h_cp=0.33,tsu_d_l_cp=0.38,
 tsu_cdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_cdn_l=0.31,tpw_cp_h=0.23,tpw_cp_l=0.43,tpw_cdn_l=0.20,cp_lh_q_lh=0,
 cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decrq2.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decrq2 (CP,CDN,D,ENN,Q);

output  Q;
input   CP,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_RB #1 (Q,CP,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_P_RB_NO #1 (Q,CP,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.39,tsu_enn_l_cp=0.47,tsu_d_h_cp=0.30,tsu_d_l_cp=0.34,
 tsu_cdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_cdn_l=0.30,tpw_cp_h=0.24,tpw_cp_l=0.42,tpw_cdn_l=0.22,cp_lh_q_lh=0,
 cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: decrq4.v
// Description  	:  Buffered Enabled D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module decrq4 (CP,CDN,D,ENN,Q);

output  Q;
input   CP,CDN,D,ENN;

wire CDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_RB #1 (Q,CP,ENN,CDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_CDN,d_D,notifier);
`else
U_FD_EN_P_RB_NO #1 (Q,CP,ENN,CDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((CDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.40,tsu_enn_l_cp=0.46,tsu_d_h_cp=0.33,tsu_d_l_cp=0.38,
 tsu_cdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_cdn_l=0.31,tpw_cp_h=0.23,tpw_cp_l=0.43,tpw_cdn_l=0.20,cp_lh_q_lh=0,
 cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
$recrem (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (CDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (CDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge CDN &&& (ENN==1'b0),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((CDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: denrq1.v
// Description  	:  Buffered Enabled D Flip-Flop with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module denrq1 (CP,D,ENN,Q);

output  Q;
input   CP,D,ENN;

wire D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_NO #1 (Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (Q,CP,ENN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.36,tsu_enn_l_cp=0.45,tsu_d_h_cp=0.27,tsu_d_l_cp=0.37,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.23,
 tpw_cp_l=0.41,cp_lh_q_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: denrq2.v
// Description  	:  Buffered Enabled D Flip-Flop with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module denrq2 (CP,D,ENN,Q);

output  Q;
input   CP,D,ENN;

wire D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_NO #1 (Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (Q,CP,ENN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.36,tsu_enn_l_cp=0.45,tsu_d_h_cp=0.27,tsu_d_l_cp=0.37,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.23,
 tpw_cp_l=0.41,cp_lh_q_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: denrq4.v
// Description  	:  Buffered Enabled D Flip-Flop with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module denrq4 (CP,D,ENN,Q);

output  Q;
input   CP,D,ENN;

wire D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_NO #1 (Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (Q,CP,ENN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.36,tsu_enn_l_cp=0.45,tsu_d_h_cp=0.27,tsu_d_l_cp=0.37,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.23,
 tpw_cp_l=0.41,cp_lh_q_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
$setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
$setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
$setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: depfq1.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module depfq1 (CPN,SDN,D,ENN,Q);

output  Q;
input   CPN,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_SB #1 (Q,CPN,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_SB_NO #1 (Q,d_CPN,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_N_SB_NO #1 (Q,CPN,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.23,tsu_enn_l_cpn=0.45,tsu_d_h_cpn=0.27,tsu_d_l_cpn=0.38,
 tsu_sdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.14,tpw_cpn_l=0.35,tpw_cpn_h=0.34,tpw_sdn_l=0.32,cpn_hl_q_hl=0,
 cpn_hl_q_lh=0,sdn_hl_q_lh_5=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_5,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: depfq2.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module depfq2 (CPN,SDN,D,ENN,Q);

output  Q;
input   CPN,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_SB #1 (Q,CPN,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_SB_NO #1 (Q,d_CPN,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_N_SB_NO #1 (Q,CPN,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.24,tsu_enn_l_cpn=0.45,tsu_d_h_cpn=0.26,tsu_d_l_cpn=0.36,
 tsu_sdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.14,tpw_cpn_l=0.37,tpw_cpn_h=0.32,tpw_sdn_l=0.32,cpn_hl_q_hl=0,
 cpn_hl_q_lh=0,sdn_hl_q_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: depfq4.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module depfq4 (CPN,SDN,D,ENN,Q);

output  Q;
input   CPN,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_N_SB #1 (Q,CPN,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_N_SB_NO #1 (Q,d_CPN,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_N_SB_NO #1 (Q,CPN,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cpn=0.23,tsu_enn_l_cpn=0.45,tsu_d_h_cpn=0.27,tsu_d_l_cpn=0.38,
 tsu_sdn_h_cpn=0.00,th_cpn_enn_h=0.00,th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.14,tpw_cpn_l=0.35,tpw_cpn_h=0.34,tpw_sdn_l=0.32,cpn_hl_q_hl=0,
 cpn_hl_q_lh=0,sdn_hl_q_lh_5=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),negedge CPN &&& (ENN==1'b0),tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (negedge CPN  => (Q +: BOOL_OUT)) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_5,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: deprq1.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module deprq1 (CP,SDN,D,ENN,Q);

output  Q;
input   CP,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_SB #1 (Q,CP,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_P_SB_NO #1 (Q,CP,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.38,tsu_enn_l_cp=0.45,tsu_d_h_cp=0.31,tsu_d_l_cp=0.38,
 tsu_sdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.13,tpw_cp_h=0.25,tpw_cp_l=0.44,tpw_sdn_l=0.28,cp_lh_q_hl=0,
 sdn_hl_q_lh_1=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: deprq2.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module deprq2 (CP,SDN,D,ENN,Q);

output  Q;
input   CP,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_SB #1 (Q,CP,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_P_SB_NO #1 (Q,CP,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.38,tsu_enn_l_cp=0.46,tsu_d_h_cp=0.32,tsu_d_l_cp=0.39,
 tsu_sdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.13,tpw_cp_h=0.27,tpw_cp_l=0.44,tpw_sdn_l=0.31,cp_lh_q_hl=0,
 cp_lh_q_lh=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: deprq4.v
// Description  	:  Buffered Enabled D Flip-Flop with Preset and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module deprq4 (CP,SDN,D,ENN,Q);

output  Q;
input   CP,SDN,D,ENN;

wire SDN_buf,D_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P_SB #1 (Q,CP,ENN,SDN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SDN,d_D,notifier);
`else
U_FD_EN_P_SB_NO #1 (Q,CP,ENN,SDN,D,notifier);
`endif
`endif

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
wire vcond1 = ((SDN_buf==1'b1) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.38,tsu_enn_l_cp=0.45,tsu_d_h_cp=0.31,tsu_d_l_cp=0.38,
 tsu_sdn_h_cp=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.13,tpw_cp_h=0.25,tpw_cp_l=0.44,tpw_sdn_l=0.28,cp_lh_q_hl=0,
 sdn_hl_q_lh_1=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (SDN==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (SDN==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge SDN &&& (ENN==1'b0),th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if ((SDN==1'b1) && (ENN==1'b0))
 (posedge CP   => (Q +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbfb1.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbfb1 (D,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN,CDN;

wire not_SDN,not_CDN,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,D,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
U_FD_N_R_S_NO_QN #1 (QN,d_D,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,d_D,d_CPN,d_CDN,d_SDN,notifier);
`else
not (not_SDN,SDN);
not (not_CDN,CDN);
U_FD_N_R_S_NO_QN #1 (QN,D,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,D,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.15,tsu_d_l_cpn=0.24,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,
 th_cpn_d_h=0.00,th_cpn_d_l=0.06,th_cpn_sdn_l=0.13,th_cpn_cdn_l=0.33,tpw_cpn_l=0.40,
 tpw_cpn_h=0.39,tpw_sdn_l=0.32,tpw_cdn_l=0.30,cdn_hl_qn_lh_1=0,sdn_lh_qn_lh_1=0,
 sdn_hl_qn_hl_2=0,sdn_hl_q_lh_1=0,cdn_hl_q_hl_1=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0,
 cdn_lh_q_lh_1=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_2);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbfb2.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbfb2 (D,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN,CDN;

wire not_SDN,not_CDN,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,D,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
U_FD_N_R_S_NO_QN #1 (QN,d_D,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,d_D,d_CPN,d_CDN,d_SDN,notifier);
`else
not (not_SDN,SDN);
not (not_CDN,CDN);
U_FD_N_R_S_NO_QN #1 (QN,D,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,D,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.15,tsu_d_l_cpn=0.24,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,
 th_cpn_d_h=0.00,th_cpn_d_l=0.06,th_cpn_sdn_l=0.13,th_cpn_cdn_l=0.32,tpw_cpn_l=0.49,
 tpw_cpn_h=0.38,tpw_sdn_l=0.35,tpw_cdn_l=0.33,cdn_hl_qn_lh_1=0,sdn_lh_qn_lh_1=0,
 sdn_hl_qn_hl_2=0,sdn_hl_q_lh_1=0,cdn_hl_q_hl_1=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0,
 cdn_lh_q_lh_1=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_2);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbfb4.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbfb4 (D,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN,CDN;

wire not_SDN,not_CDN,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,D,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
U_FD_N_R_S_NO_QN #1 (QN,d_D,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,d_D,d_CPN,d_CDN,d_SDN,notifier);
`else
not (not_SDN,SDN);
not (not_CDN,CDN);
U_FD_N_R_S_NO_QN #1 (QN,D,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,D,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.15,tsu_d_l_cpn=0.24,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,
 th_cpn_d_h=0.00,th_cpn_d_l=0.06,th_cpn_sdn_l=0.13,th_cpn_cdn_l=0.33,tpw_cpn_l=0.40,
 tpw_cpn_h=0.39,tpw_sdn_l=0.32,tpw_cdn_l=0.30,cdn_hl_qn_lh_1=0,sdn_lh_qn_lh_1=0,
 sdn_hl_qn_hl_2=0,sdn_hl_q_lh_1=0,cdn_hl_q_hl_1=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0,
 cdn_lh_q_lh_1=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (vcond1==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (vcond1==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_2);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbrb1.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbrb1 (D,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CP,SDN,CDN;

wire not_CP,not_CDN,not_SDN;
wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,D,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,d_D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,d_D,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,D,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.16,tsu_d_l_cp=0.22,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.16,th_cp_cdn_l=0.31,tpw_cp_h=0.29,
 tpw_cp_l=0.43,tpw_sdn_l=0.36,tpw_cdn_l=0.25,sdn_lh_qn_lh_1=0,cp_lh_qn_lh=0,
 cp_lh_q_hl=0,sdn_hl_qn_hl_3=0,sdn_hl_q_lh_2=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0,
 cdn_lh_q_lh_1=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_3);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_2,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbrb2.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbrb2 (D,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CP,SDN,CDN;

wire not_CP,not_SDN,not_CDN,CDN_buf,SDN_buf;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,D,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,d_D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,d_D,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,D,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.16,tsu_d_l_cp=0.22,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.15,th_cp_cdn_l=0.30,tpw_cp_h=0.37,
 tpw_cp_l=0.44,tpw_sdn_l=0.47,tpw_cdn_l=0.35,sdn_lh_qn_lh_1=0,cp_lh_qn_lh=0,
 cp_lh_q_hl=0,sdn_hl_qn_hl_3=0,sdn_hl_q_lh_2=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0,
 cdn_lh_q_lh_1=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_3);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_2,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfbrb4.v
// Description  	:  Buffered D Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfbrb4 (D,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,CP,SDN,CDN;

wire not_CP,not_SDN,not_CDN,CDN_buf,SDN_buf;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,D,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,D,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,d_D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,d_D,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,D,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,D,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.16,tsu_d_l_cp=0.22,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.16,th_cp_cdn_l=0.31,tpw_cp_h=0.29,
 tpw_cp_l=0.43,tpw_sdn_l=0.36,tpw_cdn_l=0.25,sdn_lh_qn_lh_1=0,cp_lh_qn_lh=0,
 cp_lh_q_hl=0,sdn_hl_qn_hl_3=0,sdn_hl_q_lh_2=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0,
 cdn_lh_q_lh_1=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_3);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_2,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfb1.v
// Description  	:  Buffered D Flip-Flop with Clear, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfb1 (D,CPN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,D,CPN,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.10,tsu_d_l_cpn=0.22,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.09,th_cpn_cdn_l=0.32,tpw_cpn_l=0.32,tpw_cpn_h=0.34,tpw_cdn_l=0.26,
 cpn_hl_qn_hl=0,cpn_hl_q_lh=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (CDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfb2.v
// Description  	:  Buffered D Flip-Flop with Clear, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfb2 (D,CPN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,D,CPN,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.11,tsu_d_l_cpn=0.21,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.10,th_cpn_cdn_l=0.30,tpw_cpn_l=0.39,tpw_cpn_h=0.34,tpw_cdn_l=0.29,
 cpn_hl_qn_hl=0,cpn_hl_q_lh=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (CDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfb4.v
// Description  	:  Buffered D Flip-Flop with Clear, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfb4 (D,CPN,CDN,Q,QN);

output  Q,QN;
input   D,CPN,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,D,CPN,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.10,tsu_d_l_cpn=0.22,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.09,th_cpn_cdn_l=0.32,tpw_cpn_l=0.32,tpw_cpn_h=0.34,tpw_cdn_l=0.26,
 cpn_hl_qn_hl=0,cpn_hl_q_lh=0,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (CDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfq1.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfq1 (D,CPN,CDN,Q);

output  Q;
input   D,CPN,CDN;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,D,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.00,tsu_d_l_cpn=0.21,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.14,th_cpn_cdn_l=0.35,tpw_cpn_l=0.30,tpw_cpn_h=0.34,tpw_cdn_l=0.20,
 cpn_hl_q_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfq2.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfq2 (D,CPN,CDN,Q);

output  Q;
input   D,CPN,CDN;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif


`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,D,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.00,tsu_d_l_cpn=0.21,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.14,th_cpn_cdn_l=0.35,tpw_cpn_l=0.32,tpw_cpn_h=0.34,tpw_cdn_l=0.22,
 cpn_hl_q_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcfq4.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcfq4 (D,CPN,CDN,Q);

output  Q;
input   D,CPN,CDN;

`ifdef neg_tchk
wire d_D,d_CPN,d_CDN;
`endif


`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,D,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,d_D,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,D,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.00,tsu_d_l_cpn=0.21,tsu_cdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.14,th_cpn_cdn_l=0.35,tpw_cpn_l=0.30,tpw_cpn_h=0.34,tpw_cdn_l=0.20,
 cpn_hl_q_lh=0,cpn_hl_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrb1.v
// Description  	:  Buffered D Flip-Flop with Clear, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrb1 (D,CP,CDN,Q,QN);

output  Q,QN;
input   D,CP,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,D,CP,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.11,tsu_d_l_cp=0.19,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.28,tpw_cp_h=0.27,tpw_cp_l=0.38,tpw_cdn_l=0.30,
 cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrb2.v
// Description  	:  Buffered D Flip-Flop with Clear, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrb2 (D,CP,CDN,Q,QN);

output  Q,QN;
input   D,CP,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,D,CP,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.11,tsu_d_l_cp=0.19,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.26,tpw_cp_h=0.33,tpw_cp_l=0.38,tpw_cdn_l=0.41,
 cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrb4.v
// Description  	:  Buffered D Flip-Flop with Clear, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrb4 (D,CP,CDN,Q,QN);

output  Q,QN;
input   D,CP,CDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,D,CP,CDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.11,tsu_d_l_cp=0.19,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.28,tpw_cp_h=0.27,tpw_cp_l=0.38,tpw_cdn_l=0.30,
 cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrn1.v
// Description  	:  Buffered D Flip-Flop with Clear and QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrn1 (D,CP,CDN,QN);

output  QN;
input   D,CP,CDN;

wire QN_not;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,D,CP,CDN,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.12,tsu_d_l_cp=0.22,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.33,tpw_cp_h=0.26,tpw_cp_l=0.43,tpw_cdn_l=0.23,
 cp_lh_qn_hl=0,cp_lh_qn_lh=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrn2.v
// Description  	:  Buffered D Flip-Flop with Clear and QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrn2 (D,CP,CDN,QN);

output  QN;
input   D,CP,CDN;

wire QN_not;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,D,CP,CDN,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.12,tsu_d_l_cp=0.22,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.31,tpw_cp_h=0.28,tpw_cp_l=0.42,tpw_cdn_l=0.23,
 cp_lh_qn_hl=0,cp_lh_qn_lh=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrn4.v
// Description  	:  Buffered D Flip-Flop with Clear and QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrn4 (D,CP,CDN,QN);

output  QN;
input   D,CP,CDN;

wire QN_not;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,D,CP,CDN,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.12,tsu_d_l_cp=0.22,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.33,tpw_cp_h=0.26,tpw_cp_l=0.43,tpw_cdn_l=0.23,
 cp_lh_qn_hl=0,cp_lh_qn_lh=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrq1.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrq1 (D,CP,CDN,Q);

output  Q;
input   D,CP,CDN;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,D,CP,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.14,tsu_d_l_cp=0.17,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.29,tpw_cp_h=0.25,tpw_cp_l=0.37,tpw_cdn_l=0.20,
 cp_lh_q_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrq2.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrq2 (D,CP,CDN,Q);

output  Q;
input   D,CP,CDN;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,D,CP,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.14,tsu_d_l_cp=0.18,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.29,tpw_cp_h=0.26,tpw_cp_l=0.37,tpw_cdn_l=0.22,
 cp_lh_q_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfcrq4.v
// Description  	:  Buffered D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfcrq4 (D,CP,CDN,Q);

output  Q;
input   D,CP,CDN;

`ifdef neg_tchk
wire d_D,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,D,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,d_D,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,D,CP,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.14,tsu_d_l_cp=0.17,tsu_cdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_cdn_l=0.29,tpw_cp_h=0.25,tpw_cp_l=0.37,tpw_cdn_l=0.20,
 cp_lh_q_lh=0,cp_lh_q_hl=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnfb1.v
// Description  	:  Buffered D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnfb1 (D,CPN,Q,QN);

output  Q,QN;
input   D,CPN;

wire buf_Q;

`ifdef neg_tchk
wire d_CPN,d_D;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,D,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,d_D,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,D,CPN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.04,tsu_d_l_cpn=0.18,th_cpn_d_h=0.00,th_cpn_d_l=0.10,
 tpw_cpn_l=0.39,tpw_cpn_h=0.30,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold(negedge CPN, posedge D, tsu_d_h_cpn, th_cpn_d_l, notifier,,,d_CPN,d_D);
 $setuphold(negedge CPN, negedge D, tsu_d_l_cpn, th_cpn_d_h, notifier,,,d_CPN,d_D);
`else
 $setup (posedge D,negedge CPN,tsu_d_h_cpn,notifier);
 $setup (negedge D,negedge CPN,tsu_d_l_cpn,notifier);
 $hold  (negedge CPN,negedge D,th_cpn_d_h,notifier);
 $hold  (negedge CPN,posedge D,th_cpn_d_l,notifier);
`endif
 $width (negedge CPN,tpw_cpn_l,0,notifier);
 $width (posedge CPN,tpw_cpn_h,0,notifier);
// Delays
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnfb2.v
// Description  	:  Buffered D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnfb2 (D,CPN,Q,QN);

output  Q,QN;
input   D,CPN;

wire buf_Q;

`ifdef neg_tchk
wire d_CPN,d_D;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,D,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,d_D,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,D,CPN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.03,tsu_d_l_cpn=0.18,th_cpn_d_h=0.00,th_cpn_d_l=0.11,
 tpw_cpn_l=0.50,tpw_cpn_h=0.30,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold(negedge CPN, posedge D, tsu_d_h_cpn, th_cpn_d_l, notifier,,,d_CPN,d_D);
 $setuphold(negedge CPN, negedge D, tsu_d_l_cpn, th_cpn_d_h, notifier,,,d_CPN,d_D);
`else
 $setup (posedge D,negedge CPN,tsu_d_h_cpn,notifier);
 $setup (negedge D,negedge CPN,tsu_d_l_cpn,notifier);
 $hold  (negedge CPN,negedge D,th_cpn_d_h,notifier);
 $hold  (negedge CPN,posedge D,th_cpn_d_l,notifier);
`endif
 $width (negedge CPN,tpw_cpn_l,0,notifier);
 $width (posedge CPN,tpw_cpn_h,0,notifier);
// Delays
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnfb4.v
// Description  	:  Buffered D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnfb4 (D,CPN,Q,QN);

output  Q,QN;
input   D,CPN;

wire buf_Q;

`ifdef neg_tchk
wire d_CPN,d_D;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,D,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,d_D,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,D,CPN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.04,tsu_d_l_cpn=0.18,th_cpn_d_h=0.00,th_cpn_d_l=0.10,
 tpw_cpn_l=0.39,tpw_cpn_h=0.30,cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold(negedge CPN, posedge D, tsu_d_h_cpn, th_cpn_d_l, notifier,,,d_CPN,d_D);
 $setuphold(negedge CPN, negedge D, tsu_d_l_cpn, th_cpn_d_h, notifier,,,d_CPN,d_D);
`else
 $setup (posedge D,negedge CPN,tsu_d_h_cpn,notifier);
 $setup (negedge D,negedge CPN,tsu_d_l_cpn,notifier);
 $hold  (negedge CPN,negedge D,th_cpn_d_h,notifier);
 $hold  (negedge CPN,posedge D,th_cpn_d_l,notifier);
`endif
 $width (negedge CPN,tpw_cpn_l,0,notifier);
 $width (posedge CPN,tpw_cpn_h,0,notifier);
// Delays
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrb1.v
// Description  	:  Buffered D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrb1 (D,CP,Q,QN);

output  Q,QN;
input   D,CP;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,D,CP,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.15,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.24,tpw_cp_l=0.40,cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (posedge CP  => (Q  +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrb2.v
// Description  	:  Buffered D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrb2 (D,CP,Q,QN);

output  Q,QN;
input   D,CP;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,D,CP,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.13,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.32,tpw_cp_l=0.41,cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (posedge CP  => (Q  +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrb4.v
// Description  	:  Buffered D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrb4 (D,CP,Q,QN);

output  Q,QN;
input   D,CP;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,D,CP,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.15,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.24,tpw_cp_l=0.40,cp_lh_qn_hl=0,cp_lh_q_lh=0,cp_lh_qn_lh=0,cp_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 (posedge CP  => (Q  +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrn1.v
// Description  	:  Buffered D Flip-Flop with QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrn1 (CP,D,QN);

output  QN;
input   CP,D;

wire QN_not;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (QN_not,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,D,CP,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.17,tsu_d_l_cp=0.17,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.22,tpw_cp_l=0.40,cp_lh_qn_lh=0,cp_lh_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrn2.v
// Description  	:  Buffered D Flip-Flop with QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrn2 (CP,D,QN);

output  QN;
input   CP,D;

wire QN_not;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (QN_not,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,D,CP,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.14,tsu_d_l_cp=0.18,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.24,tpw_cp_l=0.41,cp_lh_qn_hl=0,cp_lh_qn_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrn4.v
// Description  	:  Buffered D Flip-Flop with QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrn4 (CP,D,QN);

output  QN;
input   CP,D;

wire QN_not;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (QN_not,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,D,CP,notifier);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.17,tsu_d_l_cp=0.17,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.22,tpw_cp_l=0.40,cp_lh_qn_lh=0,cp_lh_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: D  )) = (cp_lh_qn_lh,cp_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrq1.v
// Description  	:  Buffered D Flip-Flop with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrq1 (CP,D,Q);

output  Q;
input   CP,D;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,D,CP,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.09,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.27,tpw_cp_l=0.32,cp_lh_q_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrq2.v
// Description  	:  Buffered D Flip-Flop with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrq2 (CP,D,Q);

output  Q;
input   CP,D;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,D,CP,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.08,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.31,tpw_cp_l=0.32,cp_lh_q_lh=0,cp_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfnrq4.v
// Description  	:  Buffered D Flip-Flop with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfnrq4 (CP,D,Q);

output  Q;
input   CP,D;

`ifdef neg_tchk
wire d_CP,d_D;
`endif

`ifdef functional
U_FD_P #1 (Q,D,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,d_D,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,D,CP,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.09,tsu_d_l_cp=0.16,th_cp_d_h=0.00,th_cp_d_l=0.00,
 tpw_cp_h=0.27,tpw_cp_l=0.32,cp_lh_q_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge D,tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP,negedge D,tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge D,posedge CP,tsu_d_h_cp,notifier);
 $setup (negedge D,posedge CP,tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge D,th_cp_d_h,notifier);
 $hold  (posedge CP,posedge D,th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D  )) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfpfb1.v
// Description  	:  Buffered D Flip-Flop with Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfpfb1 (D,CPN,SDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,D,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,d_D,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,D,CPN,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.06,tsu_d_l_cpn=0.21,tsu_sdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.11,th_cpn_sdn_l=0.20,tpw_cpn_l=0.38,tpw_cpn_h=0.37,tpw_sdn_l=0.42,
 cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0,sdn_hl_qn_hl_2=0,sdn_hl_q_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else 
 $setup (posedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (SDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_2);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfpfb2.v
// Description  	:  Buffered D Flip-Flop with Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfpfb2 (D,CPN,SDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,D,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,d_D,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,D,CPN,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.08,tsu_d_l_cpn=0.22,tsu_sdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.12,th_cpn_sdn_l=0.19,tpw_cpn_l=0.48,tpw_cpn_h=0.36,tpw_sdn_l=0.35,
 cpn_hl_qn_lh=0,cpn_hl_q_hl=0,sdn_hl_qn_hl_1=0,sdn_hl_q_lh_1=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (SDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfpfb4.v
// Description  	:  Buffered D Flip-Flop with Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfpfb4 (D,CPN,SDN,Q,QN);

output  Q,QN;
input   D,CPN,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,D,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,d_D,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,D,CPN,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cpn=0.06,tsu_d_l_cpn=0.21,tsu_sdn_h_cpn=0.00,th_cpn_d_h=0.00,
 th_cpn_d_l=0.11,th_cpn_sdn_l=0.20,tpw_cpn_l=0.38,tpw_cpn_h=0.37,tpw_sdn_l=0.42,
 cpn_hl_qn_lh=0,cpn_hl_q_hl=0,cpn_hl_qn_hl=0,cpn_hl_q_lh=0,sdn_hl_qn_hl_2=0,sdn_hl_q_lh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else 
 $setup (posedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN  => (QN -: D   )) = (cpn_hl_qn_lh,cpn_hl_qn_hl);
 if (SDN==1'b1)
 (negedge CPN  => (Q  +: D   )) = (cpn_hl_q_lh,cpn_hl_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_2);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfprb1.v
// Description  	:  Buffered D Flip-Flop with Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfprb1 (D,CP,SDN,Q,QN);

output  Q,QN;
input   D,CP,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,D,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,d_D,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,D,CP,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.13,tsu_d_l_cp=0.20,tsu_sdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_sdn_l=0.21,tpw_cp_h=0.28,tpw_cp_l=0.41,tpw_sdn_l=0.32,
 cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0,sdn_hl_qn_hl_1=0,sdn_hl_q_lh_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_3,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfprb2.v
// Description  	:  Buffered D Flip-Flop with Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfprb2 (D,CP,SDN,Q,QN);

output  Q,QN;
input   D,CP,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,D,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,d_D,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,D,CP,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.13,tsu_d_l_cp=0.21,tsu_sdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_sdn_l=0.20,tpw_cp_h=0.36,tpw_cp_l=0.41,tpw_sdn_l=0.43,
 cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0,sdn_hl_qn_hl_1=0,sdn_hl_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dfprb4.v
// Description  	:  Buffered D Flip-Flop with Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module dfprb4 (D,CP,SDN,Q,QN);

output  Q,QN;
input   D,CP,SDN;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,D,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,d_D,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,D,CP,SDN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_cp=0.13,tsu_d_l_cp=0.20,tsu_sdn_h_cp=0.00,th_cp_d_h=0.00,
 th_cp_d_l=0.00,th_cp_sdn_l=0.21,tpw_cp_h=0.28,tpw_cp_l=0.41,tpw_sdn_l=0.32,
 cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0,sdn_hl_qn_hl_1=0,sdn_hl_q_lh_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge D &&& (SDN==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge D &&& (SDN==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: D   )) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: D   )) = (cp_lh_q_lh,cp_lh_q_hl);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_3,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl01d1.v
// Description  	:  Non Inverting Delay Buffer with 1X Delay, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl01d1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl01d2.v
// Description  	:  Non Inverting Delay Buffer with 1X Delay, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl01d2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl01d4.v
// Description  	:  Non Inverting Delay Buffer with 1X Delay, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl01d4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl02d1.v
// Description  	:  Non Inverting Delay Buffer with 2X Delay, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl02d1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl02d2.v
// Description  	:  Non Inverting Delay Buffer with 2X Delay, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl02d2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl02d4.v
// Description  	:  Non Inverting Delay Buffer with 2X Delay, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl02d4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl03d1.v
// Description  	:  Non Inverting Delay Buffer with 4X Delay, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl03d1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl03d2.v
// Description  	:  Non Inverting Delay Buffer with 4X Delay, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl03d2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////


`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl03d4.v
// Description  	:  Non Inverting Delay Buffer with 4X Delay, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl03d4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl04d1.v
// Description  	:  Non Inverting Delay Buffer with 8X Delay, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl04d1 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl04d2.v
// Description  	:  Non Inverting Delay Buffer with 8X Delay, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module dl04d2 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: dl04d4.v
// Description  	:  Non Inverting Delay Buffer with 8X Delay, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.7
//
//


module dl04d4 (I,Z);

output  Z;
input   I;

buf #1 (Z,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_z_lh=0,i_hl_z_hl=0;
// Delays
 (        I +=> Z) = (i_lh_z_lh,i_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclfsn1.v
// Description  	:  latch_negedge_postcontrol clock gating cells, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclfsn1 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_P #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_P_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,init,SE);
`ifdef neg_tchk
or (GCLK,init_2,d_CLK);
`else
or (GCLK,init_2,CLK);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_h=0.24,clk_hl_gclk_lh=0,clk_hl_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (negedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,negedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,negedge CLK ,tsu_en_l_clk,notifier);
 $hold  (negedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (negedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (posedge CLK ,tpw_clk_h,0,notifier);
// Delays
 if (SE==1'b0)
 (negedge CLK  => (GCLK -: EN )) = (clk_hl_gclk_lh,clk_hl_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclfsn2.v
// Description  	:  latch_negedge_postcontrol clock gating cells, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclfsn2 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_P #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_P_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,init,SE);
`ifdef neg_tchk
or (GCLK,init_2,d_CLK);
`else
or (GCLK,init_2,CLK);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_h=0.24,clk_hl_gclk_lh=0,clk_hl_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (negedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,negedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,negedge CLK ,tsu_en_l_clk,notifier);
 $hold  (negedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (negedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (posedge CLK ,tpw_clk_h,0,notifier);
// Delays
 if (SE==1'b0)
 (negedge CLK  => (GCLK -: EN )) = (clk_hl_gclk_lh,clk_hl_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclfsn4.v
// Description  	:  latch_negedge_postcontrol clock gating cells, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclfsn4 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_P #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_P_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,init,SE);
`ifdef neg_tchk
or (GCLK,init_2,d_CLK);
`else
or (GCLK,init_2,CLK);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_h=0.24,clk_hl_gclk_lh=0,clk_hl_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (negedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,negedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,negedge CLK ,tsu_en_l_clk,notifier);
 $hold  (negedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (negedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (posedge CLK ,tpw_clk_h,0,notifier);
// Delays
 if (SE==1'b0)
 (negedge CLK  => (GCLK -: EN )) = (clk_hl_gclk_lh,clk_hl_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclfsn7.v
// Description  	:  latch_negedge_postcontrol clock gating cells, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclfsn7 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_P #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_P_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,init,SE);
`ifdef neg_tchk
or (GCLK,init_2,d_CLK);
`else
or (GCLK,init_2,CLK);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_h=0.24,clk_hl_gclk_lh=0,clk_hl_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (negedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,negedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,negedge CLK ,tsu_en_l_clk,notifier);
 $hold  (negedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (negedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (posedge CLK ,tpw_clk_h,0,notifier);
// Delays
 if (SE==1'b0)
 (negedge CLK  => (GCLK -: EN )) = (clk_hl_gclk_lh,clk_hl_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclfsna.v
// Description  	:  latch_negedge_postcontrol clock gating cells, aX Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclfsna (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_P #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_P_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,init,SE);
`ifdef neg_tchk
or (GCLK,init_2,d_CLK);
`else
or (GCLK,init_2,CLK);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_h=0.24,clk_hl_gclk_lh=0,clk_hl_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (negedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,negedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,negedge CLK ,tsu_en_l_clk,notifier);
 $hold  (negedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (negedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (posedge CLK ,tpw_clk_h,0,notifier);
// Delays
 if (SE==1'b0)
 (negedge CLK  => (GCLK -: EN )) = (clk_hl_gclk_lh,clk_hl_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclrsn1.v
// Description  	:  latch_posedge_postcontrol clock gating cells, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclrsn1 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2,NOT_CLK;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_N #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_N_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,SE,init);
`ifdef neg_tchk
not (NOT_CLK,d_CLK);
`else
not (NOT_CLK,CLK);
`endif
nor (GCLK,NOT_CLK,init_2);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_l=0.24,clk_lh_gclk_lh=0,clk_lh_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (posedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,posedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,posedge CLK ,tsu_en_l_clk,notifier);
 $hold  (posedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (posedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (negedge CLK ,tpw_clk_l,0,notifier);
// Delays
 if (SE==1'b0)
 (posedge CLK  => (GCLK +: EN )) = (clk_lh_gclk_lh,clk_lh_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclrsn2.v
// Description  	:  latch_posedge_postcontrol clock gating cells, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclrsn2 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2,NOT_CLK;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_N #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_N_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,SE,init);
`ifdef neg_tchk
not (NOT_CLK,d_CLK);
`else
not (NOT_CLK,CLK);
`endif
nor (GCLK,NOT_CLK,init_2);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_l=0.24,clk_lh_gclk_lh=0,clk_lh_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (posedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,posedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,posedge CLK ,tsu_en_l_clk,notifier);
 $hold  (posedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (posedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (negedge CLK ,tpw_clk_l,0,notifier);
// Delays
 if (SE==1'b0)
 (posedge CLK  => (GCLK +: EN )) = (clk_lh_gclk_lh,clk_lh_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclrsn4.v
// Description  	:  latch_posedge_postcontrol clock gating cells, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclrsn4 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2,NOT_CLK;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_N #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_N_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,SE,init);
`ifdef neg_tchk
not (NOT_CLK,d_CLK);
`else
not (NOT_CLK,CLK);
`endif
nor (GCLK,NOT_CLK,init_2);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_l=0.24,clk_lh_gclk_lh=0,clk_lh_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (posedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,posedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,posedge CLK ,tsu_en_l_clk,notifier);
 $hold  (posedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (posedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (negedge CLK ,tpw_clk_l,0,notifier);
// Delays
 if (SE==1'b0)
 (posedge CLK  => (GCLK +: EN )) = (clk_lh_gclk_lh,clk_lh_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclrsn7.v
// Description  	:  latch_posedge_postcontrol clock gating cells, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclrsn7 (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2,NOT_CLK;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_N #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_N_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,SE,init);
`ifdef neg_tchk
not (NOT_CLK,d_CLK);
`else
not (NOT_CLK,CLK);
`endif
nor (GCLK,NOT_CLK,init_2);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_l=0.24,clk_lh_gclk_lh=0,clk_lh_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (posedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,posedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,posedge CLK ,tsu_en_l_clk,notifier);
 $hold  (posedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (posedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (negedge CLK ,tpw_clk_l,0,notifier);
// Delays
 if (SE==1'b0)
 (posedge CLK  => (GCLK +: EN )) = (clk_lh_gclk_lh,clk_lh_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gclrsna.v
// Description  	:  latch_posedge_postcontrol clock gating cells, aX Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module gclrsna (EN,CLK,SE,GCLK);

output  GCLK;
input   EN,SE,CLK;

wire init,init_2,NOT_CLK;

`ifdef neg_tchk
wire d_CLK,d_EN;
`endif


`ifdef functional
U_LD_N #1 (init,EN,CLK);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (init,d_EN,d_CLK,notifier);
`else
U_LD_N_NO #1 (init,EN,CLK,notifier);
`endif
`endif

nor (init_2,SE,init);
`ifdef neg_tchk
not (NOT_CLK,d_CLK);
`else
not (NOT_CLK,CLK);
`endif
nor (GCLK,NOT_CLK,init_2);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_en_h_clk=0.04,tsu_en_l_clk=0.16,th_clk_en_h=0.00,th_clk_en_l=0.00,tpw_clk_l=0.24,clk_lh_gclk_lh=0,clk_lh_gclk_hl=0,se_gclk_lh=0,se_gclk_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CLK ,posedge EN ,tsu_en_h_clk,th_clk_en_l,notifier,,,d_CLK,d_EN);
 $setuphold (posedge CLK ,negedge EN ,tsu_en_l_clk,th_clk_en_h,notifier,,,d_CLK,d_EN);
`else
 $setup (posedge EN ,posedge CLK ,tsu_en_h_clk,notifier);
 $setup (negedge EN ,posedge CLK ,tsu_en_l_clk,notifier);
 $hold  (posedge CLK ,negedge EN ,th_clk_en_h,notifier);
 $hold  (posedge CLK ,posedge EN ,th_clk_en_l,notifier);
`endif
 $width (negedge CLK ,tpw_clk_l,0,notifier);
// Delays
 if (SE==1'b0)
 (posedge CLK  => (GCLK +: EN )) = (clk_lh_gclk_lh,clk_lh_gclk_hl);
 (SE => GCLK) = (se_gclk_lh,se_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnfnn1.v
// Description  	:  none_negedge clock gating cells, 1X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnfnn1 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
and #1 (GCLK,CLK,EN);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = EN && CLK;
  end
end 
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_hl=0,en_lh_gclk_lh=0,
  tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (posedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (posedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
 (        EN +=> GCLK) = (en_lh_gclk_lh,en_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnfnn2.v
// Description  	:  none_negedge clock gating cells, 2X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnfnn2 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
and #1 (GCLK,CLK,EN);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = EN && CLK;
  end
end 
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_hl=0,en_lh_gclk_lh=0,
  tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (posedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (posedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
 (        EN +=> GCLK) = (en_lh_gclk_lh,en_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnfnn4.v
// Description  	:  none_negedge clock gating cells, 4X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnfnn4 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
and #1 (GCLK,CLK,EN);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = EN && CLK;
  end
end 
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_hl=0,en_lh_gclk_lh=0,
  tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (posedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (posedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
 (        EN +=> GCLK) = (en_lh_gclk_lh,en_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnfnn7.v
// Description  	:  none_negedge clock gating cells, 7X DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnfnn7 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
and #1 (GCLK,CLK,EN);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = EN && CLK;
  end
end 
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_hl=0,en_lh_gclk_lh=0,
  tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (posedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (posedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
 (        EN +=> GCLK) = (en_lh_gclk_lh,en_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnfnna.v
// Description  	:  none_negedge clock gating cells, aX DRIVE
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnfnna (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
and #1 (GCLK,CLK,EN);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = EN && CLK;
  end
end 
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_hl=0,en_lh_gclk_lh=0,
  tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (posedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (posedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
 (        EN +=> GCLK) = (en_lh_gclk_lh,en_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnrnn1.v
// Description  	:  none_posedge clock gating cells, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnrnn1 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
not (not_EN,EN);
or #1 (GCLK,not_EN,CLK);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = ~EN || CLK;
  end
end
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_gclk_hl=0,clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_lh=0,
 tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (negedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (negedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        EN -=> GCLK) = (en_hl_gclk_lh,en_lh_gclk_hl);
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnrnn2.v
// Description  	:  none_posedge clock gating cells, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnrnn2 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
not (not_EN,EN);
or #1 (GCLK,not_EN,CLK);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = ~EN || CLK;
  end
end
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_gclk_hl=0,clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_lh=0,
 tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (negedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (negedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        EN -=> GCLK) = (en_hl_gclk_lh,en_lh_gclk_hl);
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnrnn4.v
// Description  	:  none_posedge clock gating cells, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnrnn4 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
not (not_EN,EN);
or #1 (GCLK,not_EN,CLK);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = ~EN || CLK;
  end
end
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_gclk_hl=0,clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_lh=0,
 tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (negedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (negedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        EN -=> GCLK) = (en_hl_gclk_lh,en_lh_gclk_hl);
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnrnn7.v
// Description  	:  none_posedge clock gating cells, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnrnn7 (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
not (not_EN,EN);
or #1 (GCLK,not_EN,CLK);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = ~EN || CLK;
  end
end
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_gclk_hl=0,clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_lh=0,
 tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (negedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (negedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        EN -=> GCLK) = (en_hl_gclk_lh,en_lh_gclk_hl);
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: gcnrnna.v
// Description  	:  none_posedge clock gating cells, aX Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module gcnrnna (CLK,EN,GCLK);

output  GCLK;
input   CLK,EN;

`ifdef functional
not (not_EN,EN);
or #1 (GCLK,not_EN,CLK);
`else
reg notifier,buf_gclk,mem_notifier;
always @(notifier or EN or CLK) begin
  if (notifier !== 1'bx && mem_notifier !== notifier) begin
   buf_gclk = 1'bx;
   mem_notifier = notifier;
  end
  else begin
   buf_gclk = ~EN || CLK;
  end
end
buf #1 (GCLK,buf_gclk);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_gclk_hl=0,clk_lh_gclk_lh=0,clk_hl_gclk_hl=0,en_hl_gclk_lh=0,
 tpw_clk_h=0,tpw_clk_l=0,en_lh_clk_lh=0,en_lh_clk_hl=0,en_hl_clk_lh=0,
  en_hl_clk_hl=0;
$nochange (negedge CLK,posedge EN,en_lh_clk_lh,en_hl_clk_lh,notifier);
$nochange (negedge CLK,negedge EN,en_hl_clk_hl,en_lh_clk_hl,notifier);
$width (posedge CLK,tpw_clk_h,0,notifier);
$width (negedge CLK,tpw_clk_l,0,notifier);
// Delays
 (        EN -=> GCLK) = (en_hl_gclk_lh,en_lh_gclk_hl);
 (        CLK +=> GCLK) = (clk_lh_gclk_lh,clk_hl_gclk_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0d0.v
// Description  	:  Inverting Buffer, Min Inp Cap/Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0d0 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0d1.v
// Description  	:  Inverting Buffer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0d1 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0d2.v
// Description  	:  Inverting Buffer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0d2 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0d4.v
// Description  	:  Inverting Buffer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0d4 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0d7.v
// Description  	:  Inverting Buffer, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0d7 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: inv0da.v
// Description  	:  Inverting Buffer, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module inv0da (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbd2.v
// Description  	:  Inverting Buffer with Balanced Rise/Fall Time, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invbd2 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbd4.v
// Description  	:  Inverting Buffer with Balanced Rise/Fall Time, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invbd4 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbd7.v
// Description  	:  Inverting Buffer with Balanced Rise/Fall Time, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invbd7 (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbda.v
// Description          : Inverting Buffer with Balanced Rise/Fall Time, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module invbda (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbdf.v
// Description          : Inverting Buffer with Balanced Rise/Fall Time, 15X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module invbdf (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invbdk.v
// Description          : Inverting Buffer with Balanced Rise/Fall Time, 20X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module invbdk (I,ZN);

output  ZN;
input   I;

not #1 (ZN,I);

`ifdef functional
`else
specify
// Parameter declarations
 specparam i_lh_zn_hl=0,i_hl_zn_lh=0;
// Delays
 (        I -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invtd1.v
// Description  	:  Inverting 3-State Buffer with Output Enable, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invtd1 (I,ZN,EN);

output  ZN;
input   I,EN;

notif0 #1 (ZN,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_zn_hz=0,en_hl_zn_zh=0,i_lh_zn_hl=0,en_lh_zn_lz=0,
 en_hl_zn_zl=0,i_hl_zn_lh=0;
// Delays
 (        EN  => ZN) = (en_lh_zn_lz,en_lh_zn_hz,en_lh_zn_lz,en_hl_zn_zh,en_lh_zn_hz,en_hl_zn_zl);
 (        I  -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invtd2.v
// Description  	:  Inverting 3-State Buffer with Output Enable, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invtd2 (I,ZN,EN);

output  ZN;
input   I,EN;

notif0 #1 (ZN,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_zn_hz=0,en_hl_zn_zh=0,i_lh_zn_hl=0,en_lh_zn_lz=0,
 en_hl_zn_zl=0,i_hl_zn_lh=0;
// Delays
 (        EN  => ZN) = (en_lh_zn_lz,en_lh_zn_hz,en_lh_zn_lz,en_hl_zn_zh,en_lh_zn_hz,en_hl_zn_zl);
 (        I  -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invtd4.v
// Description  	:  Inverting 3-State Buffer with Output Enable, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invtd4 (I,ZN,EN);

output  ZN;
input   I,EN;

notif0 #1 (ZN,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_zn_hz=0,en_hl_zn_zh=0,i_lh_zn_hl=0,en_lh_zn_lz=0,
 en_hl_zn_zl=0,i_hl_zn_lh=0;
// Delays
 (        EN  => ZN) = (en_lh_zn_lz,en_lh_zn_hz,en_lh_zn_lz,en_hl_zn_zh,en_lh_zn_hz,en_hl_zn_zl);
 (        I  -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invtd7.v
// Description  	:  Inverting 3-State Buffer with Output Enable, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invtd7 (I,ZN,EN);

output  ZN;
input   I,EN;

notif0 #1 (ZN,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_zn_hz=0,en_hl_zn_zh=0,i_lh_zn_hl=0,en_lh_zn_lz=0,
 en_hl_zn_zl=0,i_hl_zn_lh=0;
// Delays
 (        EN  => ZN) = (en_lh_zn_lz,en_lh_zn_hz,en_lh_zn_lz,en_hl_zn_zh,en_lh_zn_hz,en_hl_zn_zl);
 (        I  -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: invtda.v
// Description  	:  Inverting 3-State Buffer with Output Enable, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module invtda (I,ZN,EN);

output  ZN;
input   I,EN;

notif0 #1 (ZN,I,EN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam en_lh_zn_hz=0,en_hl_zn_zh=0,i_lh_zn_hl=0,en_lh_zn_lz=0,
 en_hl_zn_zl=0,i_hl_zn_lh=0;
// Delays
 (        EN  => ZN) = (en_lh_zn_lz,en_lh_zn_hz,en_lh_zn_lz,en_hl_zn_zh,en_lh_zn_hz,en_hl_zn_zl);
 (        I  -=> ZN) = (i_hl_zn_lh,i_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: jkbrb1.v
// Description          : Buffered JKZ Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//

module jkbrb1 (J,KZ,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,CP,SDN,CDN;
wire temp,not_temp,not_J,not_KZ,not_CP,not_CDN,not_SDN;
wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp,temp);

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,not_temp,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.32,tsu_j_l_cp=0.26,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.18,th_cp_cdn_l=0.26,tpw_cp_h=0.28,tpw_cp_l=0.41,
 tpw_sdn_l=0.47,tpw_cdn_l=0.38,cdn_hl_qn_lh_1=0,cdn_hl_q_hl_1=0,sdn_lh_qn_lh_3=0,
 cdn_lh_q_lh_3=0,sdn_hl_qn_hl_5=0,sdn_hl_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_3,cdn_hl_q_hl_1);
 (        SDN +=> QN) = (sdn_lh_qn_lh_3,sdn_hl_qn_hl_5);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((J && ~Q) || (KZ && Q)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((J && ~Q) || (KZ && Q)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: jkbrb2.v
// Description  	:  Buffered JKZ Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//

module jkbrb2 (J,KZ,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,CP,SDN,CDN;
wire temp,not_temp,not_J,not_KZ,not_CP,not_CDN,not_SDN;
wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp,temp);

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,not_temp,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.29,tsu_j_l_cp=0.25,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.17,th_cp_cdn_l=0.24,tpw_cp_h=0.35,tpw_cp_l=0.41,
 tpw_sdn_l=0.59,tpw_cdn_l=0.46,sdn_lh_qn_lh_1=0,cdn_lh_q_lh_1=0,sdn_hl_qn_hl_5=0,
 sdn_hl_q_lh_1=0,cdn_hl_q_hl_4=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_qn_lh_2=0,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_5);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_4);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((J && ~Q) || (KZ && Q)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((J && ~Q) || (KZ && Q)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_2,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: jkbrb4.v
// Description          : Buffered JKZ Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//

module jkbrb4 (J,KZ,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,CP,SDN,CDN;
wire temp,not_temp,not_J,not_KZ,not_CP,not_CDN,not_SDN;
wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp,temp);

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,not_temp,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,not_temp,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.32,tsu_j_l_cp=0.26,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.18,th_cp_cdn_l=0.26,tpw_cp_h=0.28,tpw_cp_l=0.41,
 tpw_sdn_l=0.47,tpw_cdn_l=0.38,cdn_hl_qn_lh_1=0,cdn_hl_q_hl_1=0,sdn_lh_qn_lh_3=0,
 cdn_lh_q_lh_3=0,sdn_hl_qn_hl_5=0,sdn_hl_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge KZ &&& (vcond1==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge KZ &&& (vcond1==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge J &&& (vcond1==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge J &&& (vcond1==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond1==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond1==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_3,cdn_hl_q_hl_1);
 (        SDN +=> QN) = (sdn_lh_qn_lh_3,sdn_hl_qn_hl_5);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((J && ~Q) || (KZ && Q)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((J && ~Q) || (KZ && Q)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: labhb1.v
// Description  	:  Buffered Latch with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module labhb1 (E,D,CDN,SDN,Q,QN);

output  Q,QN;
input   E,D,CDN,SDN;

wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_E,d_D,d_CDN,d_SDN;
`endif

`ifdef functional
U_LD_P_SB_RB_QN #1 (QN,D,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,D,E,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_SB_RB_QN_NO #1 (QN,d_D,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,d_D,d_E,d_CDN,d_SDN,notifier);
`else
U_LD_P_SB_RB_QN_NO #1 (QN,D,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,D,E,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.13,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 cdn_hl_qn_lh_6=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (        CDN -=> QN) = (cdn_hl_qn_lh_6,cdn_lh_qn_hl_5);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: D   )) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: D   )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: labhb2.v
// Description  	:  Buffered Latch with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module labhb2 (E,D,CDN,SDN,Q,QN);

output  Q,QN;
input   E,D,CDN,SDN;


wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_E,d_D,d_CDN,d_SDN;
`endif

`ifdef functional
U_LD_P_SB_RB_QN #1 (QN,D,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,D,E,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_SB_RB_QN_NO #1 (QN,d_D,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,d_D,d_E,d_CDN,d_SDN,notifier);
`else
U_LD_P_SB_RB_QN_NO #1 (QN,D,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,D,E,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.14,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,cdn_hl_qn_lh_3=0,d_lh_q_lh=0,
 d_lh_qn_hl=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (        CDN -=> QN) = (cdn_hl_qn_lh_3,cdn_lh_qn_hl_5);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: D   )) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: D   )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: labhb4.v
// Description  	:  Buffered Latch with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module labhb4 (E,D,CDN,SDN,Q,QN);

output  Q,QN;
input   E,D,CDN,SDN;


wire SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_E,d_D,d_CDN,d_SDN;
`endif

`ifdef functional
U_LD_P_SB_RB_QN #1 (QN,D,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,D,E,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_SB_RB_QN_NO #1 (QN,d_D,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,d_D,d_E,d_CDN,d_SDN,notifier);
`else
U_LD_P_SB_RB_QN_NO #1 (QN,D,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,D,E,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.13,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 cdn_hl_qn_lh_6=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        D   -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (        CDN -=> QN) = (cdn_hl_qn_lh_6,cdn_lh_qn_hl_5);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: D   )) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: D   )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lachq1.v
// Description  	:  High Enable D latch with clear and output Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lachq1 (E,D,CDN,Q);

output  Q;
input   E,D,CDN;

`ifdef neg_tchk
wire d_E,d_D,d_CDN;
`endif

`ifdef functional
U_LD_P_RB #1 (Q,D,E,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,d_E,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,E,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.03,tsu_d_l_e=0.16,tsu_cdn_h_e=0.03,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.15,tpw_cdn_l=0.25,e_lh_q_lh=0,
 e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_e_d_l,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if (CDN==1'b1)
 (posedge E    => (Q +: D   )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lachq2.v
// Description  	:  High Enable D latch with clear and output Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lachq2 (E,D,CDN,Q);

output  Q;
input   E,D,CDN;

`ifdef neg_tchk
wire d_E,d_D,d_CDN;
`endif

`ifdef functional
U_LD_P_RB #1 (Q,D,E,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,d_E,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,E,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.08,tsu_d_l_e=0.20,tsu_cdn_h_e=0.07,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.18,tpw_cdn_l=0.32,e_lh_q_lh=0,
 e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_e_d_l,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if (CDN==1'b1)
 (posedge E    => (Q +: D   )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lachq4.v
// Description  	:  High Enable D latch with clear and output Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lachq4 (E,D,CDN,Q);

output  Q;
input   E,D,CDN;

`ifdef neg_tchk
wire d_E,d_D,d_CDN;
`endif

`ifdef functional
U_LD_P_RB #1 (Q,D,E,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,d_E,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,E,CDN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.03,tsu_d_l_e=0.16,tsu_cdn_h_e=0.03,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.15,tpw_cdn_l=0.25,e_lh_q_lh=0,
 e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_e_d_l,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if (CDN==1'b1)
 (posedge E    => (Q +: D   )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: laclq1.v
// Description  	:  Buffered Latch with Low Enable, Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module laclq1 (EN,D,CDN,Q);

output  Q;
input   EN,D,CDN;

wire not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_CDN;
`endif

`ifdef functional
U_LD_N_RB #1 (Q,D,EN,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,not_EN,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,not_EN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
not (not_EN,d_EN);
`else
not (not_EN,EN);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.23,tsu_d_l_en=0.17,tsu_cdn_h_en=0.22,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.27,tpw_cdn_l=0.23,cdn_lh_q_lh=0,
 d_hl_q_hl=0,d_lh_q_lh=0,en_hl_q_hl=0,cdn_hl_q_hl_2=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_2);
 if ((EN==1'b0) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN   => (Q +: D   )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: laclq2.v
// Description  	:  Buffered Latch with Low Enable, Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module laclq2 (EN,D,CDN,Q);

output  Q;
input   EN,D,CDN;

wire not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_CDN;
`endif

`ifdef functional
U_LD_N_RB #1 (Q,D,EN,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,not_EN,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,not_EN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
not (not_EN,d_EN);
`else
not (not_EN,EN);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.28,tsu_d_l_en=0.23,tsu_cdn_h_en=0.28,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.32,tpw_cdn_l=0.31,cdn_lh_q_lh=0,
 d_hl_q_hl=0,d_lh_q_lh=0,en_hl_q_hl=0,cdn_hl_q_hl_2=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_2);
 if ((EN==1'b0) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN   => (Q +: D   )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: laclq4.v
// Description  	:  Buffered Latch with Low Enable, Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module laclq4 (EN,D,CDN,Q);

output  Q;
input   EN,D,CDN;

wire not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_CDN;
`endif

`ifdef functional
U_LD_N_RB #1 (Q,D,EN,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_RB_NO #1 (Q,d_D,not_EN,d_CDN,notifier);
`else
U_LD_P_RB_NO #1 (Q,D,not_EN,CDN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
not (not_EN,d_EN);
`else
not (not_EN,EN);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.23,tsu_d_l_en=0.17,tsu_cdn_h_en=0.22,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.27,tpw_cdn_l=0.23,cdn_lh_q_lh=0,
 d_hl_q_hl=0,d_lh_q_lh=0,en_hl_q_hl=0,cdn_hl_q_hl_2=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_d_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge D &&& (CDN==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge D &&& (CDN==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_2);
 if ((EN==1'b0) && (CDN==1'b1))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN   => (Q +: D   )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhb1.v
// Description  	:  Buffered Latch, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhb1 (D,E,Q,QN);

output  Q,QN;
input   D,E;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif

`ifdef functional
U_LD_P #1 (buf_Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (buf_Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (buf_Q,D,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tpw_e_h=0.21,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (Q  +: D )) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhb2.v
// Description  	:  Buffered Latch, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhb2 (D,E,Q,QN);

output  Q,QN;
input   D,E;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif

`ifdef functional
U_LD_P #1 (buf_Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (buf_Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (buf_Q,D,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.20,th_e_d_h=0.00,th_e_d_l=0.12,
 tpw_e_h=0.28,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (Q  +: D )) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhb4.v
// Description  	:  Buffered Latch, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhb4 (D,E,Q,QN);

output  Q,QN;
input   D,E;

wire buf_Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif

`ifdef functional
U_LD_P #1 (buf_Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (buf_Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (buf_Q,D,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tpw_e_h=0.21,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (Q  +: D )) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhn1.v
// Description  	:  Buffered Latch with QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhn1 (E,D,QN);

output  QN;
input   E,D;

wire QN_not;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P (QN_not,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO (QN_not,d_D,d_E,notifier);
`else
U_LD_P_NO (QN_not,D,E,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.24,tsu_d_l_e=0.16,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.21,d_lh_qn_hl=0,d_hl_qn_lh=0,e_lh_qn_hl=0,e_lh_qn_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
 `endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhn2.v
// Description  	:  Buffered Latch with QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhn2 (E,D,QN);

output  QN;
input   E,D;

wire QN_not;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P (QN_not,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO (QN_not,d_D,d_E,notifier);
`else
U_LD_P_NO (QN_not,D,E,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.31,tsu_d_l_e=0.21,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.24,d_lh_qn_hl=0,d_hl_qn_lh=0,e_lh_qn_hl=0,e_lh_qn_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
 `endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhn4.v
// Description  	:  Buffered Latch with QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhn4 (E,D,QN);

output  QN;
input   E,D;

wire QN_not;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P (QN_not,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO (QN_not,d_D,d_E,notifier);
`else
U_LD_P_NO (QN_not,D,E,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.24,tsu_d_l_e=0.16,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.21,d_lh_qn_hl=0,d_hl_qn_lh=0,e_lh_qn_hl=0,e_lh_qn_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
 `endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (posedge E  => (QN -: D )) = (e_lh_qn_lh,e_lh_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhq1.v
// Description  	:  Buffered Latch with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhq1 (E,D,Q);

output  Q;
input   E,D;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P #1 (Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (Q,D,E,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.16,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.24,d_hl_q_hl=0,d_lh_q_lh=0,e_lh_q_lh=0,e_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (posedge E  => (Q +: D )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhq2.v
// Description  	:  Buffered Latch with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhq2 (E,D,Q);

output  Q;
input   E,D;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P #1 (Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (Q,D,E,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.08,tsu_d_l_e=0.21,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.29,d_hl_q_hl=0,d_lh_q_lh=0,e_lh_q_lh=0,e_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (posedge E  => (Q +: D )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanhq4.v
// Description  	:  Buffered Latch with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanhq4 (E,D,Q);

output  Q;
input   E,D;

`ifdef neg_tchk
wire d_E,d_D;
`endif

`ifdef functional
U_LD_P #1 (Q,D,E);
`else
reg notifier;
`ifdef neg_tchk
U_LD_P_NO #1 (Q,d_D,d_E,notifier);
`else
U_LD_P_NO #1 (Q,D,E,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.16,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.24,d_hl_q_hl=0,d_lh_q_lh=0,e_lh_q_lh=0,e_lh_q_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 if (E==1'b1)
 (        D +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (posedge E  => (Q +: D )) = (e_lh_q_lh,e_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanht1.v
// Description  	:  Minimum Tristate Latch with Z-output only and Active Higher Enable, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to E 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module lanht1 (D,E,OE,Z);

output  Z;
input   D,E,OE;

wire D_buf,E_buf,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif


`ifdef functional
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P #1 (Q,D_buf,E_buf);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;

`ifdef neg_tchk
buf b_D (D_buf,d_D);
buf b_E (E_buf,d_E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.18,th_e_d_h=0.00,th_e_d_l=0.01,
 tpw_e_h=0.25,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zl_1=0,d_hl_z_hl=0,
 e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0,oe_lh_z_zh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_2,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (posedge E   => (Z+:D) ) = (e_lh_z_lh,e_lh_z_hl);
endspecify
`endif



endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanht2.v
// Description  	:  Minimum Tristate Latch with Z-output only and Active Higher Enable, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to E 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module lanht2 (D,E,OE,Z);

output  Z;
input   D,E,OE;

wire D_buf,E_buf,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif



`ifdef functional
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P #1 (Q,D_buf,E_buf);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;

`ifdef neg_tchk
buf b_D (D_buf,d_D);
buf b_E (E_buf,d_E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.12,tsu_d_l_e=0.23,th_e_d_h=0.00,th_e_d_l=0.00,
 tpw_e_h=0.31,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zh_1=0,oe_lh_z_zl_1=0,
 d_hl_z_hl=0,e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_1,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (posedge E   => (Z+:D)) = (e_lh_z_lh,e_lh_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanht4.v
// Description  	:  Minimum Tristate Latch with Z-output only and Active Higher Enable, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to E 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module lanht4 (D,E,OE,Z);

output  Z;
input   D,E,OE;

wire D_buf,E_buf,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_E;
`endif


`ifdef functional
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P #1 (Q,D_buf,E_buf);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;

`ifdef neg_tchk
buf b_D (D_buf,d_D);
buf b_E (E_buf,d_E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_D (D_buf,D);
buf b_E (E_buf,E);
buf b_OE (OE_buf,OE);
U_LD_P_NO #1 (Q,D_buf,E_buf,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.18,th_e_d_h=0.00,th_e_d_l=0.01,
 tpw_e_h=0.25,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zl_1=0,d_hl_z_hl=0,
 e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0,oe_lh_z_zh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E,posedge D,tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E,negedge D,tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge D,negedge E,tsu_d_h_e,notifier);
 $setup (negedge D,negedge E,tsu_d_l_e,notifier);
 $hold  (negedge E,negedge D,th_e_d_h,notifier);
 $hold  (negedge E,posedge D,th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_2,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (posedge E   => (Z +:D)) = (e_lh_z_lh,e_lh_z_hl);
endspecify
`endif



endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlb1.v
// Description  	:  Buffered Latch with Low Enable, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlb1 (EN,D,Q,QN);

output  Q,QN;
input   EN,D;

wire buf_Q;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (buf_Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (buf_Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (buf_Q,D,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.17,tsu_d_l_en=0.20,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.37,d_lh_q_lh=0,d_lh_qn_hl=0,d_hl_q_hl=0,d_hl_qn_lh=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (Q  +: D  )) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlb2.v
// Description  	:  Buffered Latch with Low Enable, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlb2 (EN,D,Q,QN);

output  Q,QN;
input   EN,D;

wire buf_Q;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (buf_Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (buf_Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (buf_Q,D,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.26,tsu_d_l_en=0.28,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.46,d_lh_q_lh=0,d_lh_qn_hl=0,d_hl_q_hl=0,d_hl_qn_lh=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (Q  +: D  )) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlb4.v
// Description  	:  Buffered Latch with Low Enable, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlb4 (EN,D,Q,QN);

output  Q,QN;
input   EN,D;

wire buf_Q;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (buf_Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (buf_Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (buf_Q,D,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.17,tsu_d_l_en=0.20,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.37,d_lh_q_lh=0,d_lh_qn_hl=0,d_hl_q_hl=0,d_hl_qn_lh=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (Q  +: D  )) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanln1.v
// Description  	:  Buffered Latch with Low Enable and QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanln1 (EN,D,QN);

output  QN;
input   EN,D;

wire QN_not;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N (QN_not,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO (QN_not,d_D,d_EN,notifier);
`else
U_LD_N_NO (QN_not,D,EN,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.21,tsu_d_l_en=0.27,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.26,d_lh_qn_hl=0,d_hl_qn_lh=0,en_hl_qn_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps


////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanln2.v
// Description  	:  Buffered Latch with Low Enable and QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanln2 (EN,D,QN);

output  QN;
input   EN,D;

wire QN_not;

`ifdef neg_tchk
wire d_EN,d_D;
`endif


`ifdef functional
U_LD_N (QN_not,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO (QN_not,d_D,d_EN,notifier);
`else
U_LD_N_NO (QN_not,D,EN,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.26,tsu_d_l_en=0.31,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.30,d_lh_qn_hl=0,d_hl_qn_lh=0,en_hl_qn_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanln4.v
// Description  	:  Buffered Latch with Low Enable and QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanln4 (EN,D,QN);

output  QN;
input   EN,D;

wire QN_not;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N (QN_not,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO (QN_not,d_D,d_EN,notifier);
`else
U_LD_N_NO (QN_not,D,EN,notifier);
`endif
`endif

not #1 (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.21,tsu_d_l_en=0.27,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.26,d_lh_qn_hl=0,d_hl_qn_lh=0,en_hl_qn_lh=0,en_hl_qn_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 (negedge EN  => (QN -: D  )) = (en_hl_qn_lh,en_hl_qn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps


////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlq1.v
// Description  	:  Buffered Latch with Low Enable and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlq1 (EN,D,Q);

output  Q;
input   EN,D;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (Q,D,EN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.11,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.29,d_lh_q_lh=0,d_hl_q_hl=0,en_hl_q_hl=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (negedge EN  => (Q +: D  )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlq2.v
// Description  	:  Buffered Latch with Low Enable and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlq2 (EN,D,Q);

output  Q;
input   EN,D;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (Q,D,EN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.14,tsu_d_l_en=0.19,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.34,d_lh_q_lh=0,d_hl_q_hl=0,en_hl_q_hl=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (negedge EN  => (Q +: D  )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: lanlq4.v
// Description  	:  Buffered Latch with Low Enable and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module lanlq4 (EN,D,Q);

output  Q;
input   EN,D;

`ifdef neg_tchk
wire d_EN,d_D;
`endif

`ifdef functional
U_LD_N #1 (Q,D,EN);
`else
reg notifier;
`ifdef neg_tchk
U_LD_N_NO #1 (Q,d_D,d_EN,notifier);
`else
U_LD_N_NO #1 (Q,D,EN,notifier);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.11,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.00,
 tpw_en_l=0.29,d_lh_q_lh=0,d_hl_q_hl=0,en_hl_q_hl=0,en_hl_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN,posedge D,tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN,negedge D,tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge D,posedge EN,tsu_d_h_en,notifier);
 $setup (negedge D,posedge EN,tsu_d_l_en,notifier);
 $hold  (posedge EN,negedge D,th_en_d_h,notifier);
 $hold  (posedge EN,posedge D,th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
// Delays
 if (EN==1'b0)
 (        D  +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 (negedge EN  => (Q +: D  )) = (en_hl_q_lh,en_hl_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mffnrb1.v
// Description  	:  Buffered Enabled D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mffnrb1 (CP,D,ENN,Q,QN);

output  Q,QN;
input   CP,D,ENN;

wire D_buf,ENN_buf,buf_Q;

`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (buf_Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk
U_FD_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (buf_Q,CP,ENN,D,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.40,tsu_enn_l_cp=0.54,tsu_d_h_cp=0.20,tsu_d_l_cp=0.42,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.21,
 tpw_cp_l=0.47,cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (QN -: BOOL_OUT)) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (ENN==1'b0)
 (posedge CP  => (Q  +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mffnrb2.v
// Description  	:  Buffered Enabled D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mffnrb2 (CP,D,ENN,Q,QN);

output  Q,QN;
input   CP,D,ENN;

wire D_buf,ENN_buf,buf_Q;


`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (buf_Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk 
U_FD_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (buf_Q,CP,ENN,D,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.40,tsu_enn_l_cp=0.55,tsu_d_h_cp=0.19,tsu_d_l_cp=0.43,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.24,
 tpw_cp_l=0.47,cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (QN -: BOOL_OUT)) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (ENN==1'b0)
 (posedge CP  => (Q  +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mffnrb4.v
// Description  	:  Buffered Enabled D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mffnrb4 (CP,D,ENN,Q,QN);

output  Q,QN;
input   CP,D,ENN;

wire D_buf,ENN_buf,buf_Q;

`ifdef neg_tchk
wire d_CP,d_D,d_ENN;
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (D_buf,d_D);
buf (ENN_buf,d_ENN);
`else
buf (D_buf,D);
buf (ENN_buf,ENN);
`endif
`endif

`ifdef functional
U_FD_EN_P #1 (buf_Q,CP,ENN,D);
`else
reg notifier;
`ifdef neg_tchk 
U_FD_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_D,notifier);
`else
U_FD_EN_P_NO #1 (buf_Q,CP,ENN,D,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
wire BOOL_OUT = (((!ENN_buf && D_buf)) && ((!ENN_buf))) || !(!Q || ((!ENN_buf)));
specify
// Parameter declarations
 specparam tsu_enn_h_cp=0.40,tsu_enn_l_cp=0.54,tsu_d_h_cp=0.20,tsu_d_l_cp=0.42,
 th_cp_enn_h=0.00,th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.21,
 tpw_cp_l=0.47,cp_lh_qn_lh=0,cp_lh_q_hl=0,cp_lh_qn_hl=0,cp_lh_q_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP,posedge ENN,tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN,tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge ENN,posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN,posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (ENN==1'b0),posedge CP &&& (ENN==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP,negedge ENN,th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN,th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),negedge D &&& (ENN==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (ENN==1'b0),posedge D &&& (ENN==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP &&& (ENN==1'b0),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (ENN==1'b0),tpw_cp_l,0,notifier);
// Delays
 if (ENN==1'b0)
 (posedge CP  => (QN -: BOOL_OUT)) = (cp_lh_qn_lh,cp_lh_qn_hl);
 if (ENN==1'b0)
 (posedge CP  => (Q  +: BOOL_OUT)) = (cp_lh_q_lh,cp_lh_q_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mi02d0.v
// Description          : 2-to-1 Multiplexer, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module mi02d0 (I0,I1,S,ZN);

output  ZN;
input   I0,I1,S;

U_MUX_2_1_INV #1 (ZN,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((I1 == 1'b0) && (I0 == 1'b1))
	(S => ZN) = (default_rise,default_fall);
if ((I1 == 1'b1) && (I0 == 1'b0))
	(S => ZN) = (default_rise,default_fall);
ifnone (S => ZN) = (default_rise,default_fall);
 (        I0 -=> ZN) = (default_rise,default_fall);
 (        I1 -=> ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mi02d1.v
// Description  	:  2-to-1 Multiplexer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mi02d1 (I0,I1,S,ZN);

output  ZN;
input   I0,I1,S;

U_MUX_2_1_INV #1 (ZN,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((I1 == 1'b0) && (I0 == 1'b1))
	(S => ZN) = (default_rise,default_fall);
if ((I1 == 1'b1) && (I0 == 1'b0))
	(S => ZN) = (default_rise,default_fall);
ifnone (S => ZN) = (default_rise,default_fall);
 (        I0 -=> ZN) = (default_rise,default_fall);
 (        I1 -=> ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mi02d2.v
// Description  	:  2-to-1 Multiplexer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mi02d2 (I0,I1,S,ZN);

output  ZN;
input   I0,I1,S;

U_MUX_2_1_INV #1 (ZN,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((I1 == 1'b0) && (I0 == 1'b1))
	(S => ZN) = (default_rise,default_fall);
if ((I1 == 1'b1) && (I0 == 1'b0))
	(S => ZN) = (default_rise,default_fall);
ifnone (S => ZN) = (default_rise,default_fall);
 (        I0 -=> ZN) = (default_rise,default_fall);
 (        I1 -=> ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mi02d4.v
// Description  	:  2-to-1 Inverting Multiplexer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mi02d4 (I0,I1,S,ZN);

output  ZN;
input   I0,I1,S;

U_MUX_2_1_INV #1 (ZN,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((I1 == 1'b0) && (I0 == 1'b1))
	(S => ZN) = (default_rise,default_fall);
if ((I1 == 1'b1) && (I0 == 1'b0))
	(S => ZN) = (default_rise,default_fall);
ifnone (S => ZN) = (default_rise,default_fall);
 (        I0 -=> ZN) = (default_rise,default_fall);
 (        I1 -=> ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

// ************* UDP For Synopsys Verilog Models ************ 
// **********************************************************

// Filename             : synopsys_UDP.v
// Library              : tsl18fs120
// Programmer           : ycui
// Date                 : 08-Oct-2003
// Product version      : Rev. main.1 
// Master version       : Rev. main.4


// V1.0   : Jul,2002   Initial Version Create by Haimin Hua
//                     Support to Tetra-MAX


primitive U_AO3 (CO, A, B, CI);

    input A, B, CI ;
    output CO;

// FUNCTION : CARRY GENERATOR TERM
 
  table
 
// A      B      CI :  CO
   
   1      1      ?  :  1;
   1      ?      1  :  1;
   ?      1      1  :  1;
 
   0      0      ?  :  0;
   0      ?      0  :  0;
   ?      0      0  :  0;

   endtable
endprimitive  

primitive U_ADDR2_C   (CO, A, B, CI);
    output CO;
    input A, B, CI;

// FUNCTION :  FULL ADDER CARRY OUT TERM

    table
    //  A   B   CI  :   CO
        1   1   ?   :   1 ;
        1   ?   1   :   1 ;
        ?   1   1   :   1 ;
        0   0   ?   :   0 ;
        0   ?   0   :   0 ;
        ?   0   0   :   0 ;

    endtable
endprimitive   

primitive U_ADDR2_S (S, A, B, CI);
    output S;
    input A, B, CI;

// FUNCTION :  FULL ADDER SUM TERM

    table
    //  A   B   CI  :   S
        0   0   0   :   0 ;
        0   0   1   :   1 ;
        0   1   0   :   1 ;
        0   1   1   :   0 ;
        1   0   0   :   1 ;
        1   0   1   :   0 ;
        1   1   0   :   0 ;
        1   1   1   :   1 ;

    endtable
endprimitive 

primitive U_FD_EN_P (Q,CP,EN,D);

    output Q;
    reg    Q;
    input  CP,EN,D;

//FUNCTION : Posedge Trigger D Flip-Flop with Buffered Enabled EN ( Q output) 

table
// CP  ENN   D  : - : Q;

   r     0   1  : ? : 1;
   r     0   0  : ? : 0;
   r     1   ?  : 0 : -;
   r     1   ?  : 1 : -;
   p     ?   1  : 1 : 1;
   p     ?   0  : 0 : 0;
   p     1   ?  : ? : -;
   n     ?   ?  : ? : -;
   ?     ?   *  : ? : -;
   ?     *   ?  : ? : -;

endtable
endprimitive

primitive U_FD_EN_P_NO (Q,CP,EN,D,NOT_REG);

    output Q;
    reg    Q;
    input  CP,EN,D,NOT_REG;

//FUNCTION : Posedge Trigger D Flip-Flop with Buffered Enabled EN ( Q output) 

table
// CP  ENN D  NOT_REG : - : Q;

   r     0   1    ?   : ? : 1;
   r     0   0    ?   : ? : 0;
   r     1   ?    ?   : 0 : -;
   r     1   ?    ?   : 1 : -;
   p     ?   1    ?   : 1 : 1;
   p     ?   0    ?   : 0 : 0;
   p     1   ?    ?   : ? : -;
   n     ?   ?    ?   : ? : -;
   ?     ?   *    ?   : ? : -;
   ?     *   ?    ?   : ? : -;
   ?     ?   ?    *   : ? : x;
endtable
endprimitive

primitive U_FD_EN_N_RB (Q,CPN,EN,RB,D);

   output Q;
   reg Q;
   input CPN,EN,RB,D;

//FUNCTION : Negedge trigger D Flip-Flop With Buffered Enabled and Clear, Q only

table
// CPN  EN    RB    D  : -  :  Q;

    ?    ?     0    ?  : ?  :  0;

    f    0     1    1  : ?  :  1;
    f    0     1    0  : ?  :  0;
    f    1     1    ?  : ?  :  -;

    f    ?     1    0  : 0  :  0;
    f    ?     1    1  : 1  :  1;
    f    ?     ?    0  : 0  :  0;
    f    0     x    0  : ?  :  0;
    f    1     x    ?  : 0  :  0;

  (1x)   0     1    1  : 1  :  1;
  (1x)   0     1    0  : 0  :  0;
  (1x)   1     1    ?  : ?  :  -;

  (1x)   x     1    0  : 0  :  0;
  (1x)   x     1    1  : 1  :  1;
  (1x)   x     x    0  : 0  :  0;
  (1x)   0     x    0  : 0  :  0;
  (1x)   1     x    ?  : 0  :  0;

    p    ?     1    ?  : ?  :  -;
    1    ?     x    ?  : 0  :  0;
    ?    ?    (?1)  ?  : ?  :  -;
    ?    *     1    ?  : ?  :  -;
    ?    ?     1    *  : ?  :  -;
    ?    *     x    0  : 0  :  0;
    ?    1     x    *  : 0  :  0;
    ?    ?    (?x)  ?  : 0  :  0;

endtable
endprimitive

primitive U_FD_EN_N_RB_NO (Q,CPN,EN,RB,D,NOT_REG);

   output Q;
   reg Q;
   input CPN,EN,RB,D,NOT_REG;

//FUNCTION : Negedge trigger D Flip-Flop With Buffered Enabled and Clear, Q only

table
// CPN  EN    RB    D  NOT_REG  : -  :  Q;

    ?    ?     0    ?    ?      : ?  :  0;

    f    0     1    1    ?      : ?  :  1;
    f    0     1    0    ?      : ?  :  0;
    f    1     1    ?    ?      : ?  :  -;

    f    ?     1    0    ?      : 0  :  0;
    f    ?     1    1    ?      : 1  :  1;
    f    ?     ?    0    ?      : 0  :  0;
    f    0     x    0    ?      : ?  :  0;
    f    1     x    ?    ?      : 0  :  0;

  (1x)   0     1    1    ?      : 1  :  1;
  (1x)   0     1    0    ?      : 0  :  0;
  (1x)   1     1    ?    ?      : ?  :  -;

  (1x)   x     1    0    ?      : 0  :  0;
  (1x)   x     1    1    ?      : 1  :  1;
  (1x)   x     x    0    ?      : 0  :  0;
  (1x)   0     x    0    ?      : 0  :  0;
  (1x)   1     x    ?    ?      : 0  :  0;
   
    p    ?     1    ?    ?      : ?  :  -;
    1    ?     x    ?    ?      : 0  :  0;
    ?    *     1    ?    ?      : ?  :  -;
    ?    ?     1    *    ?      : ?  :  -;
    ?    *     x    0    ?      : 0  :  0;
    ?    1     x    *    ?      : 0  :  0;
    ?    ?    (?1)  ?    ?      : ?  :  -;
    ?    ?    (?x)  ?    ?      : 0  :  0;

    ?    ?     ?    ?    *      : ?  :  x;
endtable
endprimitive

primitive U_FD_EN_P_RB (Q,CP,EN,RB,D);

   output Q;
   reg Q;
   input CP,EN,RB,D;

//FUNCTION : Posedge trigger D Flip-Flop With Buffered Enabled and Clear, Q only

table
// CP   EN    RB    D  : -  :  Q;

    ?    ?     0    ?  : ?  :  0;

    r    0     1    1  : ?  :  1;
    r    0     1    0  : ?  :  0;
    r    1     1    ?  : ?  :  -;

    r    ?     1    0  : 0  :  0;
    r    ?     1    1  : 1  :  1;
    r    ?     ?    0  : 0  :  0;
    r    0     x    0  : ?  :  0;
    r    1     x    ?  : 0  :  0;

  (0x)   0     1    1  : 1  :  1;
  (0x)   0     1    0  : 0  :  0;
  (0x)   1     1    ?  : ?  :  -;

  (0x)   x     1    0  : 0  :  0;
  (0x)   x     1    1  : 1  :  1;
  (0x)   x     x    0  : 0  :  0;
  (0x)   0     x    0  : 0  :  0;
  (0x)   1     x    ?  : 0  :  0;

    n    ?     1    ?  : ?  :  -;
    0    ?     x    ?  : 0  :  0;
    ?    ?    (?1)  ?  : ?  :  -;
    ?    *     1    ?  : ?  :  -;
    ?    ?     1    *  : ?  :  -;
    ?    *     x    0  : 0  :  0;
    ?    1     x    *  : 0  :  0;
    ?    ?    (?x)  ?  : 0  :  0;

endtable
endprimitive

primitive U_FD_EN_P_RB_NO (Q,CP,EN,RB,D,NOT_REG);

   output Q;
   reg Q;
   input CP,EN,RB,D,NOT_REG;

//FUNCTION : Posedge trigger D Flip-Flop With Buffered Enabled and Clear, Q only

table
// CP   EN    RB    D  NOT_REG  : -  :  Q;

    ?    ?     0    ?    ?      : ?  :  0;

    r    0     1    1    ?      : ?  :  1;
    r    0     1    0    ?      : ?  :  0;
    r    1     1    ?    ?      : ?  :  -;

    r    ?     1    0    ?      : 0  :  0;
    r    ?     1    1    ?      : 1  :  1;
    r    ?     ?    0    ?      : 0  :  0;
    r    0     x    0    ?      : ?  :  0;
    r    1     x    ?    ?      : 0  :  0;

  (0x)   0     1    1    ?      : 1  :  1;
  (0x)   0     1    0    ?      : 0  :  0;
  (0x)   1     1    ?    ?      : ?  :  -;

  (0x)   x     1    0    ?      : 0  :  0;
  (0x)   x     1    1    ?      : 1  :  1;
  (0x)   x     x    0    ?      : 0  :  0;
  (0x)   0     x    0    ?      : 0  :  0;
  (0x)   1     x    ?    ?      : 0  :  0;

    n    ?     1    ?    ?      : ?  :  -;
    0    ?     x    ?    ?      : 0  :  0;
    ?    *     1    ?    ?      : ?  :  -;
    ?    ?     1    *    ?      : ?  :  -;
    ?    *     x    0    ?      : 0  :  0;
    ?    1     x    *    ?      : 0  :  0;
    ?    ?    (?1)  ?    ?      : ?  :  -;
    ?    ?    (?x)  ?    ?      : 0  :  0;

    ?    ?     ?    ?    *      : ?  :  x;

endtable
endprimitive

primitive U_FD_EN_N_SB (Q,CPN,EN,SB,D);

   output Q;
   reg Q;
   input CPN,EN,SB,D;

//FUNCTION : Negedge trigger D Flip-Flop With Buffered Enabled and Set, Q only

table
// CPN  EN    SB    D  : -  :  Q;

    ?    ?     0    ?  : ?  :  1;

    f    0     1    1  : ?  :  1;
    f    0     1    0  : ?  :  0;
    f    1     1    ?  : ?  :  -;

    f    ?     1    0  : 0  :  0;
    f    ?     1    1  : 1  :  1;
    f    ?     ?    1  : 1  :  1;
    f    0     ?    1  : ?  :  1;
    f    1     x    ?  : 1  :  1;

  (1x)   0     1    1  : 1  :  1;
  (1x)   0     1    0  : 0  :  0;
  (1x)   1     1    ?  : ?  :  -;

  (1x)   x     1    0  : 0  :  0;
  (1x)   x     1    1  : 1  :  1;
  (1x)   x     x    1  : 1  :  1;
  (1x)   0     x    1  : 1  :  1;
  (1x)   1     x    ?  : 1  :  1;

    p    ?     1    ?  : ?  :  -;
    1    ?     x    ?  : 1  :  1;
    ?    ?    (?1)  ?  : ?  :  -;
    ?    *     1    ?  : ?  :  -;
    ?    ?     1    *  : ?  :  -;
    ?    *     x    1  : 1  :  1;
    ?    1     x    *  : 1  :  1;
    ?    ?    (?x)  ?  : 1  :  1;

endtable
endprimitive

primitive U_FD_EN_N_SB_NO (Q,CPN,EN,SB,D,NOT_REG);

   output Q;
   reg Q;
   input CPN,EN,SB,D,NOT_REG;

//FUNCTION : Negedge trigger D Flip-Flop With Buffered Enabled and Set, Q only

table
// CPN  EN    SB    D  NOT_REG  : -  :  Q;

    ?    ?     ?    ?    *      : ?  :  x;
    
    ?    ?     0    ?    ?      : ?  :  1;

    f    0     1    1    ?      : ?  :  1;
    f    0     1    0    ?      : ?  :  0;
    f    1     1    ?    ?      : ?  :  -;

    f    ?     1    0    ?      : 0  :  0;
    f    ?     1    1    ?      : 1  :  1;
    f    ?     ?    1    ?      : 1  :  1;
    f    0     ?    1    ?      : ?  :  1;
    f    1     x    ?    ?      : 1  :  1;

  (1x)   0     1    1    ?      : 1  :  1;
  (1x)   0     1    0    ?      : 0  :  0;
  (1x)   1     1    ?    ?      : ?  :  -;

  (1x)   x     1    0    ?      : 0  :  0;    
  (1x)   x     1    1    ?      : 1  :  1;
  (1x)   x     x    1    ?      : 1  :  1;
  (1x)   0     x    1    ?      : 1  :  1;
  (1x)   1     x    ?    ?      : 1  :  1;

    p    ?     1    ?    ?      : ?  :  -;
    1    ?     x    ?    ?      : 1  :  1;
    ?    *     1    ?    ?      : ?  :  -;
    ?    ?     1    *    ?      : ?  :  -;
    ?    ?    (?1)  ?    ?      : ?  :  -;
    ?    *     x    1    ?      : 1  :  1;
    ?    1     x    *    ?      : 1  :  1;
    ?    ?    (?x)  ?    ?      : 1  :  1;

endtable
endprimitive

primitive U_FD_EN_P_SB (Q,CP,EN,SB,D);

   output Q;
   reg Q;
   input CP,EN,SB,D;

//FUNCTION : Posedge trigger D Flip-Flop With Buffered Enabled and Set, Q only

table
// CP   EN    SB    D   : -  :  Q;

    ?    ?     0    ?  : ?  :  1;

    r    0     1    1  : ?  :  1;
    r    0     1    0  : ?  :  0;
    r    1     1    ?  : ?  :  -;

    r    ?     1    0  : 0  :  0;
    r    ?     1    1  : 1  :  1;
    r    ?     ?    1  : 1  :  1;
    r    0     ?    1  : ?  :  1;
    r    1     x    ?  : 1  :  1;

  (0x)   0     1    1  : 1  :  1;
  (0x)   0     1    0  : 0  :  0;
  (0x)   1     1    ?  : ?  :  -;

  (0x)   x     1    0  : 0  :  0;
  (0x)   x     1    1  : 1  :  1;
  (0x)   x     x    1  : 1  :  1;
  (0x)   0     x    1  : 1  :  1;
  (0x)   1     x    ?  : 1  :  1;

    n    ?     1    ?  : ?  :  -;
    0    ?     x    ?  : 1  :  1;
    ?    ?    (?1)  ?  : ?  :  -;
    ?    *     1    ?  : ?  :  -;
    ?    ?     1    *  : ?  :  -;
    ?    *     x    1  : 1  :  1;
    ?    1     x    *  : 1  :  1;
    ?    ?    (?x)  ?  : 1  :  1;

endtable
endprimitive

primitive U_FD_EN_P_SB_NO (Q,CP,EN,SB,D,NOT_REG);

   output Q;
   reg Q;
   input CP,EN,SB,D,NOT_REG;

//FUNCTION : Posedge trigger D Flip-Flop With Buffered Enabled and Set, Q only

table
// CP   EN    SB    D  NOT_REG  : -  :  Q;

    ?    ?     ?    ?    *      : ?  :  x;

    ?    ?     0    ?    ?      : ?  :  1;

    r    0     1    1    ?      : ?  :  1;
    r    0     1    0    ?      : ?  :  0;
    r    1     1    ?    ?      : ?  :  -;

    r    ?     1    0    ?      : 0  :  0;
    r    ?     1    1    ?      : 1  :  1;
    r    ?     ?    1    ?      : 1  :  1;
    r    0     ?    1    ?      : ?  :  1;
    r    1     x    ?    ?      : 1  :  1;

  (0x)   0     1    1    ?      : 1  :  1;
  (0x)   0     1    0    ?      : 0  :  0;
  (0x)   1     1    ?    ?      : ?  :  -;

  (0x)   x     1    0    ?      : 0  :  0;
  (0x)   x     1    1    ?      : 1  :  1;
  (0x)   x     x    1    ?      : 1  :  1;
  (0x)   0     x    1    ?      : 1  :  1;
  (0x)   1     x    ?    ?      : 1  :  1;

    n    ?     1    ?    ?      : ?  :  -;
    0    ?     x    ?    ?      : 1  :  1;
    ?    *     1    ?    ?      : ?  :  -;
    ?    ?     1    *    ?      : ?  :  -;
    ?    ?    (?1)  ?    ?      : ?  :  -;
    ?    *     x    1    ?      : 1  :  1;
    ?    1     x    *    ?      : 1  :  1;
    ?    ?    (?x)  ?    ?      : 1  :  1;

endtable
endprimitive

primitive U_FD_N  (Q, D, CP);

    output Q;  
    input  D, CP;
    reg    Q;  

// FUNCTION :  NEGATIVE EDGE TRIGGERED D FLIP-FLOP ( Q OUTPUT UDP ).

    table
 
    //  D   CP        :   Qt  :   Qt+1

        1   (10)      :   ?   :   1;  // clocked data
        0   (10)      :   ?   :   0;
                                                           
        1   (1x)      :   1   :   1;  // reducing pessimism
        0   (1x)      :   0   :   0;                          
        1   (x0)      :   1   :   1;  
        0   (x0)      :   0   :   0; 
        
        ?   (0x)      :   ?   :   -;  // no change on rising edge 
        ?   (?1)      :   ?   :   -;  

        *    ?        :   ?   :   -;  // ignore edges on data

    endtable
endprimitive

primitive U_FD_N_NO (Q, D, CP , NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP;
    reg    Q;  

// FUNCTION :  NEGATIVE EDGE TRIGGERED D FLIP-FLOP ( Q OUTPUT UDP ).


    table
 
    //  D   CP           NOTIFIER_REG  :   Qt  :   Qt+1

        1   (10)            ?          :   ?   :   1;  // clocked data
        0   (10)            ?          :   ?   :   0;
                                                           
        1   (1x)            ?          :   1   :   1;  // reducing pessimism
        0   (1x)            ?          :   0   :   0;                          
        1   (x0)            ?          :   1   :   1;  
        0   (x0)            ?          :   0   :   0; 
        
        ?   (0x)            ?          :   ?   :   -;  // no change on rising edge 
        ?   (?1)            ?          :   ?   :   -;  

        *    ?              ?          :   ?   :   -;  // ignore edges on data
        
        ?    ?              *          :   ?   :   x;
    endtable
endprimitive

primitive U_FD_N_RB_NO (Q, D, CP, RB, NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q; 
    
// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).


    table
 
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (10)    1         ?          :   ?   :   1;  // clocked data
        0   (10)    1         ?          :   ?   :   0;

        0   (10)    x         ?          :   ?   :   0;  // pessimism
        0    ?      x         ?          :   0   :   0;  // pessimism

        1    1      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    0    (?x)        ?          :   0   :   0;  // pessimism

        x    1      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    0    (?x)        ?          :   0   :   0;  // pessimism

        1   (1x)    1         ?          :   1   :   1;  // reducing pessimism
        0   (1x)    1         ?          :   0   :   0;                          
        0   (1x)    x         ?          :   0   :   0;                          
        1   (x0)    1         ?          :   1   :   1;  
        0   (x0)    1         ?          :   0   :   0;  


        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear

        ?   (?1)    1         ?          :   ?   :   -;  // ignore falling clock
        ?   (0x)    1         ?          :   ?   :   -;  // ignore falling clock
        *    ?      1         ?          :   ?   :   -;  // ignore the edges on data

        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear 

        ?    ?      ?         *          :   ?   :   x;
 
    endtable
endprimitive

primitive U_FD_N_RB_SB  (Q, D, CP, RB, SB);

    output Q;  
    input  D, CP, RB, SB;
    reg    Q; 

// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND CLEAR. ( Q OUTPUT UDP ).

    table
 
    //  D    CP     RB  SB  :   Qt  :   Qt+1

        1   (10)    1   1   :   ?   :   1;  // clocked data
        1   (10)    1   x   :   ?   :   1;  // pessimism

        1    ?      1   x   :   1   :   1;  // pessimism

        0    1      1   x   :   1   :   1;  // pessimism
        0    x      1 (?x)  :   1   :   1;  // pessimism
        0    0      1 (?x)  :   1   :   1;  // pessimism

        x    1      1   x   :   1   :   1;  // pessimism
        x    x      1 (?x)  :   1   :   1;  // pessimism
        x    0      1 (?x)  :   1   :   1;  // pessimism


        0   (10)    1   1   :   ?   :   0;  // clocked data
        0   (10)    x   1   :   ?   :   0;  // pessimism

        0    ?      x   1   :   0   :   0;  // pessimism

        1    1      x   1   :   0   :   0;  // pessimism
        1    x    (?x)  1   :   0   :   0;  // pessimism
        1    0    (?x)  1   :   0   :   0;  // pessimism

        x    1      x   1   :   0   :   0;  // pessimism
        x    x    (?x)  1   :   0   :   0;  // pessimism
        x    0    (?x)  1   :   0   :   0;  // pessimism
                                                           
        1   (1x)    1   1   :   1   :   1;  // reducing pessimism
        0   (1x)    1   1   :   0   :   0;                          

        0   (1x)    x   1   :   0   :   0;                          
        1   (1x)    1   x   :   1   :   1;  // reducing pessimism

        1   (x0)    1   1   :   1   :   1;  
        0   (x0)    1   1   :   0   :   0;  

        ?    ?      0   ?   :   ?   :   0;  // asynchronous clear
        ?    ?      1   0   :   ?   :   1;  // asynchronous set

        ?   (?1)    1   1   :   ?   :   -;  // ignore rising clock
        ?   (0x)    1   1   :   ?   :   -;  // ignore rising clock
        *    ?      1   1   :   ?   :   -;  // ignore data edges 

        ?    ?     (?1) 1   :   ?   :   -;  // ignore the edges on 
        ?    ?      1  (?1) :   ?   :   -;  // set and clear                  

    endtable
endprimitive

primitive U_FD_N_R_S_NO_QN (QN, D, CP, R, S, NOTIFIER_REG); 

    output QN;  
    input  NOTIFIER_REG,
           D, CP, R, S;
    reg    QN; 

// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE HIGH
//            ASYNCHRONOUS SET AND RESET.  ( QN OUTPUT UDP )
        

     table
 
    //  D   CP      R   S      NOTIFIER_REG  :   Qtn :   Qtn+1

        1   (10)    0   0         ?          :   ?   :   0;  // clocked data
        1   (10)    0   x         ?          :   ?   :   0;  // pessimism

        1    ?      0   x         ?          :   0   :   0;  // pessimism

        0    1      0   x         ?          :   0   :   0;  // pessimism
        0    x      0 (?x)        ?          :   0   :   0;  // pessimism
        0    0      0 (?x)        ?          :   0   :   0;  // pessimism

        x    1      0   x         ?          :   0   :   0;  // pessimism
        x    x      0 (?x)        ?          :   0   :   0;  // pessimism
        x    0      0 (?x)        ?          :   0   :   0;  // pessimism


        0   (10)    0   0         ?          :   ?   :   1;  // clocked data
        0   (10)    x   0         ?          :   ?   :   1;  // pessimism

        0    ?      x   0         ?          :   1   :   1;  // pessimism

        1    1      x   0         ?          :   1   :   1;  // pessimism
        1    x    (?x)  0         ?          :   1   :   1;  // pessimism
        1    0    (?x)  0         ?          :   1   :   1;  // pessimism

        x    1      x   0         ?          :   1   :   1;  // pessimism
        x    x    (?x)  0         ?          :   1   :   1;  // pessimism
        x    0    (?x)  0         ?          :   1   :   1;  // pessimism
                                                           
        ?   ?       1   0         ?          :   ?   :   1;  // asynchronous clear
        ?   ?       ?   1         ?          :   ?   :   0;  // asynchronous set

        ?   (?1)    0   0         ?          :   ?   :   -;  // ignore rising clock

        0   (1x)    0   0         ?          :   1   :   1;  
        1   (1x)    0   0         ?          :   0   :   0;  
        1   (1x)    0   x         ?          :   0   :   0;  
        0   (1x)    x   0         ?          :   1   :   1;  

        *    ?      0   0         ?          :   ?   :   -;  // ignore data edges 

        ?   ?     (?0)  0         ?          :   ?   :   -;  // ignore the edges on 
        ?   ?       0  (?0)       ?          :   ?   :   -;  // set and clear                  
        
        ?   ?       ?   ?         *          :   ?   :   x;

    endtable
endprimitive

primitive U_FD_N_RB_SB_NO  (Q, D, CP, RB, SB, NOTIFY_REG);

    output Q;  
    input  D, CP, RB, SB, NOTIFY_REG;
    reg    Q; 

// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND CLEAR. ( Q OUTPUT UDP ).

    table
 
    //  D    CP     RB  SB  NOTIFY_REG  :   Qt  :   Qt+1

        1   (10)    1   1      ?        :   ?   :   1;  // clocked data
        1   (10)    1   x      ?        :   ?   :   1;  // pessimism

        1    ?      1   x      ?        :   1   :   1;  // pessimism

        0    1      1   x      ?        :   1   :   1;  // pessimism
        0    x      1 (?x)     ?        :   1   :   1;  // pessimism
        0    0      1 (?x)     ?        :   1   :   1;  // pessimism

        x    1      1   x      ?        :   1   :   1;  // pessimism
        x    x      1 (?x)     ?        :   1   :   1;  // pessimism
        x    0      1 (?x)     ?        :   1   :   1;  // pessimism


        0   (10)    1   1      ?        :   ?   :   0;  // clocked data
        0   (10)    x   1      ?        :   ?   :   0;  // pessimism

        0    ?      x   1      ?        :   0   :   0;  // pessimism

        1    1      x   1      ?        :   0   :   0;  // pessimism
        1    x    (?x)  1      ?        :   0   :   0;  // pessimism
        1    0    (?x)  1      ?        :   0   :   0;  // pessimism

        x    1      x   1      ?        :   0   :   0;  // pessimism
        x    x    (?x)  1      ?        :   0   :   0;  // pessimism
        x    0    (?x)  1      ?        :   0   :   0;  // pessimism
                                                           
        1   (1x)    1   1      ?        :   1   :   1;  // reducing pessimism
        0   (1x)    1   1      ?        :   0   :   0;                          

        1   (1x)    1   x      ?        :   1   :   1;  // reducing pessimism
        0   (1x)    x   1      ?        :   0   :   0;                          

        1   (x0)    1   1      ?        :   1   :   1;  
        0   (x0)    1   1      ?        :   0   :   0;  

        ?    ?      0   ?      ?        :   ?   :   0;  // asynchronous clear
        ?    ?      1   0      ?        :   ?   :   1;  // asynchronous set

        ?   (?1)    1   1      ?        :   ?   :   -;  // ignore rising clock
        ?   (0x)    1   1      ?        :   ?   :   -;  // ignore rising clock
        *    ?      1   1      ?        :   ?   :   -;  // ignore data edges 

        ?    ?     (?1) 1      ?        :   ?   :   -;  // ignore the edges on 
        ?    ?      1  (?1)    ?        :   ?   :   -;  // set and clear                  
        ?    ?      ?   ?      *        :   ?   :   x;  

    endtable
endprimitive

primitive U_FD_N_RB_SB_QN (QN, D, CP, RB, SB);

    output QN;  
    input  D, CP, RB, SB;
    reg    QN; 

// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND CLEAR .  ( QN OUTPUT UDP ).

    table
 
    //  D    CP     RB  SB  :   Qtn :   Qtn+1

        1   (10)    1   1   :   ?   :   0;  // clocked data
        1   (10)    1   x   :   ?   :   0;  // pessimism

        1    ?      1   x   :   0   :   0;  // pessimism

        0    1      1   x   :   0   :   0;  // pessimism
        0    x      1 (?x)  :   0   :   0;  // pessimism
        0    0      1 (?x)  :   0   :   0;  // pessimism

        x    1      1   x   :   0   :   0;  // pessimism
        x    x      1 (?x)  :   0   :   0;  // pessimism
        x    0      1 (?x)  :   0   :   0;  // pessimism


        0   (10)    1   1   :   ?   :   1;  // clocked data
        0   (10)    x   1   :   ?   :   1;  // pessimism

        0    ?      x   1   :   1   :   1;  // pessimism
                        
        1    1      x   1   :   1   :   1;  // pessimism
        1    x    (?x)  1   :   1   :   1;  // pessimism
        1    0    (?x)  1   :   1   :   1;  // pessimism
                        
        x    1      x   1   :   1   :   1;  // pessimism
        x    x    (?x)  1   :   1   :   1;  // pessimism
        x    0    (?x)  1   :   1   :   1;  // pessimism

        ?    ?      0   1   :   ?   :   1;  // asynchronous clear
        ?    ?      ?   0   :   ?   :   0;  // asynchronous set

        ?   (?1)    1   1   :   ?   :   -;  // ignore rising clock

        0   (1x)    1   1   :   1   :   1;  
        1   (1x)    1   1   :   0   :   0; 
        1   (1x)    1   x   :   0   :   0;
        0   (1x)    x   1   :   1   :   1;

        *    ?      1   1   :   ?   :   -;  // ignore data edges 

        ?    ?     (?1) 1   :   ?   :   -;  // ignore the edges on 
        ?    ?      1  (?1) :   ?   :   -;  // set and clear                  

    endtable
endprimitive

primitive U_FD_N_SB_NO (Q, D, CP, SB, NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP, SB;
    reg    Q; 
    
// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET ( Q OUTPUT UDP )


    table
 
    //  D   CP      SB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (10)    1         ?          :   ?   :   1;  // clocked data
        0   (10)    1         ?          :   ?   :   0;
        1   (10)    x         ?          :   ?   :   1;  // reducing pessimism
        1    ?      x         ?          :   1   :   1;  // pessimism

        0    1      x         ?          :   1   :   1;  // pessimism
        0    x    (?x)        ?          :   1   :   1;  // pessimism
        0    0    (?x)        ?          :   1   :   1;  // pessimism

        x    1      x         ?          :   1   :   1;  // pessimism
        x    x    (?x)        ?          :   1   :   1;  // pessimism
        x    0    (?x)        ?          :   1   :   1;  // pessimism

        1   (1x)    1         ?          :   1   :   1;  // reducing pessimism
        0   (1x)    1         ?          :   0   :   0;                          
        1   (1x)    x         ?          :   1   :   1;  // reducing pessimism

        1   (x0)    1         ?          :   1   :   1;  
        0   (x0)    1         ?          :   0   :   0;  

        ?    ?      0         ?          :   ?   :   1;  // asynchronous clear

        ?   (?1)    1         ?          :   ?   :   -;  // ignore falling clock
        ?   (0x)    1         ?          :   ?   :   -;  // ignore falling clock
        *    ?      1         ?          :   ?   :   -;  // ignore the data edges

        ?   ?     (?1)        ?          :   ?   :   -;  // ignore the edges on set
        
        ?   ?       ?         *          :   ?   :   x;

    endtable
endprimitive

primitive U_FD_P_RB  (Q, D, CP, RB);

    output Q;  
    input  D, CP, RB;
    reg    Q; 
    
// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).

    table
 
    //  D   CP      RB  :   Qt  :   Qt+1

        1   (01)    1   :   ?   :   1;  // clocked data
        0   (01)    1   :   ?   :   0;

        0   (01)    x   :   ?   :   0;  // pessimism

        0    ?      x   :   0   :   0;  // pessimism
                       
        1    0      x   :   0   :   0;  // pessimism
        1    x    (?x)  :   0   :   0;  // pessimism
        1    1    (?x)  :   0   :   0;  // pessimism
                       
        x    0      x   :   0   :   0;  // pessimism
        x    x    (?x)  :   0   :   0;  // pessimism
        x    1    (?x)  :   0   :   0;  // pessimism

        1   (x1)    1   :   1   :   1;  // reducing pessimism
        0   (x1)    1   :   0   :   0;                          
        1   (0x)    1   :   1   :   1;  
        0   (0x)    1   :   0   :   0;  
        0   (0x)    x   :   0   :   0;  


        ?   ?       0   :   ?   :   0;  // asynchronous clear

        ?   (?0)    1   :   ?   :   -;  // ignore falling clock
        ?   (1x)    1   :   ?   :   -;  // ignore falling clock
        *    ?      1   :   ?   :   -;  // ignore the edges on data

        ?    ?    (?1)  :   ?   :   -;  // ignore the edges on clear 


    endtable
endprimitive

primitive U_FD_P_RB_NO (Q, D, CP, RB, NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q; 
    
// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).


    table
 
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)    1         ?          :   ?   :   1;  // clocked data
        0   (01)    1         ?          :   ?   :   0;

        0   (01)    x         ?          :   ?   :   0;  // pessimism

        0    ?      x         ?          :   0   :   0;  // pessimism

        1    0      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    1    (?x)        ?          :   0   :   0;  // pessimism

        x    0      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    1    (?x)        ?          :   0   :   0;  // pessimism

        1   (x1)    1         ?          :   1   :   1;  // reducing pessimism
        0   (x1)    1         ?          :   0   :   0;                          
        1   (0x)    1         ?          :   1   :   1;  
        0   (0x)    1         ?          :   0   :   0;  
        0   (0x)    x         ?          :   0   :   0;  


        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear

        ?   (?0)    1         ?          :   ?   :   -;  // ignore falling clock
        ?   (1x)    1         ?          :   ?   :   -;  // ignore falling clock
        *    ?      1         ?          :   ?   :   -;  // ignore the edges on data

        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear 

        ?    ?      ?         *          :   ?   :   x;
 
    endtable
endprimitive

primitive U_FD_P_RB_SB  (Q, D, CP, RB, SB);

    output Q;  
    input  D, CP, RB, SB;
    reg    Q; 

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND CLEAR. ( Q OUTPUT UDP ).

    table
 
    //  D   CP      RB  SB  :   Qt  :   Qt+1

        1   (01)    1   1   :   ?   :   1;  // clocked data
        1   (01)    1   x   :   ?   :   1;  // pessimism

        1    ?      1   x   :   1   :   1;  // pessimism

        0    0      1   x   :   1   :   1;  // pessimism
        0    x      1 (?x)  :   1   :   1;  // pessimism
        0    1      1 (?x)  :   1   :   1;  // pessimism

        x    0      1   x   :   1   :   1;  // pessimism
        x    x      1 (?x)  :   1   :   1;  // pessimism
        x    1      1 (?x)  :   1   :   1;  // pessimism

        0   (01)    1   1   :   ?   :   0;  // clocked data
        0   (01)    x   1   :   ?   :   0;  // pessimism
 
        0    ?      x   1   :   0   :   0;  // pessimism

        1    0      x   1   :   0   :   0;  // pessimism
        1    x    (?x)  1   :   0   :   0;  // pessimism
        1    1    (?x)  1   :   0   :   0;  // pessimism

        x    0      x   1   :   0   :   0;  // pessimism
        x    x    (?x)  1   :   0   :   0;  // pessimism
        x    1    (?x)  1   :   0   :   0;  // pessimism
                                                           
        ?   ?       0   ?   :   ?   :   0;  // asynchronous clear
        ?   ?       1   0   :   ?   :   1;  // asynchronous set

        ?   (?0)    1   1   :   ?   :   -;  // ignore falling clock
        1   (?x)    1   1   :   1   :   1;  
        0   (?x)    1   1   :   0   :   0;  
        1   (?x)    1   x   :   1   :   1;  
        0   (?x)    x   1   :   0   :   0;  
        *    ?      1   1   :   ?   :   -;  // ignore data edges 

        ?   ?     (?1)  1   :   ?   :   -;  // ignore the edges on 
        ?   ?       1  (?1) :   ?   :   -;  //       set and clear                  

    endtable
endprimitive

primitive U_FD_P_RB_SB_NO (Q, D, CP, RB, SB, NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP, RB, SB;
    reg    Q; 

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND CLEAR. ( Q OUTPUT UDP ).


    table
 
    //  D   CP      RB  SB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)    1   1         ?          :   ?   :   1;  // clocked data
        1   (01)    1   x         ?          :   ?   :   1;  // pessimism
 
        1    ?      1   x         ?          :   1   :   1;  // pessimism

        0    0      1   x         ?          :   1   :   1;  // pessimism
        0    x      1 (?x)        ?          :   1   :   1;  // pessimism
        0    1      1 (?x)        ?          :   1   :   1;  // pessimism

        x    0      1   x         ?          :   1   :   1;  // pessimism
        x    x      1 (?x)        ?          :   1   :   1;  // pessimism
        x    1      1 (?x)        ?          :   1   :   1;  // pessimism

        0   (01)    1   1         ?          :   ?   :   0;  // clocked data
        0   (01)    x   1         ?          :   ?   :   0;  // pessimism

        0    ?      x   1         ?          :   0   :   0;  // pessimism

        1    0      x   1         ?          :   0   :   0;  // pessimism
        1    x    (?x)  1         ?          :   0   :   0;  // pessimism
        1    1    (?x)  1         ?          :   0   :   0;  // pessimism

        x    0      x   1         ?          :   0   :   0;  // pessimism
        x    x    (?x)  1         ?          :   0   :   0;  // pessimism
        x    1    (?x)  1         ?          :   0   :   0;  // pessimism

        ?   ?       0   ?         ?          :   ?   :   0;  // asynchronous clear
        ?   ?       1   0         ?          :   ?   :   1;  // asynchronous set

        ?   (?0)    1   1         ?          :   ?   :   -;  // ignore falling clock

        1   (?x)    1   1         ?          :   1   :   1;  // ignore falling clock
        0   (?x)    1   1         ?          :   0   :   0;  // ignore falling clock
        1   (?x)    1   x         ?          :   1   :   1;  // ignore falling clock
        0   (?x)    x   1         ?          :   0   :   0;  // ignore falling clock

        *    ?      1   1         ?          :   ?   :   -;  // ignore data edges 

        ?   ?     (?1)  1         ?          :   ?   :   -;  // ignore the edges on 
        ?   ?       1  (?1)       ?          :   ?   :   -;  //       set and clear                  
       
        ?   ?       ?   ?         *          :   ?   :   x;


    endtable
endprimitive

primitive U_FD_P_SB (Q, D, CP, SB);

    output Q;  
    input  D, CP, SB;
    reg    Q; 
    
// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET ( Q OUTPUT UDP )

    table
 
    //  D   CP      SB  :   Qt  :   Qt+1

        1   (01)    1   :   ?   :   1;  // clocked data
        0   (01)    1   :   ?   :   0;
        1   (01)    x   :   ?   :   1;  // reducing pessimism

        1    ?      x   :   1   :   1;  // pessimism

        0    0      x   :   1   :   1;  // pessimism
        0    x    (?x)  :   1   :   1;  // pessimism
        0    1    (?x)  :   1   :   1;  // pessimism

        x    0      x   :   1   :   1;  // pessimism
        x    x    (?x)  :   1   :   1;  // pessimism
        x    1    (?x)  :   1   :   1;  // pessimism
                                                           
        1   (x1)    1   :   1   :   1;  // reducing pessimism
        0   (x1)    1   :   0   :   0;                          
        1   (0x)    1   :   1   :   1;  
        0   (0x)    1   :   0   :   0;  
        1   (0x)    x   :   1   :   1;  


        ?    ?      0   :   ?   :   1;  // asynchronous clear

        ?   (?0)    1   :   ?   :   -;  // ignore falling clock
        ?   (1x)    1   :   ?   :   -;  // ignore falling clock
        *    ?      1   :   ?   :   -;  // ignore the data edges

        ?   ?     (?1)  :   ?   :   -;  // ignore the edges on set

    endtable
endprimitive

primitive U_FD_P_SB_NO (Q, D, CP, SB, NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP, SB;
    reg    Q; 
    
// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS SET ( Q OUTPUT UDP )


    table
 
    //  D   CP      SB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)    1         ?          :   ?   :   1;  // clocked data
        0   (01)    1         ?          :   ?   :   0;
        1   (01)    x         ?          :   ?   :   1;  // reducing pessimism
        1    ?      x         ?          :   1   :   1;  // pessimism

        0    0      x         ?          :   1   :   1;  // pessimism
        0    x    (?x)        ?          :   1   :   1;  // pessimism
        0    1    (?x)        ?          :   1   :   1;  // pessimism

        x    0      x         ?          :   1   :   1;  // pessimism
        x    x    (?x)        ?          :   1   :   1;  // pessimism
        x    1    (?x)        ?          :   1   :   1;  // pessimism

        1   (x1)    1         ?          :   1   :   1;  // reducing pessimism
        0   (x1)    1         ?          :   0   :   0;                          
        1   (0x)    1         ?          :   1   :   1;  
        0   (0x)    1         ?          :   0   :   0;  
        1   (0x)    x         ?          :   1   :   1;  

        ?    ?      0         ?          :   ?   :   1;  // asynchronous clear

        ?   (?0)    1         ?          :   ?   :   -;  // ignore falling clock
        ?   (1x)    1         ?          :   ?   :   -;  // ignore falling clock
        *    ?      1         ?          :   ?   :   -;  // ignore the data edges

        ?   ?     (?1)        ?          :   ?   :   -;  // ignore the edges on set
        
        ?   ?       ?         *          :   ?   :   x;

    endtable
endprimitive

primitive U_FD_SC_EN_P (Q,CP,ENN,SC,D,SD);

   output Q;
   reg    Q;
   input  CP,ENN,SC,D,SD;

//FUNCTION : Muxed Scan D Flip-Flop With Enable, Q Only

table
// CP   ENN  SC   D   SD  : - : Q;

   r    ?    1    ?    1  : ? : 1;
   r    ?    1    ?    0  : ? : 0;
   r    0    0    1    ?  : ? : 1;
   r    0    0    0    ?  : ? : 0;
   r    x    0    0    ?  : 0 : -;
   r    x    0    1    ?  : 1 : -;
   r    0    x    0    0  : ? : 0;
   r    0    x    1    1  : ? : 1;
   r    1    x    ?    0  : 0 : -;
   r    1    x    ?    1  : 1 : -;
   r    x    x    0    0  : 0 : -;
   r    x    x    1    1  : 1 : -;

  (?x)  ?    0    0    ?  : 0 : 0;
  (?x)  ?    0    1    ?  : 1 : 1;
  (?x)  x    x    0    0  : 0 : 0;
  (?x)  x    x    1    1  : 1 : 1;
  (?x)  0    x    0    0  : 0 : 0;
  (?x)  0    x    1    1  : 1 : 1;
  (?x)  1    x    ?    1  : 1 : 1;
  (?x)  1    x    ?    0  : 0 : 0;
  (?x)  ?    1    ?    0  : 0 : 0;
  (?x)  ?    1    ?    1  : 1 : 1;

  (?0)  ?    ?    ?    ?  : ? : -;

   *    1    0    ?    ?  : ? : -;
   ?    *    ?    ?    ?  : ? : -;
   ?    ?    *    ?    ?  : ? : -;
   ?    ?    ?    *    ?  : ? : -;
   ?    ?    ?    ?    *  : ? : -;

endtable
endprimitive

primitive U_FD_SC_EN_P_NO (Q,CP,ENN,SC,D,SD,NOT_REG);

   output Q;
   reg    Q;
   input  CP,ENN,SC,D,SD,NOT_REG;

//FUNCTION : Muxed Scan D Flip-Flop With Enable, Q Only

table
// CP   ENN  SC   D   SD NOT_REG : - : Q;

   r    ?    1    ?    1    ?   : ? : 1;
   r    ?    1    ?    0    ?   : ? : 0;
   r    0    0    1    ?    ?   : ? : 1;
   r    0    0    0    ?    ?   : ? : 0;
   r    x    0    0    ?    ?   : 0 : -;
   r    x    0    1    ?    ?   : 1 : -;
   r    0    x    0    0    ?   : ? : 0;
   r    0    x    1    1    ?   : ? : 1;
   r    1    x    ?    0    ?   : 0 : -;
   r    1    x    ?    1    ?   : 1 : -;
   r    x    x    0    0    ?   : 0 : -;
   r    x    x    1    1    ?   : 1 : -;

  (?x)  ?    0    0    ?    ?   : 0 : 0;
  (?x)  ?    0    1    ?    ?   : 1 : 1;
  (?x)  x    x    0    0    ?   : 0 : 0;
  (?x)  x    x    1    1    ?   : 1 : 1;
  (?x)  0    x    0    0    ?   : 0 : 0;
  (?x)  0    x    1    1    ?   : 1 : 1;
  (?x)  1    x    ?    1    ?   : 1 : 1;
  (?x)  1    x    ?    0    ?   : 0 : 0;
  (?x)  ?    1    ?    0    ?   : 0 : 0;
  (?x)  ?    1    ?    1    ?   : 1 : 1;

  (?0)  ?    ?    ?    ?    ?   : ? : -;

   *    1    0    ?    ?    ?   : ? : -;
   ?    *    ?    ?    ?    ?   : ? : -;
   ?    ?    *    ?    ?    ?   : ? : -;
   ?    ?    ?    *    ?    ?   : ? : -;
   ?    ?    ?    ?    *    ?   : ? : -;

   ?    ?    ?    ?    ?    *   : ? : x;

endtable
endprimitive

primitive U_FD_SC_EN_P_RB (Q,CP,ENN,SC,CDN,D,SD);

   output Q;
   reg    Q;
   input  CP,ENN,SC,CDN,D,SD;

//FUNCTION : Muxed Scan D Flip-Flop with Clear and Enable,Q only

table
// CP   ENN  SC   CDN  D   SD  : - : Q;

   ?    ?    ?    0    ?    ?  : ? : 0;

   r    ?    1    1    ?    0  : ? : 0;
   r    ?    1    1    ?    1  : ? : 1;
   r    0    0    1    0    ?  : ? : 0;
   r    0    0    1    1    ?  : ? : 1;
   r    ?    0    ?    0    ?  : 0 : -;
   r    ?    0    1    1    ?  : 1 : -;

   r    0    x    1    0    0  : ? : 0;
   r    0    x    1    1    1  : ? : 1;
   r    1    x    1    ?    0  : 0 : -;
   r    1    x    1    ?    1  : 1 : -;
   r    ?    1    x    ?    0  : ? : 0;
   r    0    0    x    0    ?  : ? : 0;
   r    1    0    x    ?    ?  : 0 : 0;
   r    0    x    x    0    0  : ? : 0;
   r    1    x    x    ?    0  : 0 : 0;
   r    ?    ?    ?    0    0  : 0 : 0;
   r    ?    ?    1    1    1  : 1 : 1;

  (?x)  ?    1    1    ?    0  : 0 : 0;
  (?x)  ?    1    1    ?    1  : 1 : 1;
  (?x)  ?    0    ?    0    ?  : 0 : -;
  (?x)  ?    0    1    1    ?  : 1 : -;

  (?x)  0    x    1    0    0  : 0 : 0;
  (?x)  0    x    1    1    1  : 1 : 1;
  (?x)  1    x    1    ?    0  : 0 : -;
  (?x)  1    x    1    ?    1  : 1 : -;
  (?x)  x    x    ?    0    0  : 0 : 0;
  (?x)  ?    ?    1    1    1  : 1 : 1;
  (?x)  1    0    x    ?    ?  : 0 : 0;
  (?x)  ?    1    x    ?    0  : 0 : 0;
  (?x)  0    x    x    0    0  : 0 : 0;
  (?x)  1    x    x    ?    0  : 0 : 0;

   0    ?    ?    x    ?    ?  : 0 : 0;
   ?    ?    ?   (?x)  ?    ?  : 0 : 0;

   n    ?    ?    1    ?    ?  : ? : -;

   *    1    0    1    ?    ?  : ? : -;
   ?    *    ?    1    ?    ?  : ? : -;
   ?    *    0    x    0    ?  : 0 : 0;
   ?    *    1    x    ?    0  : 0 : 0;
   ?    *    x    x    0    0  : 0 : 0;
   ?    ?    *    1    ?    ?  : ? : -;
   ?    ?    *    x    0    0  : 0 : 0;
   ?    1    *    x    ?    0  : 0 : 0;
   ?    ?    ?   (?1)  ?    ?  : ? : -;
   ?    ?    ?    1    *    ?  : ? : -;
   ?    1    ?    x    *    ?  : 0 : 0;
   ?    ?    ?    1    ?    *  : ? : -;
   ?    ?    0    x    ?    *  : 0 : 0;

endtable
endprimitive

primitive U_FD_SC_EN_P_RB_NO (Q,CP,ENN,SC,CDN,D,SD,NOT_REG);

   output Q;
   reg    Q;
   input  CP,ENN,SC,CDN,D,SD,NOT_REG;

//FUNCTION : Muxed Scan D Flip-Flop with Clear and Enable,Q only

table
// CP   ENN  SC   CDN  D   SD NOT_REG : - : Q;

   ?    ?    ?    0    ?    ?    ?   : ? : 0;

   r    ?    1    1    ?    0    ?   : ? : 0;
   r    ?    1    1    ?    1    ?   : ? : 1;
   r    0    0    1    0    ?    ?   : ? : 0;
   r    0    0    1    1    ?    ?   : ? : 1;
   r    ?    0    ?    0    ?    ?   : 0 : -;
   r    ?    0    1    1    ?    ?   : 1 : -;

   r    0    x    1    0    0    ?   : ? : 0;
   r    0    x    1    1    1    ?   : ? : 1;
   r    1    x    1    ?    0    ?   : 0 : -;
   r    1    x    1    ?    1    ?   : 1 : -;
   r    ?    1    x    ?    0    ?   : ? : 0;
   r    0    0    x    0    ?    ?   : ? : 0;
   r    1    0    x    ?    ?    ?   : 0 : 0;
   r    0    x    x    0    0    ?   : ? : 0;
   r    1    x    x    ?    0    ?   : 0 : 0;
   r    ?    ?    ?    0    0    ?   : 0 : 0;
   r    ?    ?    1    1    1    ?   : 1 : 1;

  (?x)  ?    1    1    ?    0    ?   : 0 : 0;
  (?x)  ?    1    1    ?    1    ?   : 1 : 1;
  (?x)  ?    0    ?    0    ?    ?   : 0 : -;
  (?x)  ?    0    1    1    ?    ?   : 1 : -;

  (?x)  0    x    1    0    0    ?   : 0 : 0;
  (?x)  0    x    1    1    1    ?   : 1 : 1;
  (?x)  1    x    1    ?    0    ?   : 0 : -;
  (?x)  1    x    1    ?    1    ?   : 1 : -;
  (?x)  x    x    ?    0    0    ?   : 0 : 0;
  (?x)  ?    ?    1    1    1    ?   : 1 : 1;
  (?x)  1    0    x    ?    ?    ?   : 0 : 0;
  (?x)  ?    1    x    ?    0    ?   : 0 : 0;
  (?x)  0    x    x    0    0    ?   : 0 : 0;
  (?x)  1    x    x    ?    0    ?   : 0 : 0;

   0    ?    ?    x    ?    ?    ?   : 0 : 0;
   ?    ?    ?   (?x)  ?    ?    ?   : 0 : 0;

   n    ?    ?    1    ?    ?    ?   : ? : -;

   *    1    0    1    ?    ?    ?   : ? : -;
   ?    *    ?    1    ?    ?    ?   : ? : -;
   ?    *    0    x    0    ?    ?   : 0 : 0;
   ?    *    1    x    ?    0    ?   : 0 : 0;
   ?    *    x    x    0    0    ?   : 0 : 0;
   ?    ?    *    1    ?    ?    ?   : ? : -;
   ?    ?    *    x    0    0    ?   : 0 : 0;
   ?    1    *    x    ?    0    ?   : 0 : 0;
   ?    ?    ?   (?1)  ?    ?    ?   : ? : -;
   ?    ?    ?    1    *    ?    ?   : ? : -;
   ?    1    ?    x    *    ?    ?   : 0 : 0;
   ?    ?    ?    1    ?    *    ?   : ? : -;
   ?    ?    0    x    ?    *    ?   : 0 : 0;

   ?    ?    ?    ?    ?    ?    *   : ? : x;

endtable
endprimitive

primitive U_FD_SC_EN_P_SB (Q,CP,ENN,SC,SDN,D,SD);

   output Q;
   reg    Q;
   input  CP,ENN,SC,SDN,D,SD;

//FUNCTION : Muxed Scan D Flip-Flop with Set and Enable,Q only

table
// CP   ENN  SC   SDN  D   SD  : - : Q;

   ?    ?    ?    0    ?    ?  : ? : 1;

   r    ?    1    1    ?    0  : ? : 0;
   r    ?    1    1    ?    1  : ? : 1;
   r    0    0    1    0    ?  : ? : 0;
   r    0    0    1    1    ?  : ? : 1;
   r    ?    0    ?    1    ?  : 1 : -;
   r    ?    0    1    0    ?  : 0 : -;

   r    0    x    1    0    0  : ? : 0;
   r    0    x    1    1    1  : ? : 1;
   r    1    x    1    ?    0  : 0 : -;
   r    1    x    1    ?    1  : 1 : -;
   r    ?    1    x    ?    1  : ? : 1;
   r    0    0    x    1    ?  : ? : 1;
   r    1    0    x    ?    ?  : 1 : 1;
   r    0    x    x    1    1  : ? : 1;
   r    1    x    x    ?    1  : 1 : 1;
   r    ?    ?    ?    1    1  : 1 : 1;
   r    ?    ?    1    0    0  : 0 : 0;

  (?x)  ?    1    1    ?    0  : 0 : 0;
  (?x)  ?    1    1    ?    1  : 1 : 1;
  (?x)  ?    0    ?    1    ?  : 1 : -;
  (?x)  ?    0    1    0    ?  : 0 : -;

  (?x)  0    x    1    0    0  : 0 : 0;
  (?x)  0    x    1    1    1  : 1 : 1;
  (?x)  1    x    1    ?    0  : 0 : -;
  (?x)  1    x    1    ?    1  : 1 : -;
  (?x)  x    x    ?    1    1  : 1 : 1;
  (?x)  ?    ?    1    0    0  : 0 : 0;
  (?x)  1    0    x    ?    ?  : 1 : 1;
  (?x)  ?    1    x    ?    1  : 1 : 1;
  (?x)  0    x    x    1    1  : 1 : 1;
  (?x)  1    x    x    ?    1  : 1 : 1;

   0    ?    ?    x    ?    ?  : 1 : 1;
   ?    ?    ?   (?x)  ?    ?  : 1 : 1;

   n    ?    ?    1    ?    ?  : ? : -;

   *    1    0    1    ?    ?  : ? : -;
   ?    *    ?    1    ?    ?  : ? : -;
   ?    *    0    x    1    ?  : 1 : 1;
   ?    *    1    x    ?    1  : 1 : 1;
   ?    *    x    x    1    1  : 1 : 1;
   ?    ?    *    1    ?    ?  : ? : -;
   ?    ?    *    x    1    1  : 1 : 1;
   ?    1    *    x    ?    1  : 1 : 1;
   ?    ?    ?   (?1)  ?    ?  : ? : -;
   ?    ?    ?    1    *    ?  : ? : -;
   ?    1    ?    x    *    ?  : 1 : 1;
   ?    ?    ?    1    ?    *  : ? : -;
   ?    ?    0    x    ?    *  : 1 : 1;

endtable
endprimitive

primitive U_FD_SC_EN_P_SB_NO (Q,CP,ENN,SC,SDN,D,SD,NOT_REG);

   output Q;
   reg    Q;
   input  CP,ENN,SC,SDN,D,SD,NOT_REG;

//FUNCTION : Muxed Scan D Flip-Flop with Set and Enable,Q only

table
// CP   ENN  SC   SDN  D   SD NOT_REG : - : Q;

   ?    ?    ?    0    ?    ?    ?   : ? : 1;

   r    ?    1    1    ?    0    ?   : ? : 0;
   r    ?    1    1    ?    1    ?   : ? : 1;
   r    0    0    1    0    ?    ?   : ? : 0;
   r    0    0    1    1    ?    ?   : ? : 1;
   r    ?    0    ?    1    ?    ?   : 1 : -;
   r    ?    0    1    0    ?    ?   : 0 : -;

   r    0    x    1    0    0    ?   : ? : 0;
   r    0    x    1    1    1    ?   : ? : 1;
   r    1    x    1    ?    0    ?   : 0 : -;
   r    1    x    1    ?    1    ?   : 1 : -;
   r    ?    1    x    ?    1    ?   : ? : 1;
   r    0    0    x    1    ?    ?   : ? : 1;
   r    1    0    x    ?    ?    ?   : 1 : 1;
   r    0    x    x    1    1    ?   : ? : 1;
   r    1    x    x    ?    1    ?   : 1 : 1;
   r    ?    ?    ?    1    1    ?   : 1 : 1;
   r    ?    ?    1    0    0    ?   : 0 : 0;

  (?x)  ?    1    1    ?    0    ?   : 0 : 0;
  (?x)  ?    1    1    ?    1    ?   : 1 : 1;
  (?x)  ?    0    ?    1    ?    ?   : 1 : -;
  (?x)  ?    0    1    0    ?    ?   : 0 : -;

  (?x)  0    x    1    0    0    ?   : 0 : 0;
  (?x)  0    x    1    1    1    ?   : 1 : 1;
  (?x)  1    x    1    ?    0    ?   : 0 : -;
  (?x)  1    x    1    ?    1    ?   : 1 : -;
  (?x)  x    x    ?    1    1    ?   : 1 : 1;
  (?x)  ?    ?    1    0    0    ?   : 0 : 0;
  (?x)  1    0    x    ?    ?    ?   : 1 : 1;
  (?x)  ?    1    x    ?    1    ?   : 1 : 1;
  (?x)  0    x    x    1    1    ?   : 1 : 1;
  (?x)  1    x    x    ?    1    ?   : 1 : 1;

   0    ?    ?    x    ?    ?    ?   : 1 : 1;
   ?    ?    ?   (?x)  ?    ?    ?   : 1 : 1;

   n    ?    ?    1    ?    ?    ?   : ? : -;

   *    1    0    1    ?    ?    ?   : ? : -;
   ?    *    ?    1    ?    ?    ?   : ? : -;
   ?    *    0    x    1    ?    ?   : 1 : 1;
   ?    *    1    x    ?    1    ?   : 1 : 1;
   ?    *    x    x    1    1    ?   : 1 : 1;
   ?    ?    *    1    ?    ?    ?   : ? : -;
   ?    ?    *    x    1    1    ?   : 1 : 1;
   ?    1    *    x    ?    1    ?   : 1 : 1;
   ?    ?    ?   (?1)  ?    ?    ?   : ? : -;
   ?    ?    ?    1    *    ?    ?   : ? : -;
   ?    1    ?    x    *    ?    ?   : 1 : 1;
   ?    ?    ?    1    ?    *    ?   : ? : -;
   ?    ?    0    x    ?    *    ?   : 1 : 1;

   ?    ?    ?    ?    ?    ?    *   : ? : x;

endtable
endprimitive

primitive U_LD_N (Q, D, GN); 

//
// FUNCTION :  D-LATCH, GATED  ACTIVE LOW / STANDARD DRIVE ( Q OUTPUT UDP )
//

    output Q; 
    reg    Q;                               
    input  D, 
           GN;       // Gate- active low

    table
     //  D     GN    : Qt  :   Qt+1

         ?      1    :  ?  :    -   ;   //clock disabled

         0      0    :  ?  :    0   ;  //clock enabled transparent
         1      0    :  ?  :    1   ;  //data

         1      x    :  1  :    1   ;  //reducing pessimism
         0      x    :  0  :    0   ; 
         
   endtable
endprimitive

primitive U_LD_N_NO (Q, D, GN, NOTI_REG); 

    output Q; 
    reg    Q;                               
    input  D,                // data
           GN,                // clock
           NOTI_REG;         // NOTIFY_REG
// FUNCTION :  D-LATCH, GATED  ACTIVE LOW / STANDARD DRIVE ( Q OUTPUT UDP )
//


   table
     //  D       GN    NOTI_REG        : Qt  :   Qt+1

         ?      (?1)    ?             :  ?  :    -   ;

         *       1      ?             :  ?  :    -   ;

       (?0)      0      ?             :  ?  :    0   ;
       (?1)      0      ?             :  ?  :    1   ; 
        0       (10)    ?             :  ?  :    0   ;
        1       (10)    ?             :  ?  :    1   ; 

         1      x      ?             :  1  :    1   ;    // Reducing pessimism.
         0      x      ?             :  0  :    0   ; 

         0      (1x)    ?             :  0  :    0   ;   // Reducing pessimism.
         1      (1x)    ?             :  1  :    1   ;
         0      (x0)    ?             :  ?  :    0   ;
         1      (x0)    ?             :  ?  :    1   ;
         
         ?       ?      *             :  ?  :    x   ;

   endtable
endprimitive

primitive U_FD_P  (Q, D, CP);

    output Q;  
    input  D, CP;
    reg    Q;  

// FUNCTION :  POSITIVE EDGE TRIGGERED D FLIP-FLOP ( Q OUTPUT UDP ).

    table
 
    //  D   CP        :   Qt  :   Qt+1

        1   (01)      :   ?   :   1;  // clocked data
        0   (01)      :   ?   :   0;
                                                           
        1   (x1)      :   1   :   1;  // reducing pessimism
        0   (x1)      :   0   :   0;                          
        1   (0x)      :   1   :   1;  
        0   (0x)      :   0   :   0; 
        
        ?   (1x)      :   ?   :   -;  // no change on falling edge 
        ?   (?0)      :   ?   :   -;  

        *    ?        :   ?   :   -;  // ignore edges on data

    endtable
endprimitive

primitive U_FD_P_NO (Q, D, CP , NOTIFIER_REG); 

    output Q;  
    input  NOTIFIER_REG,
           D, CP;
    reg    Q;  

// FUNCTION :  POSITIVE EDGE TRIGGERED D FLIP-FLOP ( Q OUTPUT UDP ).


    table
 
    //  D   CP           NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)            ?          :   ?   :   1;  // clocked data
        0   (01)            ?          :   ?   :   0;
                                                           
        1   (x1)            ?          :   1   :   1;  // reducing pessimism
        0   (x1)            ?          :   0   :   0;                          
        1   (0x)            ?          :   1   :   1;  
        0   (0x)            ?          :   0   :   0; 
        
        ?   (1x)            ?          :   ?   :   -;  // no change on falling edge 
        ?   (?0)            ?          :   ?   :   -;  

        *    ?              ?          :   ?   :   -;  // ignore edges on data
        
        ?    ?              *          :   ?   :   x;
    endtable
endprimitive

primitive U_LD_N_RB (Q, D, GN, RB); 

//
// FUNCTION : D-LATCH, CLEAR DIRECT( ACTIVE LOW ), GATE ACTIVE LOW 
//             STANDARD DRIVE ( Q OUTPUT UDP )


    output Q; 
    reg    Q;                               
    input  D,
           GN,                                      // Gate- active low
           RB;                                      // Clear- active low

    table
     //  D     GN      RB      : Qt  :   Qt+1
   
         ?      1      1       :  ?  :    -   ;     // latch state

         0      0      1       :  ?  :    0   ;     // latch data
         1      0      1       :  ?  :    1   ;            

         1      x      1       :  1  :    1   ;     // Reducing pessimism.
         0      x      1       :  0  :    0   ;     // Reducing pessimism.

         ?      ?      0       :  ?  :    0   ;    // clear    
     
         ?      1      x       :  0  :    0   ;      // Reducing pessimism.
         0      0      x       :  ?  :    0   ;      // Reducing pessimism.
         0      ?      x       :  0  :    0   ;      // Reducing pessimism.

    endtable
endprimitive

primitive U_LD_P (Q, D, G); 

//
// FUNCTION : DLATCH, GATED  STANDARD DRIVE / ACTIVE HIGH ( Q OUTPUT UDP )
//

    output Q; 
    reg    Q;                               
    input  D, G;

   table
     //  D      G    : Qt  :   Qt+1

         ?      0    :  ?  :    -   ;    // clock disabled   

         0      1    :  ?  :    0   ;  //clock enabled 
         1      1    :  ?  :    1   ;  //transparent data 

         1      x    :  1  :    1   ;  // Reducing pessimism.
         0      x    :  0  :    0   ; 
                                       
   endtable
endprimitive

primitive U_LD_P_NO (Q, D, G, NOTI_REG); 

    output Q; 
    reg    Q;                               
    input  D,              // data
           G,              // clock
           NOTI_REG;       
// FUNCTION : DLATCH, GATED  STANDARD DRIVE / ACTIVE HIGH ( Q OUTPUT UDP )
//

   table
     //  D       G    NOTI_REG        : Qtn :   Qtn+1

         *       0      ?             :  ?  :    -   ;
         ?      (?0)    ?             :  ?  :    -   ;
	 0      (0x)    ?             :  0  :    0   ;
         1      (0x)    ?             :  1  :    1   ;
         0      (x1)    ?             :  ?  :    0   ;
         1      (x1)    ?             :  ?  :    1   ;
        (?0)     1      ?             :  ?  :    0   ;
        (?1)     1      ?             :  ?  :    1   ; 
         0      (01)    ?             :  ?  :    0   ;
         1      (01)    ?             :  ?  :    1   ; 
         1      x      ?             :  1  :    1   ;    // Reducing pessimism.
         0      x      ?             :  0  :    0   ; 
         
         ?       ?      *             :  ?  :    x   ;

   endtable
endprimitive

primitive U_LD_P_RB (Q, D, G, RB); 

//
// FUNCTION : D-LATCH, GATED  CLEAR DIRECT /GATE ACTIVE HIGH ( Q OUTPUT UDP ) 
//

    output Q; 
    reg    Q;                               
    input  D,
           G,                                       // Gate- active high
           RB;                                      // Clear-active low

    table
     //  D      G     RB       : Qt  :   Qt+1

         ?      0      1       :  ?  :    -   ;     // latch state 

         0      1      1       :  ?  :    0   ;     // latch data
         1      1      1       :  ?  :    1   ;            

         1      x      1       :  1  :    1   ;     // Reducing pessimism.
         0      x      1       :  0  :    0   ;     // Reducing pessimism
       
         ?      ?      0       :  ?  :    0   ;      // Clear

         0      1      x       :  ?  :    0   ;      // Reducing pessimism.
         0      ?      x       :  0  :    0   ;      // Reducing pessimism.
         
         ?      0      x       :  0  :    0   ;      // Reducing pessimism 
   
      endtable
endprimitive

primitive U_LD_P_RB_NO (Q, D, G, RB, NOTI_REG); 

    output Q; 
    reg    Q;                               
    input  D,               // DATA
           G,               // CLOCK
           RB,              // CLEAR ACTIVE LOW
           NOTI_REG;        // NOTIFY REG
// FUNCTION : D-LATCH, GATED  CLEAR DIRECT /GATE ACTIVE HIGH ( Q OUTPUT UDP ) 
//

   table
     //  D       G      RB    NOTI_REG       : Qt  :   Qt+1

         *       0      1      ?             :  ?  :    -   ;

         ?       ?      0      ?             :  ?  :    0   ; // asynchro clear

         ?      (?0)    1      ?             :  ?  :    -   ; //AB

         0      (0x)    1      ?             :  0  :    0   ;
         1      (0x)    1      ?             :  1  :    1   ;
         0      (x1)    1      ?             :  ?  :    0   ;
         1      (x1)    1      ?             :  ?  :    1   ;

        (?0)     1      1      ?             :  ?  :    0   ;
        (?1)     1      1      ?             :  ?  :    1   ; 
         0      (01)    1      ?             :  ?  :    0   ;
         1      (01)    1      ?             :  ?  :    1   ; 

         ?       0      x      ?             :  0  :    0   ;   // Reducing pessimism.//AB

        (?0)     x      x      ?             :  0  :    0   ;   // Reducing pessimism.//AB
         0       x      *      ?             :  0  :    0   ;   // Reducing pessimism.//AB
         0      (0x)    x      ?             :  0  :    0   ;   // Reducing pessimism.//AB
         
         0      (?1)    x      ?             :  ?  :    0   ;   // Reducing pessimism.
        (?0)     1      x      ?             :  ?  :    0   ;   // Reducing pessimism.
         0       1     (?x)    ?             :  ?  :    0   ;   // Reducing pessimism.//AB

         ?       0     (?1)    ?             :  ?  :    -   ;   // ignore edge on clear
         0       1     (?1)    ?             :  ?  :    0   ;   // pessimism .
         1       1     (?1)    ?             :  ?  :    1   ;  

         1       x      1      ?             :  1  :    1   ;   // Reducing pessimism.
         0       x      1      ?             :  0  :    0   ;   // Reducing pessimism.
         
         ?       ?      ?      *             :  ?  :    x   ;

   endtable
endprimitive

primitive U_LD_P_SB_RB ( Q, D, CK, RB, SB );

   output Q; 
   reg    Q;
   input  D,  CK, RB, SB;

// FUNCTION : POSITIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND RESET ( Q OUTPUT UDP ).

table
    //  D   CK  RB  SB  :   Qt  :   Qt+1

        1   1   1   1   :   ?   :   1;  // clock enabled transparent data.
        0   1   1   1   :   ?   :   0;

        1   x   1   1   :   1   :   1;  // possible enabled clock.
        0   x   1   1   :   0   :   0;

        ?   ?   0   1   :   ?   :   0;  // asynchronous reset.
        ?   ?   ?   0   :   ?   :   1;  // asynchronous set override.

        ?   0   1   1   :   ?   :   -;  // clock disabled.

        0   1   x   1   :   ?   :   0;  // pessimism 
        0   ?   x   1   :   0   :   0;  // pessimism 
        1   1   1   x   :   ?   :   1;  // pessimism 
        1   ?   1   x   :   1   :   1;  // pessimism                       

        ?   0   x   1   :   0  :    0;  // set inactive                    
        ?   0   1   x   :   1  :    1;  // reset inactive    
  
   endtable  
endprimitive

primitive U_LD_P_SB_RB_NO (Q, D, G, RB, SB, NOTI_REG); 

    output Q; 
    reg    Q;                               
    input  D,               // DATA
           G,               // CLOCK
           RB,              // CLEAR ACTIVE LOW
           SB,              // SET ACTIVE LOW
           NOTI_REG;        // NOTIFY_REG
// FUNCTION : POSITIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND RESET.  ( Q OUTPUT UDP ).


   table
     //  D       G      RB    SB   NOTI_REG       : Qt  :   Qt+1
                                  

         *       0      1     1     ?             :  ?  :    -   ;

         ?       ?      0     1     ?             :  ?  :    0   ; // asynchro clear
         ?       ?      ?     0     ?             :  ?  :    1   ; // asynch set
                                                                    // occurs 
         ?      (?0)    1     1     ?             :  ?  :    -   ;  //AB

         0       x      1     1     ?             :  0  :    0   ;
         1       x      1     1     ?             :  1  :    1   ;

         1       1      1     1     ?             :  ?  :    1   ;
         0       1      1     1     ?             :  ?  :    0   ;

         ?       0      x     1     ?             :  0  :    0   ;   // Reducing pessimism.//AB
         0       ?      x     1     ?             :  0  :    0   ;   // Reducing pessimism.//AB

         0       x      *     1     ?             :  0  :    0   ;   // Reducing pessimism.//AB

         0       1      ?     1     ?             :  ?  :    0   ; // When SB=1 D=0 and G=1,no matter what RB is,Q=0.

         ?       0      1     x     ?             :  1  :    1   ;   // Reducing pessimism.//AB

         1       x      1     x     ?             :  1  :    1   ;   // Reducing pessimism.//AB
         1       x      1     *     ?             :  1  :    1   ;   // Reducing pessimism.//AB

         1       1      1     x     ?             :  ?  :    1   ; // Reducing pessimism.

         ?       0     (?1)   1     ?             :  ?  :    -   ;   // ignore edge on clear
         ?       0      1    (?1)   ?             :  ?  :    -   ;   // ignore edge on set

         ?       ?      ?     ?     *             :  ?  :    x   ;

   endtable
endprimitive

primitive U_LD_P_SB_RB_QN ( QN, D, CK, RB, SB );

   output QN; 
   reg    QN;
   input  D,  CK,  RB, SB;

// FUNCTION : POSITIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND RESET ( QN OUTPUT UDP ).

table
    //  D   CK  RB  SB  :   Qtn : Qtn+1

        1   1   1   1   :   ?   :   0;  // clock enabled transparent data.
        0   1   1   1   :   ?   :   1;

        1   x   1   1   :   0   :   0;  // possible enabled clock.
        0   x   1   1   :   1   :   1;

        ?   ?   1   0   :   ?   :   0;  // asynchronous set 
        ?   ?   0   ?   :   ?  :    1;  // asynchronous reset

        ?   0   1   1   :   ?   :   -;  // clock disabled.

        0   1   x   1   :   ?   :   1;  // pessimism 
        0   ?   x   1   :   1   :   1;  // pessimism 
        1   1   1   x   :   ?   :   0;  // pessimism 
        1   ?   1   x   :   0   :   0;  // pessimism                       

        ?   0   x   1   :   1  :    1;  // set inactive                    
        ?   0   1   x   :   0  :    0;  // reset inactive    
  
   endtable  
endprimitive

primitive U_LD_P_SB_RB_QN_NO ( QN, D, CK, RB, SB, NOTIFIER_REG );
   output QN; 
   reg    QN;
   input  D, 
         CK, 
         RB, 
         SB,
	 NOTIFIER_REG;

// FUNCTION : POSITIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE LOW
//            ASYNCHRONOUS SET AND RESET ( QN OUTPUT UDP ).


table
    //  D   CK  RB  SB  NOTIFIER_REG  :   Qtn : Qtn+1

        1   1   1   1     ?           :   ?   :   0;  // clock enabled transparent data.
        0   1   1   1     ?           :   ?   :   1;

        1   x   1   1     ?           :   0   :   0;  // possible enabled clock.
        0   x   1   1     ?           :   1   :   1;

        ?   ?   0   ?     ?           :   ?  :    1; // asynchronous reset
        ?   ?   1   0     ?           :   ?   :   0;  // asynchronous set 
        *   0   1   1     ?           :   ?   :   -;
        ?   0   r   1     ?           :   ?   :   -;
        ?   0   1   r     ?           :   ?   :   -;

        0   1   x   1     ?           :   ?   :   1;  // pessimism 
        0   ?   x   1     ?           :   1   :   1;  // pessimism 
        1   1   1   x     ?           :   ?   :   0;  // pessimism 
        1   ?   1   x     ?           :   0   :   0;  // pessimism                       

        ?   0   x   1     ?           :   1  :    1;  // set inactive                    
        ?   0   1   x     ?           :   0  :    0;  // reset inactive    

        ?  (?0) 1   1     ?           :   ?  :    -;
        ?   ?   ?   ?     *           :   ?  :    x;

   endtable  
endprimitive

primitive U_MUX_2_1 (Q, A, B, SL);
    output Q;
    input A, B, SL;

// FUNCTION :  TWO TO ONE MULTIPLEXER

    table
    //  A   B   SL  :   Q
        0   0   ?   :   0 ;
        1   1   ?   :   1 ;

        0   ?   0   :   0 ;
        1   ?   0   :   1 ;

        ?   0   1   :   0 ;
        ?   1   1   :   1 ;

    endtable
endprimitive    

primitive U_MUX_4_2 (Y, D0, D1, D2, D3, S0, S1);

    input D0, D1, D2, D3, S0, S1;
    output Y;
   
// FUNCTION :  FOUR TO ONE MULTIPLEXER WITH 2 SELECT CONTROLS

    table

//   D0  D1  D2 D3  S0  S1 : Y
                       
     0   ?   ?  ?    0  0  : 0 ; 
     1   ?   ?  ?    0  0  : 1 ; 
                                 
     ?   0   ?  ?    1  0  : 0 ; 
     ?   1   ?  ?    1  0  : 1 ; 
                                 
     ?   ?   0  ?    0  1  : 0 ; 
     ?   ?   1  ?    0  1  : 1 ; 
                                 
     ?   ?   ?  0    1  1  : 0 ; 
     ?   ?   ?  1    1  1  : 1 ; 
                                 
                                 
     0   0   0   0   ?  ?  : 0 ; 
                       
     1   1   1   1   ?  ?  : 1 ; 

     0   0   ?   ?   ?  0  : 0 ;    
     1   1   ?   ?   ?  0  : 1 ; 

     ?   ?   0   0   ?  1  : 0 ; 
     ?   ?   1   1   ?  1  : 1 ; 

     0   ?   0   ?   0  ?  : 0 ; 
     1   ?   1   ?   0  ?  : 1 ; 

     ?   0   ?   0   1  ?  : 0 ; 
     ?   1   ?   1   1  ?  : 1 ; 
                 
     endtable
endprimitive

primitive U_L_SB_RB_NO ( Q, SB, RB, NOTI_REG);
      output Q;	
      reg Q;
      input SB, RB, NOTI_REG;

// FUNCTION : CROSS-COUPLED NAND LATCH.  SET AND RESET ARE ACTIVE LOW.  RESET IS
//            DOMINANT ( Q OUTPUT UDP ).

//  This model does not reflect the data ambiguity when set and
//  reset are both active and simultaneously change to inactive.

table
  //   SB   RB  NOTI_REG  :  Qt  :  Qt+1                                   
                                                                
        1   (?1)     ?    :   ?  :     -;  // Latch state.                
       (?1)  1       ?    :   ?  :     -;  // Latch state.                
        1    0       ?    :   ?  :     0;  // Reset state.                
        0    1       ?    :   ?  :     1;  // set state.                  
        0    0       ?    :   ?  :     0;  // Set overrided by reset.        
                                                                
        x    0       ?    :   ?  :     0;                                 
                                                                
        1    x       ?    :   0  :     0;  // Indeterminate set and reset.
        x    1       ?    :   1  :     1;

        ?    ?       *    :   ?  :     x;  

endtable
endprimitive

primitive U_L_SB_RB_QN_NO (QN, SB, RB, NOTI_REG);
      output QN;
      reg QN;
      input SB, RB, NOTI_REG;

// FUNCTION : CROSS-COUPLED NAND LATCH.  SET AND RESET ARE ACTIVE LOW.  SET IS
//            DOMINANT ( QN OUTPUT UDP ).

//  This model does not reflect the data ambiguity when set and
//  reset are both active and simultaneously change to inactive.

table
  //   SB   RB  NOTI_REG  :  QNt  :  QNt+1                                   
                                                                
        1   (?1)    ?    :   ?  :     -;  // Latch state.                
       (?1)  1      ?    :   ?  :     -;  // Latch state.                
        1    0      ?     :   ?  :     1;  // Reset state.                
        0    1      ?     :   ?  :     0;  // set state.                  
        0    0      ?     :   ?  :     0;  // Set overrides reset.        
                                                                
        0    x      ?     :   ?  :     0;                                 
                                                                
        1    x      ?     :   1  :     1;  // Indeterminate set and reset.
        x    1      ?     :   0  :     0;

        ?    ?      *     :   ?  :     x;

endtable
endprimitive

primitive U_L_SB_RB ( Q, SB, RB);
      output Q;	
      reg Q;
      input SB, RB;

// FUNCTION : CROSS-COUPLED NAND LATCH.  SET AND RESET ARE ACTIVE LOW.  RESET IS
//            DOMINANT ( Q OUTPUT UDP ).

//  This model does not reflect the data ambiguity when set and
//  reset are both active and simultaneously change to inactive.

table
  //   SB   RB  :  Qt  :  Qt+1                                   
                                                                
        1    1  :   ?  :     -;  // Latch state.                
        1    0  :   ?  :     0;  // Reset state.                
        0    1  :   ?  :     1;  // set state.                  
        0    0  :   ?  :     0;  // Set overrided by reset.        
                                                                
        x    0  :   ?  :     0;                                 
                                                                
        1    x  :   0  :     0;  // Indeterminate set and reset.
        x    1  :   1  :     1;

endtable
endprimitive

primitive U_L_SB_RB_QN (QN, SB, RB);
      output QN;
      reg QN;
      input SB, RB;

// FUNCTION : CROSS-COUPLED NAND LATCH.  SET AND RESET ARE ACTIVE LOW.  SET IS
//            DOMINANT ( QN OUTPUT UDP ).

//  This model does not reflect the data ambiguity when set and
//  reset are both active and simultaneously change to inactive.

table
  //   SB   RB  :  QNt  :  QNt+1                                   
                                                                
        1    1  :   ?  :     -;  // Latch state.                
        1    0  :   ?  :     1;  // Reset state.                
        0    1  :   ?  :     0;  // set state.                  
        0    0  :   ?  :     0;  // Set overrides reset.        
                                                                
        0    x  :   ?  :     0;                                 
                                                                
        1    x  :   1  :     1;  // Indeterminate set and reset.
        x    1  :   0  :     0;

endtable
endprimitive

primitive U_MUX_2_1_INV (Y, D0, D1, S);

    input D0, D1, S;
    output Y;
   
// FUNCTION :  TWO TO ONE MULTIPLEXER  WITH INVERTING OUTPUT

    table
//   D0  D1  S  : Y
  
     0   ?   0  : 1 ;
     1   ?   0  : 0 ;

     ?   0   1  : 1 ;
     ?   1   1  : 0 ;

     0   0   ?  : 1 ;
     1   1   ?  : 0 ;

     endtable
endprimitive

primitive U_SUB2_C (CO, A, B, CI);

    output CO;
    input CI, A, B;
          
// FUNCTION : 1-bit SUBTRACTOR (A - B) carry out term 

// Conventions :  CI = BORROW IN , CO = BORROW OUT
// CI = 0 implies borrow is on  i.e. previous stage is 
// borrowing from this stage and CI =  1 implies  
// no borrow 
// CO = 0 implies borrow out is on  i.e. this stage
// will borrow from next stage  
                                      

    table
    //  A   B   CI  :   CO
        0   ?   0   :   0 ;  // A < B , so borrow from next stage  

        ?   0   1   :   1 ;  // no borrow in and A >= B ,
                             // so don't borrow from next stage

        0   1   ?   :   0 ;  // A < B , so borrow from next stage

        1   0   ?   :   1 ;  // A > B , NO borrow from next stage

        ?   1   0   :   0 ;  // A <= B and borrow in is on , so
                             // borrow from next stage   

        1   ?   1   :   1 ;  // A >= B , and no borrow in ,
                             // so don't borrow from next stage
  
    endtable
endprimitive   

primitive U_SUB2_D (S, A, B, CI);

    output S;
    input CI, A, B;
          
// FUNCTION : 1-bit SUBTRACTOR Difference ( A - B) out term 

// Conventions :  CI = BORROW IN , S = DIFFERENCE 
// CI = 0 implies borrow is on i.e. previous stage is 
// borrowing from this stage and CI =  1 implies
// no borrow

    table
    //  A   B   CI  :   S           Operation performed
        0   0   0   :   1 ;     //  S =  10  - 1 - 0 
        0   0   1   :   0 ;     //  S =  0 - 0
        0   1   0   :   0 ;     //  S =  10 - 1 - 1 
        0   1   1   :   1 ;     //  S =  10 - 1 
        1   0   0   :   0 ;     //  S =  1 - 1 - 0
        1   0   1   :   1 ;     //  S =  1 - 0
        1   1   0   :   1 ;     //  S =  11 - 1 - 1
        1   1   1   :   0 ;     //  S =  1 - 1

    endtable
endprimitive   
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx02d0.v
// Description          : 2-to-1 Multiplexer, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs		: 14Aug05 ben gilboa 
//


module mx02d0 (I0,I1,S,Z);

output  Z;
input   I0,I1,S;

U_MUX_2_1 #1 (Z,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
 if ((I1 == 1'b0) && (I0 == 1'b1))
 	(S => Z) = (default_rise,default_fall);
 if ((I1 == 1'b1) && (I0 == 1'b0))
 	(S => Z) = (default_rise,default_fall);
 ifnone (S => Z) = (default_rise,default_fall);

 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx02d1.v
// Description  	:  2-to-1 Multiplexer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs		: 14Aug05 ben gilboa 
//


module mx02d1 (I0,I1,S,Z);

output  Z;
input   I0,I1,S;

U_MUX_2_1 #1 (Z,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
 if ((I1 == 1'b0) && (I0 == 1'b1))
 	(S => Z) = (default_rise,default_fall);
 if ((I1 == 1'b1) && (I0 == 1'b0))
 	(S => Z) = (default_rise,default_fall);

 ifnone (S => Z) = (default_rise,default_fall);
 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx02d2.v
// Description  	:  2-to-1 Multiplexer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs		: 14Aug05 ben gilboa 
//


module mx02d2 (I0,I1,S,Z);

output  Z;
input   I0,I1,S;

U_MUX_2_1 #1 (Z,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
 if ((I1 == 1'b0) && (I0 == 1'b1))
 	(S => Z) = (default_rise,default_fall);
 if ((I1 == 1'b1) && (I0 == 1'b0))
 	(S => Z) = (default_rise,default_fall);
  ifnone (S => Z) = (default_rise,default_fall);
 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx02d4.v
// Description  	:  2-to-1 Multiplexer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs		: 14Aug05 ben gilboa 
//


module mx02d4 (I0,I1,S,Z);

output  Z;
input   I0,I1,S;

U_MUX_2_1 #1 (Z,I0,I1,S);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
 if ((I1 == 1'b0) && (I0 == 1'b1))
 	(S => Z) = (default_rise,default_fall);
 if ((I1 == 1'b1) && (I0 == 1'b0))
 	(S => Z) = (default_rise,default_fall);
 ifnone (S => Z) = (default_rise,default_fall);
 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx04d0.v
// Description          : 4-to-1 Multiplexer, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module mx04d0 (I0,I1,I2,I3,S0,S1,Z);

output  Z;
input   I0,I1,I2,I3,S0,S1;

U_MUX_4_2 #1 (Z,I0,I1,I2,I3,S0,S1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
ifnone (S0 => Z) = (default_rise,default_fall);	
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
ifnone (S1 => Z) = (default_rise,default_fall);

 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
 (        I2 +=> Z) = (default_rise,default_fall);
 (        I3 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx04d1.v
// Description  	:  4-to-1 Multiplexer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mx04d1 (I0,I1,I2,I3,S0,S1,Z);

output  Z;
input   I0,I1,I2,I3,S0,S1;

U_MUX_4_2 #1 (Z,I0,I1,I2,I3,S0,S1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
ifnone (S0 => Z) = (default_rise,default_fall);	
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
ifnone (S1 => Z) = (default_rise,default_fall);

 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
 (        I2 +=> Z) = (default_rise,default_fall);
 (        I3 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx04d2.v
// Description  	:  4-to-1 Multiplexer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mx04d2 (I0,I1,I2,I3,S0,S1,Z);

output  Z;
input   I0,I1,I2,I3,S0,S1;

U_MUX_4_2 #1 (Z,I0,I1,I2,I3,S0,S1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
ifnone (S0 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
ifnone (S1 => Z) = (default_rise,default_fall);

 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
 (        I2 +=> Z) = (default_rise,default_fall);
 (        I3 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx04d4.v
// Description  	:  4-to-1 Multiplexer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module mx04d4 (I0,I1,I2,I3,S0,S1,Z);

output  Z;
input   I0,I1,I2,I3,S0,S1;

U_MUX_4_2 #1 (Z,I0,I1,I2,I3,S0,S1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S0 => Z) = (default_rise,default_fall);
if ((S1 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S0 => Z) = (default_rise,default_fall);
ifnone (S0 => Z) = (default_rise,default_fall);	
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b0) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b0) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b0) && (I2 == 1'b1) && (I1 == 1'b1) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b0) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b0))
	(S1 => Z) = (default_rise,default_fall);
if ((S0 == 1'b1) && (I3 == 1'b1) && (I2 == 1'b1) && (I1 == 1'b0) && (I0 == 1'b1))
	(S1 => Z) = (default_rise,default_fall);
ifnone (S1 => Z) = (default_rise,default_fall);

 (        I0 +=> Z) = (default_rise,default_fall);
 (        I1 +=> Z) = (default_rise,default_fall);
 (        I2 +=> Z) = (default_rise,default_fall);
 (        I3 +=> Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx08d1.v
// Description  	:  8-to-1 Multiplexer, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mx08d1 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output  Z;
input   I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;

wire I0_buf;
wire I1_buf;
wire I2_buf;
wire I3_buf;
wire I4_buf;
wire I5_buf;
wire I6_buf;
wire I7_buf;
wire S0_buf;
wire S1_buf;
wire S2_buf;

buf b_I0 (I0_buf,I0);
buf b_I1 (I1_buf,I1);
buf b_I2 (I2_buf,I2);
buf b_I3 (I3_buf,I3);
buf b_I4 (I4_buf,I4);
buf b_I5 (I5_buf,I5);
buf b_I6 (I6_buf,I6);
buf b_I7 (I7_buf,I7);
buf b_S0 (S0_buf,S0);
buf b_S1 (S1_buf,S1);
buf b_S2 (S2_buf,S2);

`ifdef udp_input_ge_10
U_MUX_8_3 (Z,I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf);
`else
s_mx08d1 g1_s_mx08d1_1(I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf,Z);

`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam i0_lh_z_lh=0,i0_hl_z_hl_1=0,s0_lh_z_lh=0,s0_hl_z_hl=0,
 s1_lh_z_lh=0,s1_hl_z_hl_1=0,s2_lh_z_lh=0,s2_hl_z_hl=0,i1_lh_z_lh=0,
 i1_hl_z_hl=0,i3_lh_z_lh=0,i3_hl_z_hl=0,i2_lh_z_lh=0,i2_hl_z_hl=0,
 i6_lh_z_lh=0,i6_hl_z_hl=0,i7_lh_z_lh=0,i7_hl_z_hl=0,i5_lh_z_lh=0,
 i5_hl_z_hl=0,i4_lh_z_lh=0,i4_hl_z_hl=0;
// Delays
 (        S0  => Z) = (s0_lh_z_lh,s0_hl_z_hl);
 (        S1  => Z) = (s1_lh_z_lh,s1_hl_z_hl_1);
 (        S2  => Z) = (s2_lh_z_lh,s2_hl_z_hl);
 (        I0 +=> Z) = (i0_lh_z_lh,i0_hl_z_hl_1);
 (        I1 +=> Z) = (i1_lh_z_lh,i1_hl_z_hl);
 (        I3 +=> Z) = (i3_lh_z_lh,i3_hl_z_hl);
 (        I2 +=> Z) = (i2_lh_z_lh,i2_hl_z_hl);
 (        I6 +=> Z) = (i6_lh_z_lh,i6_hl_z_hl);
 (        I7 +=> Z) = (i7_lh_z_lh,i7_hl_z_hl);
 (        I5 +=> Z) = (i5_lh_z_lh,i5_hl_z_hl);
 (        I4 +=> Z) = (i4_lh_z_lh,i4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

`ifdef udp_input_ge_10
`else
module s_mx08d1 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output    Z;
input     I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;
reg       reg_Z,xreg_Z,flag_Z;
buf #0.01 (Z,reg_Z);

always @ (S2 or S1 or S0 or I7 or I6 or I5 or I4 or I3 or I2 or I1 or 
          I0) begin
 if ((S2===0) && (S1===0) && (S0===0)) reg_Z=I0;
 else if ((S2===0) && (S1===0) && (S0===1)) reg_Z=I1;
 else if ((S2===0) && (S1===1) && (S0===1)) reg_Z=I3;
 else if ((S2===0) && (S1===1) && (S0===0)) reg_Z=I2;
 else if ((S2===1) && (S1===1) && (S0===0)) reg_Z=I6;
 else if ((S2===1) && (S1===1) && (S0===1)) reg_Z=I7;
 else if ((S2===1) && (S1===0) && (S0===1)) reg_Z=I5;
 else if ((S2===1) && (S1===0) && (S0===0)) reg_Z=I4;
 else if ((S2===1'bx) || (S1===1'bx) || (S0===1'bx)) begin
  flag_Z=1;
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   xreg_Z=I0;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I1;
   else if (xreg_Z!==I1) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I3;
   else if (xreg_Z!==I3) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I2;
   else if (xreg_Z!==I2) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I6;
   else if (xreg_Z!==I6) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I7;
   else if (xreg_Z!==I7) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I5;
   else if (xreg_Z!==I5) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I4;
   else if (xreg_Z!==I4) xreg_Z=1'bx;
   flag_Z=0;
  end
  reg_Z=xreg_Z;
 end
end

endmodule
`endif
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx08d2.v
// Description  	:  8-to-1 Multiplexer, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mx08d2 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output  Z;
input   I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;

wire I0_buf;
wire I1_buf;
wire I2_buf;
wire I3_buf;
wire I4_buf;
wire I5_buf;
wire I6_buf;
wire I7_buf;
wire S0_buf;
wire S1_buf;
wire S2_buf;

buf b_I0 (I0_buf,I0);
buf b_I1 (I1_buf,I1);
buf b_I2 (I2_buf,I2);
buf b_I3 (I3_buf,I3);
buf b_I4 (I4_buf,I4);
buf b_I5 (I5_buf,I5);
buf b_I6 (I6_buf,I6);
buf b_I7 (I7_buf,I7);
buf b_S0 (S0_buf,S0);
buf b_S1 (S1_buf,S1);
buf b_S2 (S2_buf,S2);

`ifdef udp_input_ge_10
U_MUX_8_3 (Z,I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf);
`else
s_mx08d2 g1_s_mx08d2_1(I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf,Z);

`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam i0_lh_z_lh=0,i0_hl_z_hl_1=0,s0_lh_z_lh=0,s0_hl_z_hl=0,
 s1_lh_z_lh=0,s2_lh_z_lh=0,s2_hl_z_hl=0,i1_lh_z_lh=0,i1_hl_z_hl=0,
 i3_lh_z_lh=0,i3_hl_z_hl=0,i2_lh_z_lh=0,i2_hl_z_hl=0,i6_lh_z_lh=0,
 i6_hl_z_hl=0,i7_lh_z_lh=0,i7_hl_z_hl=0,s1_hl_z_hl_2=0,i5_lh_z_lh=0,
 i5_hl_z_hl=0,i4_lh_z_lh=0,i4_hl_z_hl=0;
// Delays
 (        S0  => Z) = (s0_lh_z_lh,s0_hl_z_hl);
 (        S1  => Z) = (s1_lh_z_lh,s1_hl_z_hl_2);
 (        S2  => Z) = (s2_lh_z_lh,s2_hl_z_hl);
 (        I0 +=> Z) = (i0_lh_z_lh,i0_hl_z_hl_1);
 (        I1 +=> Z) = (i1_lh_z_lh,i1_hl_z_hl);
 (        I3 +=> Z) = (i3_lh_z_lh,i3_hl_z_hl);
 (        I2 +=> Z) = (i2_lh_z_lh,i2_hl_z_hl);
 (        I6 +=> Z) = (i6_lh_z_lh,i6_hl_z_hl);
 (        I7 +=> Z) = (i7_lh_z_lh,i7_hl_z_hl);
 (        I5 +=> Z) = (i5_lh_z_lh,i5_hl_z_hl);
 (        I4 +=> Z) = (i4_lh_z_lh,i4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

`ifdef udp_input_ge_10
`else
module s_mx08d2 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output    Z;
input     I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;
reg       reg_Z,xreg_Z,flag_Z;
buf #0.01 (Z,reg_Z);

always @ (S2 or S1 or S0 or I7 or I6 or I5 or I4 or I3 or I2 or I1 or 
          I0) begin
 if ((S2===0) && (S1===0) && (S0===0)) reg_Z=I0;
 else if ((S2===0) && (S1===0) && (S0===1)) reg_Z=I1;
 else if ((S2===0) && (S1===1) && (S0===1)) reg_Z=I3;
 else if ((S2===0) && (S1===1) && (S0===0)) reg_Z=I2;
 else if ((S2===1) && (S1===1) && (S0===0)) reg_Z=I6;
 else if ((S2===1) && (S1===1) && (S0===1)) reg_Z=I7;
 else if ((S2===1) && (S1===0) && (S0===1)) reg_Z=I5;
 else if ((S2===1) && (S1===0) && (S0===0)) reg_Z=I4;
 else if ((S2===1'bx) || (S1===1'bx) || (S0===1'bx)) begin
  flag_Z=1;
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   xreg_Z=I0;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I1;
   else if (xreg_Z!==I1) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I3;
   else if (xreg_Z!==I3) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I2;
   else if (xreg_Z!==I2) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I6;
   else if (xreg_Z!==I6) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I7;
   else if (xreg_Z!==I7) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I5;
   else if (xreg_Z!==I5) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I4;
   else if (xreg_Z!==I4) xreg_Z=1'bx;
   flag_Z=0;
  end
  reg_Z=xreg_Z;
 end
end

endmodule
`endif
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: mx08d4.v
// Description  	:  8-to-1 Multiplexer, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module mx08d4 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output  Z;
input   I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;

wire I0_buf;
wire I1_buf;
wire I2_buf;
wire I3_buf;
wire I4_buf;
wire I5_buf;
wire I6_buf;
wire I7_buf;
wire S0_buf;
wire S1_buf;
wire S2_buf;

buf b_I0 (I0_buf,I0);
buf b_I1 (I1_buf,I1);
buf b_I2 (I2_buf,I2);
buf b_I3 (I3_buf,I3);
buf b_I4 (I4_buf,I4);
buf b_I5 (I5_buf,I5);
buf b_I6 (I6_buf,I6);
buf b_I7 (I7_buf,I7);
buf b_S0 (S0_buf,S0);
buf b_S1 (S1_buf,S1);
buf b_S2 (S2_buf,S2);

`ifdef udp_input_ge_10
U_MUX_8_3 (Z,I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf);
`else

s_mx08d4 g1_s_mx08d4_1(I0_buf,I1_buf,I2_buf,I3_buf,I4_buf,I5_buf,I6_buf,
                       I7_buf,S0_buf,S1_buf,S2_buf,Z);
                       
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam i0_lh_z_lh=0,i0_hl_z_hl_1=0,s0_lh_z_lh=0,s0_hl_z_hl=0,
 s1_lh_z_lh=0,s1_hl_z_hl_1=0,s2_lh_z_lh=0,s2_hl_z_hl=0,i1_lh_z_lh=0,
 i1_hl_z_hl=0,i3_lh_z_lh=0,i3_hl_z_hl=0,i2_lh_z_lh=0,i2_hl_z_hl=0,
 i6_lh_z_lh=0,i6_hl_z_hl=0,i7_lh_z_lh=0,i7_hl_z_hl=0,i5_lh_z_lh=0,
 i5_hl_z_hl=0,i4_lh_z_lh=0,i4_hl_z_hl=0;
// Delays
 (        S0  => Z) = (s0_lh_z_lh,s0_hl_z_hl);
 (        S1  => Z) = (s1_lh_z_lh,s1_hl_z_hl_1);
 (        S2  => Z) = (s2_lh_z_lh,s2_hl_z_hl);
 (        I0 +=> Z) = (i0_lh_z_lh,i0_hl_z_hl_1);
 (        I1 +=> Z) = (i1_lh_z_lh,i1_hl_z_hl);
 (        I3 +=> Z) = (i3_lh_z_lh,i3_hl_z_hl);
 (        I2 +=> Z) = (i2_lh_z_lh,i2_hl_z_hl);
 (        I6 +=> Z) = (i6_lh_z_lh,i6_hl_z_hl);
 (        I7 +=> Z) = (i7_lh_z_lh,i7_hl_z_hl);
 (        I5 +=> Z) = (i5_lh_z_lh,i5_hl_z_hl);
 (        I4 +=> Z) = (i4_lh_z_lh,i4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

`ifdef udp_input_ge_10
`else
module s_mx08d4 (I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2,Z);

output    Z;
input     I0,I1,I2,I3,I4,I5,I6,I7,S0,S1,S2;
reg       reg_Z,xreg_Z,flag_Z;
buf #0.01 (Z,reg_Z);

always @ (S2 or S1 or S0 or I7 or I6 or I5 or I4 or I3 or I2 or I1 or 
          I0) begin
 if ((S2===0) && (S1===0) && (S0===0)) reg_Z=I0;
 else if ((S2===0) && (S1===0) && (S0===1)) reg_Z=I1;
 else if ((S2===0) && (S1===1) && (S0===1)) reg_Z=I3;
 else if ((S2===0) && (S1===1) && (S0===0)) reg_Z=I2;
 else if ((S2===1) && (S1===1) && (S0===0)) reg_Z=I6;
 else if ((S2===1) && (S1===1) && (S0===1)) reg_Z=I7;
 else if ((S2===1) && (S1===0) && (S0===1)) reg_Z=I5;
 else if ((S2===1) && (S1===0) && (S0===0)) reg_Z=I4;
 else if ((S2===1'bx) || (S1===1'bx) || (S0===1'bx)) begin
  flag_Z=1;
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   xreg_Z=I0;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I1;
   else if (xreg_Z!==I1) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I3;
   else if (xreg_Z!==I3) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===0) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I2;
   else if (xreg_Z!==I2) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I6;
   else if (xreg_Z!==I6) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===1) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I7;
   else if (xreg_Z!==I7) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===1) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I5;
   else if (xreg_Z!==I5) xreg_Z=1'bx;
   flag_Z=0;
  end
  if (((S2===1) || (S2===1'bx)) && ((S1===0) || (S1===1'bx)) && 
          ((S0===0) || (S0===1'bx))) begin
   if (flag_Z) xreg_Z=I4;
   else if (xreg_Z!==I4) xreg_Z=1'bx;
   flag_Z=0;
  end
  reg_Z=xreg_Z;
 end
end

endmodule
`endif
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02d0.v
// Description          : 2-Input NAND, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd02d0 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02d1.v
// Description  	:  2-Input NAND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd02d1 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02d2.v
// Description  	:  2-Input NAND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd02d2 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02d4.v
// Description  	:  2-Input NAND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd02d4 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02d7.v
// Description  	:  2-Input NAND, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd02d7 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd02da.v
// Description          : 2-Input NAND, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd02da (A1,A2,ZN);

output  ZN;
input   A1,A2;

nand #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03d0.v
// Description          : 3-Input NAND, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd03d0 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03d1.v
// Description  	:  3-Input NAND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd03d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03d2.v
// Description  	:  3-Input NAND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd03d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03d4.v
// Description  	:  3-Input NAND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd03d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03d7.v
// Description  	:  3-Input NAND, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd03d7 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd03da.v
// Description          : 3-Input NAND, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd03da (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nand #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04d0.v
// Description          : 4-Input NAND, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd04d0 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04d1.v
// Description  	:  4-Input NAND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd04d1 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04d2.v
// Description  	:  4-Input NAND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd04d2 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04d4.v
// Description  	:  4-Input NAND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd04d4 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04d7.v
// Description  	:  4-Input NAND, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd04d7 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd04da.v
// Description          : 4-Input NAND, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd04da (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nand #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_hl_zn_lh=0,a2_lh_zn_hl=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0,a4_hl_zn_lh=0,a4_lh_zn_hl=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd12d0.v
// Description          : 2-Input NAND with one Input Inverted, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nd12d0 (A1,A2,ZN);

output  ZN;
input   A1,A2;

wire not_A2;

not (not_A2,A2);
or #1 (ZN,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd12d1.v
// Description  	: 2-Input NAND with one Input Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd12d1 (A1,A2,ZN);

output  ZN;
input   A1,A2;

wire not_A2;

not (not_A2,A2);
or #1 (ZN,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd12d2.v
// Description  	: 2-Input NAND with one Input Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd12d2 (A1,A2,ZN);

output  ZN;
input   A1,A2;

wire not_A2;

not (not_A2,A2);
or #1 (ZN,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd12d4.v
// Description  	: 2-Input NAND with one Input Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd12d4 (A1,A2,ZN);

output  ZN;
input   A1,A2;

wire not_A2;

not (not_A2,A2);
or #1 (ZN,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd13d1.v
// Description  	:  3-INPUT NAND with 1 Inverted Input, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd13d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
or #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd13d2.v
// Description  	:  3-INPUT NAND with 1 Inverted Input, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd13d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
or #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd13d4.v
// Description  	:  3-INPUT NAND with 1 Inverted Input, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd13d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
or #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a2_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_lh=0,
 a3_hl_zn_lh=0,a3_lh_zn_hl=0;
// Delays
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd23d1.v
// Description  	:  3-INPUT NAND with 2 Inverted Input, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd23d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
or #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a3_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_lh=0,
 a2_hl_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd23d2.v
// Description  	:  3-INPUT NAND with 2 Inverted Input, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd23d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
or #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a3_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_lh=0,
 a2_hl_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nd23d4.v
// Description  	:  3-INPUT NAND with 2 Inverted Input, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nd23d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
or #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a3_lh_zn_hl=0,a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_lh=0,
 a2_hl_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02d0.v
// Description          : 2-Input NOR, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr02d0 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02d1.v
// Description  	:  2-Input NOR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr02d1 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02d2.v
// Description  	:  2-Input NOR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr02d2 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02d4.v
// Description  	:  2-Input NOR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr02d4 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02d7.v
// Description  	:  2-Input NOR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr02d7 (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr02da.v
// Description          : 2-Input NOR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr02da (A1,A2,ZN);

output  ZN;
input   A1,A2;

nor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03d0.v
// Description          : 3-Input NOR, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr03d0 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03d1.v
// Description  	:  3-Input NOR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr03d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03d2.v
// Description  	:  3-Input NOR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr03d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03d4.v
// Description  	:  3-Input NOR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr03d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03d7.v
// Description  	:  3-Input NOR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr03d7 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr03da.v
// Description          : 3-Input NOR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr03da (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

nor #1 (ZN,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04d0.v
// Description          : 4-Input NOR, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr04d0 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04d1.v
// Description  	:  4-Input NOR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr04d1 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04d2.v
// Description  	:  4-Input NOR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr04d2 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04d4.v
// Description  	:  4-Input NOR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr04d4 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04d7.v
// Description  	:  4-Input NOR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr04d7 (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr04da.v
// Description          : 4-Input NOR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module nr04da (A1,A2,A3,A4,ZN);

output  ZN;
input   A1,A2,A3,A4;

nor #1 (ZN,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl=0,a1_hl_zn_lh=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0,a4_lh_zn_hl=0,a4_hl_zn_lh=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh,a1_lh_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
 (        A4 -=> ZN) = (a4_hl_zn_lh,a4_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr13d1.v
// Description  	:  3-Input NOR with 1 Inverted Input, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr13d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
and #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr13d2.v
// Description  	:  3-Input NOR with 1 Inverted Input, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr13d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
and #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr13d4.v
// Description  	:  3-Input NOR with 1 Inverted Input, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr13d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A2,not_A3;

not (not_A3,A3);
not (not_A2,A2);
and #1 (ZN,not_A3,not_A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_lh_zn_hl=0,a2_hl_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 -=> ZN) = (a2_hl_zn_lh,a2_lh_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr23d1.v
// Description  	:  3-Input NOR with 2 Inverted Input, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr23d1 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
and #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_hl=0,a2_lh_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr23d2.v
// Description  	:  3-Input NOR with 2 Inverted Input, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr23d2 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
and #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_hl=0,a2_lh_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: nr23d4.v
// Description  	:  3-Input NOR with 2 Inverted Input, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module nr23d4 (A1,A2,A3,ZN);

output  ZN;
input   A1,A2,A3;

wire not_A3;

not (not_A3,A3);
and #1 (ZN,not_A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_lh=0,a1_hl_zn_hl=0,a2_hl_zn_hl=0,a2_lh_zn_lh=0,
 a3_lh_zn_hl=0,a3_hl_zn_lh=0;
// Delays
 (        A1 +=> ZN) = (a1_lh_zn_lh,a1_hl_zn_hl);
 (        A2 +=> ZN) = (a2_lh_zn_lh,a2_hl_zn_hl);
 (        A3 -=> ZN) = (a3_hl_zn_lh,a3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai211d1.v
// Description  	:  2/1/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai211d1 (C1,C2,A,B,ZN);

output  ZN;
input   C1,C2,A,B;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C1);
and (g_2_out,B,A,C2);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b_hl_zn_lh_1=0,c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,
 a_hl_zn_lh_2=0,a_lh_zn_hl_2=0,b_lh_zn_hl_2=0,c2_hl_zn_lh=0;
// Delays
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_2);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai211d2.v
// Description  	:  2/1/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai211d2 (C1,C2,A,B,ZN);

output  ZN;
input   C1,C2,A,B;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C1);
and (g_2_out,B,A,C2);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 a_lh_zn_hl_2=0,b_hl_zn_lh_2=0,b_lh_zn_hl_2=0,c2_hl_zn_lh=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai211d4.v
// Description  	:  2/1/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai211d4 (C1,C2,A,B,ZN);

output  ZN;
input   C1,C2,A,B;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C1);
and (g_2_out,B,A,C2);
nor #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 a_lh_zn_hl_2=0,b_hl_zn_lh_2=0,b_lh_zn_hl_2=0,c2_hl_zn_lh=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai21d1.v
// Description  	:  2/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai21d1 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_2_out;

or (g_2_out,B1,B2);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 a_lh_zn_hl_2=0,b2_hl_zn_lh=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai21d2.v
// Description  	:  2/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai21d2 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_2_out;

or (g_2_out,B1,B2);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 a_lh_zn_hl_2=0,b2_hl_zn_lh=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai21d4.v
// Description  	:  2/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai21d4 (B1,B2,A,ZN);

output  ZN;
input   B1,B2,A;

wire g_2_out;

or (g_2_out,B1,B2);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 a_lh_zn_hl_2=0,b2_hl_zn_lh=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai221d1.v
// Description  	:  2/2/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai221d1 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_3_out,g_2_out;

or (g_2_out,C1,C2);
or (g_3_out,B2,B1);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,
 b2_lh_zn_hl_2=0,a_hl_zn_lh_5=0,a_lh_zn_hl_5=0,b2_hl_zn_lh_2=0,c2_hl_zn_lh_2=0,c2_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_5);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai221d2.v
// Description  	:  2/2/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai221d2 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_3_out,g_2_out;

or (g_2_out,C1,C2);
or (g_3_out,B2,B1);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,
 b2_lh_zn_hl_2=0,a_hl_zn_lh_5=0,a_lh_zn_hl_5=0,b2_hl_zn_lh_2=0,c2_hl_zn_lh_2=0,c2_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_5);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai221d4.v
// Description  	:  2/2/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai221d4 (C1,C2,B1,B2,A,ZN);

output  ZN;
input   C1,C2,B1,B2,A;

wire g_3_out,g_2_out;

or (g_2_out,C1,C2);
or (g_3_out,B2,B1);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,
 b2_lh_zn_hl_2=0,a_hl_zn_lh_5=0,a_lh_zn_hl_5=0,b2_hl_zn_lh_2=0,c2_hl_zn_lh_2=0,c2_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_5);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai2222d1.v
// Description  	:  2/2/2/2 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai2222d1 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_3_out,g_2_out,g_1_out,g_4_out;

or (g_1_out,D2,D1);
or (g_2_out,B2,B1);
or (g_3_out,A2,A1);
or (g_4_out,C2,C1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,
 a2_hl_zn_lh_2=0,b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0,a2_lh_zn_hl_8=0,d1_hl_zn_lh_10=0,
 d1_lh_zn_hl_10=0,c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,
 d2_hl_zn_lh_10=0,d2_lh_zn_hl_11=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_8);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
 (        D1 -=> ZN) = (d1_hl_zn_lh_10,d1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_11);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai2222d2.v
// Description  	:  2/2/2/2 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai2222d2 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_3_out,g_2_out,g_1_out,g_4_out;

or (g_1_out,D2,D1);
or (g_2_out,B2,B1);
or (g_3_out,A2,A1);
or (g_4_out,C2,C1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,a1_lh_zn_hl_2=0,a2_lh_zn_hl_2=0,
 b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0,a1_hl_zn_lh_8=0,d1_hl_zn_lh_10=0,d1_lh_zn_hl_10=0,
 c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,a2_hl_zn_lh_20=0,
 d2_hl_zn_lh_10=0,d2_lh_zn_hl_11=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_8,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_20,a2_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
 (        D1 -=> ZN) = (d1_hl_zn_lh_10,d1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_11);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai2222d4.v
// Description  	:  2/2/2/2 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai2222d4 (A1,A2,B1,B2,C1,C2,D1,D2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2,D1,D2;

wire g_3_out,g_2_out,g_1_out,g_4_out;

or (g_1_out,D2,D1);
or (g_2_out,B2,B1);
or (g_3_out,A2,A1);
or (g_4_out,C2,C1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out,g_4_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,
 a2_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0,d1_hl_zn_lh_10=0,
 d1_lh_zn_hl_10=0,c1_hl_zn_lh_10=0,c1_lh_zn_hl_10=0,c2_lh_zn_hl_10=0,c2_hl_zn_lh_10=0,
 d2_hl_zn_lh_10=0,d2_lh_zn_hl_11=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
 (        D1 -=> ZN) = (d1_hl_zn_lh_10,d1_lh_zn_hl_10);
 (        C1 -=> ZN) = (c1_hl_zn_lh_10,c1_lh_zn_hl_10);
 (        C2 -=> ZN) = (c2_hl_zn_lh_10,c2_lh_zn_hl_10);
 (        D2 -=> ZN) = (d2_hl_zn_lh_10,d2_lh_zn_hl_11);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai222d1.v
// Description  	:  2/2/2 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai222d1 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_3_out,g_2_out,g_1_out;

or (g_1_out,C2,C1);
or (g_2_out,A2,A1);
or (g_3_out,B2,B1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,b1_hl_zn_lh_5=0,b1_lh_zn_hl_5=0,
 a1_hl_zn_lh_5=0,a1_lh_zn_hl_5=0,a2_lh_zn_hl_5=0,a2_hl_zn_lh_5=0,b2_hl_zn_lh_5=0,
 b2_lh_zn_hl_6=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_5,b1_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_5,a1_lh_zn_hl_5);
 (        A2 -=> ZN) = (a2_hl_zn_lh_5,a2_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_5,b2_lh_zn_hl_6);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai222d2.v
// Description  	:  2/2/2 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai222d2 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_3_out,g_2_out,g_1_out;

or (g_1_out,C2,C1);
or (g_2_out,A2,A1);
or (g_3_out,B2,B1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,b1_hl_zn_lh_5=0,b1_lh_zn_hl_5=0,
 a1_hl_zn_lh_5=0,a1_lh_zn_hl_5=0,a2_lh_zn_hl_5=0,a2_hl_zn_lh_5=0,b2_hl_zn_lh_5=0,
 b2_lh_zn_hl_6=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_5,b1_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_5,a1_lh_zn_hl_5);
 (        A2 -=> ZN) = (a2_hl_zn_lh_5,a2_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_5,b2_lh_zn_hl_6);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai222d4.v
// Description  	:  2/2/2 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai222d4 (A1,A2,B1,B2,C1,C2,ZN);

output  ZN;
input   A1,A2,B1,B2,C1,C2;

wire g_3_out,g_2_out,g_1_out;

or (g_1_out,C2,C1);
or (g_2_out,A2,A1);
or (g_3_out,B2,B1);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,b1_hl_zn_lh_5=0,b1_lh_zn_hl_5=0,
 a1_hl_zn_lh_5=0,a1_lh_zn_hl_5=0,a2_lh_zn_hl_5=0,a2_hl_zn_lh_5=0,b2_hl_zn_lh_5=0,
 b2_lh_zn_hl_6=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_5,b1_lh_zn_hl_5);
 (        A1 -=> ZN) = (a1_hl_zn_lh_5,a1_lh_zn_hl_5);
 (        A2 -=> ZN) = (a2_hl_zn_lh_5,a2_lh_zn_hl_5);
 (        B2 -=> ZN) = (b2_hl_zn_lh_5,b2_lh_zn_hl_6);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai22d1.v
// Description  	:  2/2 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai22d1 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_2_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_lh_zn_hl_2=0,b1_hl_zn_lh_3=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,
 a2_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_3,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai22d2.v
// Description  	:  2/2 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai22d2 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_2_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,
 a2_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai22d4.v
// Description  	:  2/2 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai22d4 (A1,A2,B1,B2,ZN);

output  ZN;
input   A1,A2,B1,B2;

wire g_2_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh_2=0,b1_lh_zn_hl_2=0,a1_hl_zn_lh_2=0,a1_lh_zn_hl_2=0,
 a2_lh_zn_hl_2=0,a2_hl_zn_lh_2=0,b2_hl_zn_lh_2=0,b2_lh_zn_hl_3=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_2);
 (        A1 -=> ZN) = (a1_hl_zn_lh_2,a1_lh_zn_hl_2);
 (        A2 -=> ZN) = (a2_hl_zn_lh_2,a2_lh_zn_hl_2);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai311d1.v
// Description  	:  3/1/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai311d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
nand #1 (ZN,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,b_hl_zn_lh_2=0,
 c2_hl_zn_lh=0,c3_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,b_lh_zn_hl_4=0,c3_hl_zn_lh=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai311d2.v
// Description  	:  3/1/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai311d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
nand #1 (ZN,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,c2_hl_zn_lh=0,
 c3_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,b_hl_zn_lh_4=0,b_lh_zn_hl_4=0,c3_hl_zn_lh=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
 (        B  -=> ZN) = (b_hl_zn_lh_4,b_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai311d4.v
// Description  	:  3/1/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai311d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
nand #1 (ZN,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh=0,c1_lh_zn_hl=0,c2_lh_zn_hl=0,c2_hl_zn_lh=0,
 c3_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,b_hl_zn_lh_4=0,b_lh_zn_hl_4=0,c3_hl_zn_lh=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        C3 -=> ZN) = (c3_hl_zn_lh,c3_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
 (        B  -=> ZN) = (b_hl_zn_lh_4,b_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai31d1.v
// Description  	:  3/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai31d1 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_hl_zn_lh_1=0,b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,
 b2_hl_zn_lh=0,b3_lh_zn_hl=0,a_lh_zn_hl_4=0,b3_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_4);
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai31d2.v
// Description  	:  3/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai31d2 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,a_hl_zn_lh_2=0,
 b2_hl_zn_lh=0,b3_lh_zn_hl=0,a_lh_zn_hl_4=0,b3_hl_zn_lh=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_4);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai31d4.v
// Description  	:  3/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai31d4 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
nand #1 (ZN,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_zn_lh=0,b1_lh_zn_hl=0,b2_lh_zn_hl=0,b2_hl_zn_lh=0,
 b3_lh_zn_hl=0,a_hl_zn_lh_4=0,a_lh_zn_hl_4=0,b3_hl_zn_lh=0;
// Delays
 (        B1 -=> ZN) = (b1_hl_zn_lh,b1_lh_zn_hl);
 (        B2 -=> ZN) = (b2_hl_zn_lh,b2_lh_zn_hl);
 (        B3 -=> ZN) = (b3_hl_zn_lh,b3_lh_zn_hl);
 (        A  -=> ZN) = (a_hl_zn_lh_4,a_lh_zn_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai321d1.v
// Description  	:  3/2/1 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai321d1 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_2_out,g_3_out;

or (g_2_out,C3,C2,C1);
or (g_3_out,B1,B2);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,b1_hl_zn_lh_2=0,a_hl_zn_lh_5=0,
 b2_hl_zn_lh_2=0,c2_hl_zn_lh_2=0,c2_lh_zn_hl_3=0,b1_lh_zn_hl_4=0,b2_lh_zn_hl_4=0,
 a_lh_zn_hl_11=0,c3_hl_zn_lh_2=0,c3_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        B1 -=> ZN) = (b1_hl_zn_lh_2,b1_lh_zn_hl_4);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_2,b2_lh_zn_hl_4);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai321d2.v
// Description  	:  3/2/1 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai321d2 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_2_out,g_3_out;

or (g_2_out,C3,C2,C1);
or (g_3_out,B1,B2);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,a_hl_zn_lh_5=0,c2_hl_zn_lh_2=0,
 c2_lh_zn_hl_3=0,b1_hl_zn_lh_4=0,b1_lh_zn_hl_4=0,b2_lh_zn_hl_4=0,a_lh_zn_hl_11=0,
 b2_hl_zn_lh_4=0,c3_hl_zn_lh_2=0,c3_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_11);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_4);
 (        B2 -=> ZN) = (b2_hl_zn_lh_4,b2_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai321d4.v
// Description  	:  3/2/1 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai321d4 (C3,C2,C1,B2,B1,A,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A;

wire g_2_out,g_3_out;

or (g_2_out,C3,C2,C1);
or (g_3_out,B1,B2);
nand #1 (ZN,A,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_2=0,c1_lh_zn_hl_2=0,a_hl_zn_lh_5=0,c2_hl_zn_lh_2=0,
 c2_lh_zn_hl_3=0,b1_hl_zn_lh_4=0,b1_lh_zn_hl_4=0,b2_lh_zn_hl_4=0,a_lh_zn_hl_11=0,
 b2_hl_zn_lh_4=0,c3_hl_zn_lh_2=0,c3_lh_zn_hl_3=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_2,c1_lh_zn_hl_2);
 (        A  -=> ZN) = (a_hl_zn_lh_5,a_lh_zn_hl_11);
 (        C2 -=> ZN) = (c2_hl_zn_lh_2,c2_lh_zn_hl_3);
 (        B1 -=> ZN) = (b1_hl_zn_lh_4,b1_lh_zn_hl_4);
 (        B2 -=> ZN) = (b2_hl_zn_lh_4,b2_lh_zn_hl_4);
 (        C3 -=> ZN) = (c3_hl_zn_lh_2,c3_lh_zn_hl_3);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai322d1.v
// Description  	:  3/2/2 OR-AND-INVERT, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai322d1 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_2_out,g_3_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
or (g_3_out,C2,C1,C3);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,b1_hl_zn_lh_6=0,a1_hl_zn_lh_5=0,
 a2_hl_zn_lh_5=0,b2_hl_zn_lh_5=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0,b1_lh_zn_hl_11=0,
 a1_lh_zn_hl_11=0,a2_lh_zn_hl_11=0,b2_lh_zn_hl_12=0,c3_hl_zn_lh_5=0,c3_lh_zn_hl_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        B1 -=> ZN) = (b1_hl_zn_lh_6,b1_lh_zn_hl_11);
 (        A1 -=> ZN) = (a1_hl_zn_lh_5,a1_lh_zn_hl_11);
 (        A2 -=> ZN) = (a2_hl_zn_lh_5,a2_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_5,b2_lh_zn_hl_12);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
 (        C3 -=> ZN) = (c3_hl_zn_lh_5,c3_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai322d2.v
// Description  	:  3/2/2 OR-AND-INVERT, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai322d2 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_2_out,g_3_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
or (g_3_out,C2,C1,C3);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0,
 b1_hl_zn_lh_11=0,b1_lh_zn_hl_11=0,a1_hl_zn_lh_11=0,a1_lh_zn_hl_11=0,a2_lh_zn_hl_11=0,
 a2_hl_zn_lh_11=0,b2_hl_zn_lh_11=0,b2_lh_zn_hl_12=0,c3_lh_zn_hl_6=0,c3_hl_zn_lh_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
 (        B1 -=> ZN) = (b1_hl_zn_lh_11,b1_lh_zn_hl_11);
 (        A1 -=> ZN) = (a1_hl_zn_lh_11,a1_lh_zn_hl_11);
 (        A2 -=> ZN) = (a2_hl_zn_lh_11,a2_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_11,b2_lh_zn_hl_12);
 (        C3 -=> ZN) = (c3_hl_zn_lh_6,c3_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oai322d4.v
// Description  	:  3/2/2 OR-AND-INVERT, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oai322d4 (C3,C2,C1,B2,B1,A2,A1,ZN);

output  ZN;
input   C3,C2,C1,B2,B1,A2,A1;

wire g_2_out,g_3_out,g_1_out;

or (g_1_out,B2,B1);
or (g_2_out,A2,A1);
or (g_3_out,C2,C1,C3);
nand #1 (ZN,g_1_out,g_2_out,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_zn_lh_5=0,c1_lh_zn_hl_5=0,c2_hl_zn_lh_5=0,c2_lh_zn_hl_6=0,
 b1_hl_zn_lh_11=0,b1_lh_zn_hl_11=0,a1_hl_zn_lh_11=0,a1_lh_zn_hl_11=0,a2_lh_zn_hl_11=0,
 a2_hl_zn_lh_11=0,b2_hl_zn_lh_11=0,b2_lh_zn_hl_12=0,c3_lh_zn_hl_6=0,c3_hl_zn_lh_6=0;
// Delays
 (        C1 -=> ZN) = (c1_hl_zn_lh_5,c1_lh_zn_hl_5);
 (        C2 -=> ZN) = (c2_hl_zn_lh_5,c2_lh_zn_hl_6);
 (        B1 -=> ZN) = (b1_hl_zn_lh_11,b1_lh_zn_hl_11);
 (        A1 -=> ZN) = (a1_hl_zn_lh_11,a1_lh_zn_hl_11);
 (        A2 -=> ZN) = (a2_hl_zn_lh_11,a2_lh_zn_hl_11);
 (        B2 -=> ZN) = (b2_hl_zn_lh_11,b2_lh_zn_hl_12);
 (        C3 -=> ZN) = (c3_hl_zn_lh_6,c3_lh_zn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim211d1.v
// Description  	:  2/1/1 OR-AND-INVERT with C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim211d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf && A_buf && !C2_buf) || (B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim211d2.v
// Description  	:  2/1/1 OR-AND-INVERT with C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim211d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf && A_buf && !C2_buf) || (B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim211d4.v
// Description  	:  2/1/1 OR-AND-INVERT with C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim211d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((B_buf && A_buf && !C2_buf) || (B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim21d1.v
// Description  	:  2/1 OR-AND-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim21d1 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B1_buf && B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim21d2.v
// Description  	:  2/1 OR-AND-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim21d2 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B1_buf && B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim21d4.v
// Description  	:  2/1 OR-AND-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim21d4 (B2,B1,A,ZN);

output  ZN;
input   B2,B1,A;

wire A_buf,B1_buf,B2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B1_buf && B2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim22d1.v
// Description  	:  2/2 OR-AND-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim22d1 (B2,B1,A2,A1,ZN);

output  ZN;
input   B2,B1,A2,A1;

wire A1_buf,B1_buf,B2_buf,A2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire ZN_OUT = ((!A2_buf && !A1_buf) || (B2_buf && B1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl_1=0,a1_hl_zn_lh_1=0,a2_lh_zn_hl_1=0,a2_hl_zn_lh_1=0,
 b1_hl_zn_hl_1=0,b1_lh_zn_lh_2=0,b2_hl_zn_hl_2=0,b2_lh_zn_lh_3=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh_1,a1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_1,a2_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh_2,b1_hl_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh_3,b2_hl_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim22d2.v
// Description  	:  2/2 OR-AND-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim22d2 (B2,B1,A2,A1,ZN);

output  ZN;
input   B2,B1,A2,A1;

wire A1_buf,B1_buf,B2_buf,A2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire ZN_OUT = ((!A2_buf && !A1_buf) || (B2_buf && B1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl_1=0,a1_hl_zn_lh_1=0,a2_lh_zn_hl_1=0,a2_hl_zn_lh_1=0,
 b1_hl_zn_hl_1=0,b1_lh_zn_lh_2=0,b2_hl_zn_hl_2=0,b2_lh_zn_lh_2=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh_1,a1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_1,a2_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh_2,b1_hl_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh_2,b2_hl_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim22d4.v
// Description  	:  2/2 OR-AND-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim22d4 (B2,B1,A2,A1,ZN);

output  ZN;
input   B2,B1,A2,A1;

wire A1_buf,B1_buf,B2_buf,A2_buf;

buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A2_buf,A2);
buf (A1_buf,A1);

wire ZN_OUT = ((!A2_buf && !A1_buf) || (B2_buf && B1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_zn_hl_1=0,a1_hl_zn_lh_1=0,a2_lh_zn_hl_1=0,a2_hl_zn_lh_1=0,
 b1_hl_zn_hl_1=0,b1_lh_zn_lh_2=0,b2_hl_zn_hl_2=0,b2_lh_zn_lh_2=0;
// Delays
 (        A1 -=> ZN) = (a1_hl_zn_lh_1,a1_lh_zn_hl_1);
 (        A2 -=> ZN) = (a2_hl_zn_lh_1,a2_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh_2,b1_hl_zn_hl_1);
 (        B2 +=> ZN) = (b2_lh_zn_lh_2,b2_hl_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim2m11d1.v
// Description  	:  2/1/1 OR-AND-INVERT with B and C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim2m11d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf && A_buf && !C2_buf) || (!B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim2m11d2.v
// Description  	:  2/1/1 OR-AND-INVERT with B and C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim2m11d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf && A_buf && !C2_buf) || (!B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim2m11d4.v
// Description  	:  2/1/1 OR-AND-INVERT with B and C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim2m11d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf;

buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = !((!B_buf && A_buf && !C2_buf) || (!B_buf && A_buf && !C1_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c2_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim311d1.v
// Description  	:  3/1/1 OR-AND-INVERT with C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim311d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf) || (!A_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c3_hl_zn_hl=0,c3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim311d2.v
// Description  	:  3/1/1 OR-AND-INVERT with C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim311d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf) || (!A_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c3_hl_zn_hl=0,c3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim311d4.v
// Description  	:  3/1/1 OR-AND-INVERT with C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim311d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C2_buf,C1_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!B_buf) || (!A_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_hl_zn_lh_1=0,b_lh_zn_hl_1=0,
 c1_lh_zn_lh=0,c1_hl_zn_hl=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c3_hl_zn_hl=0,c3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  -=> ZN) = (b_hl_zn_lh_1,b_lh_zn_hl_1);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim31d1.v
// Description  	:  3/1 OR-AND-INVERT with B Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim31d1 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B2_buf && B1_buf && B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0,b3_hl_zn_hl=0,b3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim31d2.v
// Description  	:  3/1 OR-AND-INVERT with B Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim31d2 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B2_buf && B1_buf && B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0,b3_hl_zn_hl=0,b3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim31d4.v
// Description  	:  3/1 OR-AND-INVERT with B Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim31d4 (B3,B2,B1,A,ZN);

output  ZN;
input   B3,B2,B1,A;

wire A_buf,B1_buf,B2_buf,B3_buf;

buf (B3_buf,B3);
buf (B2_buf,B2);
buf (B1_buf,B1);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B2_buf && B1_buf && B3_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b1_lh_zn_lh=0,b1_hl_zn_hl=0,
 b2_hl_zn_hl=0,b2_lh_zn_lh=0,b3_hl_zn_hl=0,b3_lh_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B1 +=> ZN) = (b1_lh_zn_lh,b1_hl_zn_hl);
 (        B2 +=> ZN) = (b2_lh_zn_lh,b2_hl_zn_hl);
 (        B3 +=> ZN) = (b3_lh_zn_lh,b3_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim3m11d1.v
// Description  	:  3/1/1 OR-AND-INVERT with B and C Inputs Inverted, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim3m11d1 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c3_lh_zn_lh=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim3m11d2.v
// Description  	:  3/1/1 OR-AND-INVERT with B and C Inputs Inverted, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim3m11d2 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c3_lh_zn_lh=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oaim3m11d4.v
// Description  	:  3/1/1 OR-AND-INVERT with B and C Inputs Inverted, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oaim3m11d4 (C3,C2,C1,B,A,ZN);

output  ZN;
input   C3,C2,C1,B,A;

wire A_buf,B_buf,C1_buf,C2_buf,C3_buf;

buf (C3_buf,C3);
buf (C2_buf,C2);
buf (C1_buf,C1);
buf (B_buf,B);
buf (A_buf,A);

wire ZN_OUT = ((!A_buf) || (B_buf) || (C1_buf && C3_buf && C2_buf));

buf #1 (ZN,ZN_OUT);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_1=0,b_lh_zn_lh_1=0,b_hl_zn_hl_1=0,
 c3_lh_zn_lh=0,c2_hl_zn_hl=0,c2_lh_zn_lh=0,c1_hl_zn_hl=0,c1_lh_zn_lh=0,c3_hl_zn_hl=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_1,a_lh_zn_hl_1);
 (        B  +=> ZN) = (b_lh_zn_lh_1,b_hl_zn_hl_1);
 (        C3 +=> ZN) = (c3_lh_zn_lh,c3_hl_zn_hl);
 (        C2 +=> ZN) = (c2_lh_zn_lh,c2_hl_zn_hl);
 (        C1 +=> ZN) = (c1_lh_zn_lh,c1_hl_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oan211d1.v
// Description  	:  2/1/1 OR-AND-NOR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oan211d1 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A);
or (g_2_out,A,C2,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_2=0,c1_lh_zn_hl=0,b_lh_zn_hl_1=0,
 c1_hl_zn_lh=0,c2_lh_zn_hl=0,b_hl_zn_lh_2=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oan211d2.v
// Description  	:  2/1/1 OR-AND-NOR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module oan211d2 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A);
or (g_2_out,A,C2,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_2=0,a_hl_zn_lh_2=0,c1_lh_zn_hl=0,c1_hl_zn_lh=0,
 c2_lh_zn_hl=0,b_hl_zn_lh_2=0,b_lh_zn_hl_2=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_2);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: oan211d4.v
// Description          : 2/1/1 OR-AND-NOR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module oan211d4 (C2,C1,B,A,ZN);

output  ZN;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

or (g_1_out,B,A);
or (g_2_out,A,C2,C1);
nand #1 (ZN,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a_lh_zn_hl_1=0,a_hl_zn_lh_2=0,c1_lh_zn_hl=0,b_lh_zn_hl_1=0,
 c1_hl_zn_lh=0,c2_lh_zn_hl=0,b_hl_zn_lh_2=0,c2_hl_zn_lh=0;
// Delays
 (        A  -=> ZN) = (a_hl_zn_lh_2,a_lh_zn_hl_1);
 (        C1 -=> ZN) = (c1_hl_zn_lh,c1_lh_zn_hl);
 (        B  -=> ZN) = (b_hl_zn_lh_2,b_lh_zn_hl_1);
 (        C2 -=> ZN) = (c2_hl_zn_lh,c2_lh_zn_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02d0.v
// Description  	:  2-Input OR, Minimum Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or02d0 (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02d1.v
// Description  	:  2-Input OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or02d1 (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02d2.v
// Description  	:  2-Input OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or02d2 (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02d4.v
// Description  	:  2-Input OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or02d4 (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02d7.v
// Description  	:  2-Input OR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or02d7 (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or02da.v
// Description          : 2-Input OR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module or02da (A1,A2,Z);

output  Z;
input   A1,A2;

or #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03d0.v
// Description          : 3-Input OR, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module or03d0 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03d1.v
// Description  	:  3-Input OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or03d1 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03d2.v
// Description  	:  3-Input OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or03d2 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03d4.v
// Description  	:  3-Input OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or03d4 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03d7.v
// Description  	:  3-Input OR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or03d7 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or03da.v
// Description          : 3-Input OR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module or03da (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

or #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04d0.v
// Description          : 4-Input OR, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module or04d0 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04d1.v
// Description  	:  4-Input OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or04d1 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04d2.v
// Description  	:  4-Input OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or04d2 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04d4.v
// Description  	:  4-Input OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or04d4 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04d7.v
// Description  	:  4-Input OR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module or04d7 (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: or04da.v
// Description          : 4-Input OR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module or04da (A1,A2,A3,A4,Z);

output  Z;
input   A1,A2,A3,A4;

or #1 (Z,A4,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam a1_lh_z_lh=0,a1_hl_z_hl=0,a2_lh_z_lh=0,a2_hl_z_hl=0,
 a3_lh_z_lh=0,a3_hl_z_hl=0,a4_lh_z_lh=0,a4_hl_z_hl=0;
// Delays
 (        A1 +=> Z) = (a1_lh_z_lh,a1_hl_z_hl);
 (        A2 +=> Z) = (a2_lh_z_lh,a2_hl_z_hl);
 (        A3 +=> Z) = (a3_lh_z_lh,a3_hl_z_hl);
 (        A4 +=> Z) = (a4_lh_z_lh,a4_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora211d1.v
// Description  	:  2/1/1 OR-AND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora211d1 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C2);
and (g_2_out,B,A,C1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b_hl_z_hl_2=0,b_lh_z_lh_2=0,c2_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora211d2.v
// Description  	:  2/1/1 OR-AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora211d2 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C2);
and (g_2_out,B,A,C1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b_hl_z_hl_2=0,b_lh_z_lh_2=0,c2_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora211d4.v
// Description  	:  2/1/1 OR-AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora211d4 (C2,C1,B,A,Z);

output  Z;
input   C2,C1,B,A;

wire g_1_out,g_2_out;

and (g_1_out,B,A,C2);
and (g_2_out,B,A,C1);
or #1 (Z,g_1_out,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b_hl_z_hl_2=0,b_lh_z_lh_2=0,c2_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_2,b_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora21d1.v
// Description  	:  2/1 OR-AND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora21d1 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_2_out;

or (g_2_out,B1,B2);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b2_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora21d2.v
// Description  	:  2/1 OR-AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora21d2 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_2_out;

or (g_2_out,B1,B2);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b2_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora21d4.v
// Description  	:  2/1 OR-AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora21d4 (B2,B1,A,Z);

output  Z;
input   B2,B1,A;

wire g_2_out;

or (g_2_out,B1,B2);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,a_hl_z_hl_2=0,
 a_lh_z_lh_2=0,b2_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_2,a_hl_z_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora311d1.v
// Description  	:  3/1/1 OR-AND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora311d1 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
and #1 (Z,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 b_hl_z_hl_2=0,c2_hl_z_hl=0,c3_lh_z_lh=0,a_lh_z_lh_4=0,b_lh_z_lh_4=0,c3_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_4,b_hl_z_hl_2);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora311d2.v
// Description  	:  3/1/1 OR-AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora311d2 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
and #1 (Z,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 b_hl_z_hl_2=0,c2_hl_z_hl=0,c3_lh_z_lh=0,a_lh_z_lh_4=0,b_lh_z_lh_4=0,c3_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_4,b_hl_z_hl_2);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora311d4.v
// Description  	:  3/1/1 OR-AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora311d4 (C3,C2,C1,B,A,Z);

output  Z;
input   C3,C2,C1,B,A;

wire g_3_out;

or (g_3_out,C1,C3,C2);
and #1 (Z,B,A,g_3_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam c1_hl_z_hl=0,c1_lh_z_lh=0,c2_lh_z_lh=0,a_hl_z_hl_2=0,
 b_hl_z_hl_2=0,c2_hl_z_hl=0,c3_lh_z_lh=0,a_lh_z_lh_4=0,b_lh_z_lh_4=0,c3_hl_z_hl=0;
// Delays
 (        C1 +=> Z) = (c1_lh_z_lh,c1_hl_z_hl);
 (        C2 +=> Z) = (c2_lh_z_lh,c2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_2);
 (        B  +=> Z) = (b_lh_z_lh_4,b_hl_z_hl_2);
 (        C3 +=> Z) = (c3_lh_z_lh,c3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora31d1.v
// Description  	:  3/1 OR-AND, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora31d1 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,a_hl_z_hl_2=0,
 b2_hl_z_hl=0,b3_lh_z_lh=0,a_lh_z_lh_4=0,b3_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_2);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora31d2.v
// Description  	:  3/1 OR-AND, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora31d2 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,b2_hl_z_hl=0,
 b3_lh_z_lh=0,a_hl_z_hl_4=0,a_lh_z_lh_4=0,b3_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: ora31d4.v
// Description  	:  3/1 OR-AND, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module ora31d4 (B3,B2,B1,A,Z);

output  Z;
input   B3,B2,B1,A;

wire g_2_out;

or (g_2_out,B2,B1,B3);
and #1 (Z,A,g_2_out);

`ifdef functional
`else
specify
// Parameter declarations
 specparam b1_hl_z_hl=0,b1_lh_z_lh=0,b2_lh_z_lh=0,b2_hl_z_hl=0,
 b3_lh_z_lh=0,a_hl_z_hl_4=0,a_lh_z_lh_4=0,b3_hl_z_hl=0;
// Delays
 (        B1 +=> Z) = (b1_lh_z_lh,b1_hl_z_hl);
 (        B2 +=> Z) = (b2_lh_z_lh,b2_hl_z_hl);
 (        B3 +=> Z) = (b3_lh_z_lh,b3_hl_z_hl);
 (        A  +=> Z) = (a_lh_z_lh_4,a_hl_z_hl_4);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbfb1.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdbfb1 (D,SD,SC,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,mux_out,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,d_CPN,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif


`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.51,tsu_sc_l_cpn=0.42,
 tsu_d_h_cpn=0.33,tsu_d_l_cpn=0.41,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,
 th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.16,th_cpn_cdn_l=0.31,tpw_cpn_h=0.37,tpw_cpn_l=0.43,tpw_sdn_l=0.31,
 tpw_cdn_l=0.31,cdn_lh_q_lh_1=0,sdn_lh_qn_lh_8=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 cdn_hl_q_hl_8=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (vcond2==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (vcond2==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 (        SDN +=> QN) = (sdn_lh_qn_lh_8,sdn_hl_qn_hl_15);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbfb2.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdbfb2 (D,SD,SC,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,mux_out,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,d_CPN,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif


`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.51,tsu_sc_l_cpn=0.42,
 tsu_d_h_cpn=0.33,tsu_d_l_cpn=0.41,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,
 th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.16,th_cpn_cdn_l=0.31,tpw_cpn_h=0.37,tpw_cpn_l=0.43,tpw_sdn_l=0.31,
 tpw_cdn_l=0.31,cdn_lh_q_lh_1=0,sdn_lh_qn_lh_8=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 cdn_hl_q_hl_8=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (vcond2==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (vcond2==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 (        SDN +=> QN) = (sdn_lh_qn_lh_8,sdn_hl_qn_hl_15);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbfb4.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdbfb4 (D,SD,SC,CPN,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,CPN,CDN,SDN);
U_FD_N_RB_SB #1 (Q,mux_out,CPN,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,d_CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,d_CPN,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,CPN,not_CDN,not_SDN,notifier);
U_FD_N_RB_SB_NO #1 (Q,mux_out,CPN,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif


`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.51,tsu_sc_l_cpn=0.42,
 tsu_d_h_cpn=0.33,tsu_d_l_cpn=0.41,tsu_sdn_h_cpn=0.00,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,
 th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,
 th_cpn_sdn_l=0.16,th_cpn_cdn_l=0.31,tpw_cpn_h=0.37,tpw_cpn_l=0.43,tpw_sdn_l=0.31,
 tpw_cdn_l=0.31,cdn_lh_q_lh_1=0,sdn_lh_qn_lh_8=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 cdn_hl_q_hl_8=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge CPN &&& (vcond3==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sdn_h_cpn,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cpn_sdn_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (vcond2==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (vcond2==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 (        SDN +=> QN) = (sdn_lh_qn_lh_8,sdn_hl_qn_hl_15);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbrb1.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdbrb1 (D,SD,SC,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf,not_CP;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,mux_out,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif


`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.52,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.51,tsu_sc_l_cp=0.42,
 tsu_d_h_cp=0.33,tsu_d_l_cp=0.41,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.16,th_cp_cdn_l=0.31,tpw_cp_h=0.37,tpw_cp_l=0.43,tpw_sdn_l=0.31,
 tpw_cdn_l=0.31,cdn_lh_q_lh_1=0,sdn_lh_qn_lh_8=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 cdn_hl_q_hl_8=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 (        SDN +=> QN) = (sdn_lh_qn_lh_8,sdn_hl_qn_hl_15);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbrb2.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdbrb2 (D,SD,SC,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf,not_CP;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,mux_out,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.53,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.51,tsu_sc_l_cp=0.47,
 tsu_d_h_cp=0.34,tsu_d_l_cp=0.40,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.16,th_cp_cdn_l=0.30,tpw_cp_h=0.47,tpw_cp_l=0.43,tpw_sdn_l=0.42,
 tpw_cdn_l=0.40,sdn_lh_qn_lh_1=0,cdn_lh_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 cdn_hl_q_hl_8=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        SDN +=> QN) = (sdn_lh_qn_lh_1,sdn_hl_qn_hl_15);
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdbrb4.v
// Description  	:  Muxed Scan D Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdbrb4 (D,SD,SC,CP,SDN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN,CDN;

wire mux_out,not_CDN,not_SDN;
wire SC_buf,SDN_buf,CDN_buf,not_CP;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

`ifdef functional
U_FD_N_RB_SB_QN #1 (QN,mux_out,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,mux_out,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,d_CP,d_CDN,d_SDN,notifier);
`else
U_FD_N_R_S_NO_QN #1 (QN,mux_out,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,mux_out,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
not (not_CP,d_CP);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
not (not_CP,CP);
not (not_SDN,SDN);
not (not_CDN,CDN);
`endif
`endif


`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.52,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.51,tsu_sc_l_cp=0.42,
 tsu_d_h_cp=0.33,tsu_d_l_cp=0.41,tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,
 th_cp_sdn_l=0.16,th_cp_cdn_l=0.31,tpw_cp_h=0.37,tpw_cp_l=0.43,tpw_sdn_l=0.31,
 tpw_cdn_l=0.31,cdn_lh_q_lh_1=0,sdn_lh_qn_lh_8=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 cdn_hl_q_hl_8=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_qn_hl_15=0,sdn_hl_q_lh_7=0,cdn_hl_qn_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_1,cdn_hl_q_hl_8);
 (        SDN +=> QN) = (sdn_lh_qn_lh_8,sdn_hl_qn_hl_15);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_7,0);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfb1.v
// Description          : Buffered Muxed Scan D Flip-Flop with Clear, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module sdcfb1 (D,SD,SC,CPN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,CDN;
 
 wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.50,tsu_sc_l_cpn=0.46,
 tsu_d_h_cpn=0.28,tsu_d_l_cpn=0.42,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.33,
 tpw_cpn_h=0.30,tpw_cpn_l=0.42,tpw_cdn_l=0.30,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,
 cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (CDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfb2.v
// Description          : Buffered Muxed Scan D Flip-Flop with Clear, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module sdcfb2 (D,SD,SC,CPN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,CDN;
 
wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.50,tsu_sc_l_cpn=0.46,
 tsu_d_h_cpn=0.28,tsu_d_l_cpn=0.42,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.33,
 tpw_cpn_h=0.30,tpw_cpn_l=0.42,tpw_cdn_l=0.30,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,
 cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (CDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfb4.v
// Description          : Buffered Muxed Scan D Flip-Flop with Clear, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module sdcfb4 (D,SD,SC,CPN,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,CDN;

wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_CDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (buf_Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (buf_Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (buf_Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.60,tsu_sc_h_cpn=0.50,tsu_sc_l_cpn=0.46,
 tsu_d_h_cpn=0.28,tsu_d_l_cpn=0.42,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.33,
 tpw_cpn_h=0.30,tpw_cpn_l=0.42,tpw_cdn_l=0.30,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,
 cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (CDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfq1.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcfq1 (CPN,CDN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.44,tsu_sd_l_cpn=0.59,tsu_sc_h_cpn=0.48,tsu_sc_l_cpn=0.43,
 tsu_d_h_cpn=0.24,tsu_d_l_cpn=0.42,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.36,
 tpw_cpn_l=0.31,tpw_cpn_h=0.33,tpw_cdn_l=0.18,cpn_hl_q_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfq2.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcfq2 (CPN,CDN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.44,tsu_sd_l_cpn=0.59,tsu_sc_h_cpn=0.48,tsu_sc_l_cpn=0.43,
 tsu_d_h_cpn=0.25,tsu_d_l_cpn=0.41,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.35,
 tpw_cpn_l=0.33,tpw_cpn_h=0.34,tpw_cdn_l=0.18,cpn_hl_q_lh_1=0,cdn_hl_q_hl_1=0,cpn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcfq4.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcfq4 (CPN,CDN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_RB #1 (Q,mux_out,CPN_not,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_RB_NO #1 (Q,mux_out,d_CPN,d_CDN,notifier);
`else
U_FD_N_RB_NO #1 (Q,mux_out,CPN,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.44,tsu_sd_l_cpn=0.59,tsu_sc_h_cpn=0.48,tsu_sc_l_cpn=0.43,
 tsu_d_h_cpn=0.24,tsu_d_l_cpn=0.42,tsu_cdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.36,
 tpw_cpn_l=0.31,tpw_cpn_h=0.33,tpw_cdn_l=0.18,cpn_hl_q_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN,th_cpn_cdn_l,notifier);
`endif
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (negedge CPN  => (Q +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_2);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrb1.v
// Description  	: Muxed Scan D Flip-Flop with Clear, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrb1 (D,SD,SC,CP,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,CDN;
 
 wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.50,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.28,tsu_d_l_cp=0.42,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.33,
 tpw_cp_h=0.30,tpw_cp_l=0.42,tpw_cdn_l=0.30,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,
 cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrb2.v
// Description  	: Muxed Scan D Flip-Flop with Clear, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdcrb2 (D,SD,SC,CP,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,CDN;
 
 wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.50,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.28,tsu_d_l_cp=0.42,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.33,
 tpw_cp_h=0.30,tpw_cp_l=0.42,tpw_cdn_l=0.30,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,
 cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrb4.v
// Description  	: Muxed Scan D Flip-Flop with Clear, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrb4 (D,SD,SC,CP,CDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,CDN;
 
 wire buf_Q,mux_out,SC_buf,CDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_CDN;
`endif

`ifdef functional
U_FD_P_RB #1 (buf_Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (buf_Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (buf_Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.60,tsu_sc_h_cp=0.50,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.28,tsu_d_l_cp=0.42,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.33,
 tpw_cp_h=0.30,tpw_cp_l=0.42,tpw_cdn_l=0.30,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,
 cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0,cdn_hl_qn_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (CDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q  -: 1'b1)) = (0,cdn_hl_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////
`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrn1.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrn1 (CP,CDN,D,SC,SD,QN);

output  QN;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif

wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.59,tsu_sc_h_cp=0.48,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.30,tsu_d_l_cp=0.41,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.30,
 tpw_cp_h=0.27,tpw_cp_l=0.42,tpw_cdn_l=0.28,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0,cdn_hl_qn_lh_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_3,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrn2.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrn2 (CP,CDN,D,SC,SD,QN);

output  QN;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.59,tsu_sc_h_cp=0.50,tsu_sc_l_cp=0.48,
 tsu_d_h_cp=0.30,tsu_d_l_cp=0.42,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.28,
 tpw_cp_h=0.30,tpw_cp_l=0.43,tpw_cdn_l=0.33,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0,cdn_hl_qn_lh_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_3,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrn4.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrn4 (CP,CDN,D,SC,SD,QN);

output  QN;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (QN_not,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (QN_not,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (QN_not,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif

wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.59,tsu_sc_h_cp=0.48,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.30,tsu_d_l_cp=0.41,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.30,
 tpw_cp_h=0.27,tpw_cp_l=0.42,tpw_cdn_l=0.28,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0,cdn_hl_qn_lh_3=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_3,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
`timescale 1ns / 1ps

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrq1.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrq1 (CP,CDN,D,SC,SD,Q);

output  Q;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif

wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.30,tsu_d_l_cp=0.39,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.32,
 tpw_cp_h=0.26,tpw_cp_l=0.40,tpw_cdn_l=0.22,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrq2.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrq2 (CP,CDN,D,SC,SD,Q);

output  Q;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif

wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.31,tsu_d_l_cp=0.40,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.32,
 tpw_cp_h=0.29,tpw_cp_l=0.40,tpw_cdn_l=0.28,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdcrq4.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdcrq4 (CP,CDN,D,SC,SD,Q);

output  Q;
input   CP,CDN,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_CDN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P_RB #1 (Q,mux_out,CP,CDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_RB_NO #1 (Q,mux_out,d_CP,d_CDN,notifier);
`else
U_FD_P_RB_NO #1 (Q,mux_out,CP,CDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif

wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.30,tsu_d_l_cp=0.39,tsu_cdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.32,
 tpw_cp_h=0.26,tpw_cp_l=0.40,tpw_cdn_l=0.22,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 if (CDN==1'b1)
 (posedge CP   => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnfb1.v
// Description  	:  Muxed Scan D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdnfb1 (D,SD,SC,CPN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,mux_out,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,mux_out,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,mux_out,CPN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.56,tsu_sc_h_cpn=0.46,tsu_sc_l_cpn=0.40,
 tsu_d_h_cpn=0.27,tsu_d_l_cpn=0.36,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,
 th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,tpw_cpn_h=0.27,tpw_cpn_l=0.38,
 cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN,posedge SC,tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN,negedge SC,tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC,negedge CPN,tsu_sc_h_cpn,notifier);
 $setup (negedge SC,negedge CPN,tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_l_cpn,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN,negedge SC,th_cpn_sc_h,notifier);
 $hold  (negedge CPN,posedge SC,th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cpn_d_l,notifier);
`endif
 $width (posedge CPN,tpw_cpn_h,0,notifier);
 $width (negedge CPN,tpw_cpn_l,0,notifier);
// Delays
 (negedge CPN  => (QN -: ((SD && SC) || (D && ~SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 (negedge CPN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnfb2.v
// Description  	:  Muxed Scan D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdnfb2 (D,SD,SC,CPN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,mux_out,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,mux_out,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,mux_out,CPN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.56,tsu_sc_h_cpn=0.46,tsu_sc_l_cpn=0.40,
 tsu_d_h_cpn=0.27,tsu_d_l_cpn=0.36,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,
 th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,tpw_cpn_h=0.27,tpw_cpn_l=0.38,
 cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN,posedge SC,tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN,negedge SC,tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC,negedge CPN,tsu_sc_h_cpn,notifier);
 $setup (negedge SC,negedge CPN,tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_l_cpn,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN,negedge SC,th_cpn_sc_h,notifier);
 $hold  (negedge CPN,posedge SC,th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cpn_d_l,notifier);
`endif
 $width (posedge CPN,tpw_cpn_h,0,notifier);
 $width (negedge CPN,tpw_cpn_l,0,notifier);
// Delays
 (negedge CPN  => (QN -: ((SD && SC) || (D && ~SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 (negedge CPN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnfb4.v
// Description  	:  Muxed Scan D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdnfb4 (D,SD,SC,CPN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN;
`endif

`ifdef functional
U_FD_N #1 (buf_Q,mux_out,CPN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_NO #1 (buf_Q,mux_out,d_CPN,notifier);
`else
U_FD_N_NO #1 (buf_Q,mux_out,CPN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.47,tsu_sd_l_cpn=0.56,tsu_sc_h_cpn=0.46,tsu_sc_l_cpn=0.40,
 tsu_d_h_cpn=0.27,tsu_d_l_cpn=0.36,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,
 th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,tpw_cpn_h=0.27,tpw_cpn_l=0.38,
 cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN,posedge SC,tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN,negedge SC,tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge CPN &&& (SC==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC,negedge CPN,tsu_sc_h_cpn,notifier);
 $setup (negedge SC,negedge CPN,tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge CPN &&& (SC==1'b0),tsu_d_l_cpn,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN,negedge SC,th_cpn_sc_h,notifier);
 $hold  (negedge CPN,posedge SC,th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cpn_d_l,notifier);
`endif
 $width (posedge CPN,tpw_cpn_h,0,notifier);
 $width (negedge CPN,tpw_cpn_l,0,notifier);
// Delays
 (negedge CPN  => (QN -: ((SD && SC) || (D && ~SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 (negedge CPN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrb1.v
// Description  	:  Muxed Scan D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrb1 (D,SD,SC,CP,Q,QN);

output  Q,QN;
input   D,SD,SC,CP;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.56,tsu_sc_h_cp=0.46,tsu_sc_l_cp=0.40,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.36,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.27,tpw_cp_l=0.38,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (posedge CP  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrb2.v
// Description  	:  Muxed Scan D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrb2 (D,SD,SC,CP,Q,QN);

output  Q,QN;
input   D,SD,SC,CP;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.46,tsu_sd_l_cp=0.56,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.40,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.37,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.36,tpw_cp_l=0.39,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (posedge CP  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrb4.v
// Description  	:  Muxed Scan D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrb4 (D,SD,SC,CP,Q,QN);

output  Q,QN;
input   D,SD,SC,CP;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP;
`endif

`ifdef functional
U_FD_P #1 (buf_Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (buf_Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (buf_Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.56,tsu_sc_h_cp=0.46,tsu_sc_l_cp=0.40,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.36,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.27,tpw_cp_l=0.38,
 cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 (posedge CP  => (Q  +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrn1.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrn1 (CP,D,SC,SD,QN);

output  QN;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (QN_not,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.46,tsu_sd_l_cp=0.56,tsu_sc_h_cp=0.46,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.38,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.24,tpw_cp_l=0.38,
 cp_lh_qn_lh_1=0,cp_lh_qn_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrn2.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrn2 (CP,D,SC,SD,QN);

output  QN;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (QN_not,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.45,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.45,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.38,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.28,tpw_cp_l=0.39,
 cp_lh_qn_lh_1=0,cp_lh_qn_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrn4.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrn4 (CP,D,SC,SD,QN);

output  QN;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (QN_not,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (QN_not,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (QN_not,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

not (QN,QN_not);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.46,tsu_sd_l_cp=0.56,tsu_sc_h_cp=0.46,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.38,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.24,tpw_cp_l=0.38,
 cp_lh_qn_lh_1=0,cp_lh_qn_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (QN -: ((SD && SC) || (D && ~SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrq1.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrq1 (CP,D,SC,SD,Q);

output  Q;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.54,tsu_sc_h_cp=0.44,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.28,tsu_d_l_cp=0.36,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.26,tpw_cp_l=0.33,
 cp_lh_q_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrq2.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrq2 (CP,D,SC,SD,Q);

output  Q;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.46,tsu_sd_l_cp=0.55,tsu_sc_h_cp=0.44,tsu_sc_l_cp=0.45,
 tsu_d_h_cp=0.27,tsu_d_l_cp=0.36,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.28,tpw_cp_l=0.34,
 cp_lh_q_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdnrq4.v
// Description  	:  Buffered Muxed Scan D Flip-Flop with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdnrq4 (CP,D,SC,SD,Q);

output  Q;
input   CP,D,SC,SD;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not;

`ifdef neg_tchk
wire d_CP,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_P #1 (Q,mux_out,CP);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_NO #1 (Q,mux_out,d_CP,notifier);
`else
U_FD_P_NO #1 (Q,mux_out,CP,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.47,tsu_sd_l_cp=0.54,tsu_sc_h_cp=0.44,tsu_sc_l_cp=0.46,
 tsu_d_h_cp=0.28,tsu_d_l_cp=0.36,th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,
 th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.26,tpw_cp_l=0.33,
 cp_lh_q_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge CP &&& (SC==1'b0),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: ((SD && SC) || (D && ~SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdpfb1.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdpfb1 (D,SD,SC,CPN,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,mux_out,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,mux_out,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,mux_out,CPN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.50,tsu_sd_l_cpn=0.57,tsu_sc_h_cpn=0.47,tsu_sc_l_cpn=0.50,
 tsu_d_h_cpn=0.31,tsu_d_l_cpn=0.40,tsu_sdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.20,
 tpw_cpn_h=0.31,tpw_cpn_l=0.41,tpw_sdn_l=0.37,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 sdn_hl_qn_hl_1=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (SDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdpfb2.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdpfb2 (D,SD,SC,CPN,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,mux_out,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,mux_out,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,mux_out,CPN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.50,tsu_sd_l_cpn=0.57,tsu_sc_h_cpn=0.47,tsu_sc_l_cpn=0.50,
 tsu_d_h_cpn=0.31,tsu_d_l_cpn=0.40,tsu_sdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.20,
 tpw_cpn_h=0.31,tpw_cpn_l=0.41,tpw_sdn_l=0.37,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 sdn_hl_qn_hl_1=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (SDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdpfb4.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//


module sdpfb4 (D,SD,SC,CPN,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CPN,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CPN,d_SDN;
`endif

`ifdef functional
not (CPN_not,CPN);
U_FD_P_SB #1 (buf_Q,mux_out,CPN_not,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_N_SB_NO #1 (buf_Q,mux_out,d_CPN,d_SDN,notifier);
`else
U_FD_N_SB_NO #1 (buf_Q,mux_out,CPN,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.50,tsu_sd_l_cpn=0.57,tsu_sc_h_cpn=0.47,tsu_sc_l_cpn=0.50,
 tsu_d_h_cpn=0.31,tsu_d_l_cpn=0.40,tsu_sdn_h_cpn=0.00,th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,
 th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.20,
 tpw_cpn_h=0.31,tpw_cpn_l=0.41,tpw_sdn_l=0.37,cpn_hl_qn_lh_1=0,cpn_hl_q_hl_1=0,
 sdn_hl_qn_hl_1=0,cpn_hl_qn_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (negedge CPN   => (QN -: ((D && ~SC) || (SD && SC)))) = (cpn_hl_qn_lh_1,cpn_hl_qn_hl_1);
 if (SDN==1'b1)
 (negedge CPN   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdprb1.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdprb1 (D,SD,SC,CP,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,mux_out,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,mux_out,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,mux_out,CP,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.50,
 tsu_d_h_cp=0.31,tsu_d_l_cp=0.40,tsu_sdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.20,
 tpw_cp_h=0.31,tpw_cp_l=0.41,tpw_sdn_l=0.37,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 sdn_hl_qn_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdprb2.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdprb2 (D,SD,SC,CP,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,mux_out,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,mux_out,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,mux_out,CP,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.49,tsu_sd_l_cp=0.58,tsu_sc_h_cp=0.48,tsu_sc_l_cp=0.49,
 tsu_d_h_cp=0.31,tsu_d_l_cp=0.40,tsu_sdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.19,
 tpw_cp_h=0.41,tpw_cp_l=0.41,tpw_sdn_l=0.53,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 sdn_hl_q_lh_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_qn_hl_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_6);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sdprb4.v
// Description  	:  Muxed Scan D Flip-Flop with Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
//
//


module sdprb4 (D,SD,SC,CP,SDN,Q,QN);

output  Q,QN;
input   D,SD,SC,CP,SDN;

wire buf_Q,mux_out,SC_buf,CDN_buf,QN_not,SDN_buf;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_CP,d_SDN;
`endif

`ifdef functional
U_FD_P_SB #1 (buf_Q,mux_out,CP,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_FD_P_SB_NO #1 (buf_Q,mux_out,d_CP,d_SDN,notifier);
`else
U_FD_P_SB_NO #1 (buf_Q,mux_out,CP,SDN,notifier);
`endif
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
`else
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (SDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.57,tsu_sc_h_cp=0.47,tsu_sc_l_cp=0.50,
 tsu_d_h_cp=0.31,tsu_d_l_cp=0.40,tsu_sdn_h_cp=0.00,th_cp_sd_h=0.00,th_cp_sd_l=0.00,
 th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.20,
 tpw_cp_h=0.31,tpw_cp_l=0.41,tpw_sdn_l=0.37,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,
 sdn_hl_qn_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_q_lh_6=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 if (SDN==1'b1)
 (posedge CP   => (QN -: ((D && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if (SDN==1'b1)
 (posedge CP   => (Q  +: ((D && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (QN -: 1'b1)) = (0,sdn_hl_qn_hl_1);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_6,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secfq1.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module secfq1 (CPN,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_RB #1 (Q,not_CPN,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.53,tsu_sd_l_cpn=0.66,tsu_sc_h_cpn=0.68,tsu_sc_l_cpn=0.77,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.75,tsu_d_h_cpn=0.39,tsu_d_l_cpn=0.53,tsu_cdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.22,tpw_cpn_h=0.21,
 tpw_cpn_l=0.42,tpw_cdn_l=0.16,cpn_hl_q_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (negedge CPN   => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secfq2.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module secfq2 (CPN,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_RB #1 (Q,not_CPN,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.53,tsu_sd_l_cpn=0.66,tsu_sc_h_cpn=0.68,tsu_sc_l_cpn=0.77,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.75,tsu_d_h_cpn=0.39,tsu_d_l_cpn=0.53,tsu_cdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.22,tpw_cpn_h=0.21,
 tpw_cpn_l=0.42,tpw_cdn_l=0.16,cpn_hl_q_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (negedge CPN   => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secfq4.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module secfq4 (CPN,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CPN,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_RB #1 (Q,not_CPN,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_RB_NO #1 (Q,not_CPN,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.53,tsu_sd_l_cpn=0.66,tsu_sc_h_cpn=0.68,tsu_sc_l_cpn=0.77,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.75,tsu_d_h_cpn=0.39,tsu_d_l_cpn=0.53,tsu_cdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_cdn_l=0.22,tpw_cpn_h=0.21,
 tpw_cpn_l=0.42,tpw_cdn_l=0.16,cpn_hl_q_lh_1=0,cpn_hl_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,th_cpn_cdn_l,notifier,,,d_CDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge CPN &&& (CDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (CDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,negedge CPN,tsu_cdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cpn_cdn_l,notifier);
`endif
 $width (posedge CPN &&& (CDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (CDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (negedge CPN   => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secrq1.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module secrq1 (CP,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CP,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_RB #1 (Q,CP,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_RB_NO #1 (Q,CP,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.53,tsu_sd_l_cp=0.66,tsu_sc_h_cp=0.68,tsu_sc_l_cp=0.77,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.75,tsu_d_h_cp=0.39,tsu_d_l_cp=0.53,tsu_cdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.22,tpw_cp_h=0.21,
 tpw_cp_l=0.42,tpw_cdn_l=0.16,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (posedge CP   => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secrq2.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module secrq2 (CP,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CP,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_RB #1 (Q,CP,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_RB_NO #1 (Q,CP,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.53,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.77,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.74,tsu_d_h_cp=0.39,tsu_d_l_cp=0.52,tsu_cdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.22,tpw_cp_h=0.24,
 tpw_cp_l=0.42,tpw_cdn_l=0.20,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (posedge CP   => (Q +: D) ) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: secrq4.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module secrq4 (CP,CDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,CDN,ENN,D,SC,SD;

wire not_CDN,CDN_buf,SC_buf,ENN_buf,not_CPN;

`ifdef neg_tchk
wire d_CP,d_CDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_RB #1 (Q,CP,ENN,SC,CDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_RB_NO #1 (Q,d_CP,d_ENN,d_SC,d_CDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_RB_NO #1 (Q,CP,ENN,SC,CDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (CDN_buf,CDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((CDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_CDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((CDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((CDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.53,tsu_sd_l_cp=0.66,tsu_sc_h_cp=0.68,tsu_sc_l_cp=0.77,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.75,tsu_d_h_cp=0.39,tsu_d_l_cp=0.53,tsu_cdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_cdn_l=0.22,tpw_cp_h=0.21,
 tpw_cp_l=0.42,tpw_cdn_l=0.16,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cdn_hl_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (CDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge CDN &&& (vcond_CDN_vio==1'b1) ,posedge CP,tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge CDN &&& (vcond_CDN_vio==1'b1) ,th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (CDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (CDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
// Delays
 (posedge CP   => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (Q -: 1'b1)) = (0,cdn_hl_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrb1.v
// Description  	:  Muxed Scan Enable D Flip-Flop, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module senrb1 (CP,ENN,D,SC,SD,Q,QN);

output  Q,QN;
input   CP,ENN,D,SC,SD;

wire buf_Q,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (buf_Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (buf_Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.35,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.20,tpw_cp_l=0.40,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0;
// Violation constraints
 `ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
$setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (posedge CP  => (QN +: D)) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrb2.v
// Description  	:  Muxed Scan Enable D Flip-Flop, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module senrb2 (CP,ENN,D,SC,SD,Q,QN);

output  Q,QN;
input   CP,ENN,D,SC,SD;

wire buf_Q,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (buf_Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (buf_Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.35,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.20,tpw_cp_l=0.40,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0;
// Violation constraints
 `ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
$setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (posedge CP  => (QN +: D)) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrb4.v
// Description  	:  Muxed Scan Enable D Flip-Flop, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module senrb4 (CP,ENN,D,SC,SD,Q,QN);

output  Q,QN;
input   CP,ENN,D,SC,SD;

wire buf_Q,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (buf_Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (buf_Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (buf_Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.35,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.20,tpw_cp_l=0.40,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_qn_lh_1=0;
// Violation constraints
 `ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
$setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (posedge CP  => (QN +: D)) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrq1.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module senrq1 (CP,ENN,D,SC,SD,Q);

output  Q;
input   CP,ENN,D,SC,SD;

wire SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.35,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.20,tpw_cp_l=0.40,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
 `ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
$setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrq2.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module senrq2 (CP,ENN,D,SC,SD,Q);

output  Q;
input   CP,ENN,D,SC,SD;

wire SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.34,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.21,tpw_cp_l=0.41,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: senrq4.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module senrq4 (CP,ENN,D,SC,SD,Q);

output  Q;
input   CP,ENN,D,SC,SD;

wire SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P #1 (Q,CP,ENN,SC,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_NO #1 (Q,d_CP,d_ENN,d_SC,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_NO #1 (Q,CP,ENN,SC,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif

wire vcond1 = ((SC_buf==1'b0) && (ENN_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.50,tsu_sd_l_cp=0.65,tsu_sc_h_cp=0.67,tsu_sc_l_cp=0.74,
 tsu_enn_h_cp=0.46,tsu_enn_l_cp=0.76,tsu_d_h_cp=0.35,tsu_d_l_cp=0.52,th_cp_sd_h=0.00,
 th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,th_cp_enn_l=0.00,
 th_cp_d_h=0.00,th_cp_d_l=0.00,tpw_cp_h=0.20,tpw_cp_l=0.40,cp_lh_q_lh_1=0,cp_lh_q_hl_1=0;
// Violation constraints
 `ifdef neg_tchk
 $setuphold (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP,posedge SC,tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,negedge SC,tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP,posedge ENN &&& (SC==1'b0),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP,negedge ENN &&& (SC==1'b0),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
`else
$setup (posedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge CP &&& (SC==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC,posedge CP,tsu_sc_h_cp,notifier);
 $setup (negedge SC,posedge CP,tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (SC==1'b0),posedge CP,tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_d_l_cp,notifier);
 $hold  (posedge CP &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP,negedge SC,th_cp_sc_h,notifier);
 $hold  (posedge CP,posedge SC,th_cp_sc_l,notifier);
 $hold  (posedge CP,negedge ENN &&& (SC==1'b0),th_cp_enn_h,notifier);
 $hold  (posedge CP,posedge ENN &&& (SC==1'b0),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge D &&& (vcond1==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge D &&& (vcond1==1'b1),th_cp_d_l,notifier);
`endif
 $width (posedge CP,tpw_cp_h,0,notifier);
 $width (negedge CP,tpw_cp_l,0,notifier);
// Delays
 (posedge CP  => (Q +: D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sepfq1.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module sepfq1 (CPN,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_SB #1 (Q,not_CPN,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.70,tsu_sc_h_cpn=0.72,tsu_sc_l_cpn=0.76,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.80,tsu_d_h_cpn=0.37,tsu_d_l_cpn=0.57,tsu_sdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.07,tpw_cpn_h=0.23,
 tpw_cpn_l=0.43,tpw_sdn_l=0.40,cpn_hl_q_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_7=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (negedge CPN   => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_7,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sepfq2.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module sepfq2 (CPN,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_SB #1 (Q,not_CPN,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.70,tsu_sc_h_cpn=0.72,tsu_sc_l_cpn=0.76,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.80,tsu_d_h_cpn=0.37,tsu_d_l_cpn=0.57,tsu_sdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.07,tpw_cpn_h=0.23,
 tpw_cpn_l=0.43,tpw_sdn_l=0.40,cpn_hl_q_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_7=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (negedge CPN  => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_7,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: sepfq4.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
// Added negedge to CPN 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module sepfq4 (CPN,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CPN,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CPN,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
not (not_CPN,CPN);
U_FD_SC_EN_P_SB #1 (Q,not_CPN,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
not (not_CPN,d_CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
not (not_CPN,CPN);
U_FD_SC_EN_P_SB_NO #1 (Q,not_CPN,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cpn=0.52,tsu_sd_l_cpn=0.70,tsu_sc_h_cpn=0.72,tsu_sc_l_cpn=0.76,
 tsu_enn_h_cpn=0.52,tsu_enn_l_cpn=0.80,tsu_d_h_cpn=0.37,tsu_d_l_cpn=0.57,tsu_sdn_h_cpn=0.00,
 th_cpn_sd_h=0.00,th_cpn_sd_l=0.00,th_cpn_sc_h=0.00,th_cpn_sc_l=0.00,th_cpn_enn_h=0.00,
 th_cpn_enn_l=0.00,th_cpn_d_h=0.00,th_cpn_d_l=0.00,th_cpn_sdn_l=0.07,tpw_cpn_h=0.23,
 tpw_cpn_l=0.43,tpw_sdn_l=0.40,cpn_hl_q_hl_1=0,cpn_hl_q_lh_1=0,sdn_hl_q_lh_7=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cpn,th_cpn_sd_l,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cpn,th_cpn_sd_h,notifier,,,d_CPN,d_SD);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cpn,th_cpn_sc_l,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cpn,th_cpn_sc_h,notifier,,,d_CPN,d_SC);
 $setuphold (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cpn,th_cpn_enn_l,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cpn,th_cpn_enn_h,notifier,,,d_CPN,d_ENN);
 $setuphold (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cpn,th_cpn_d_l,notifier,,,d_CPN,d_D);
 $setuphold (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cpn,th_cpn_d_h,notifier,,,d_CPN,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,th_cpn_sdn_l,notifier,,,d_SDN,d_CPN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_h_cpn,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge CPN &&& (vcond1==1'b1),tsu_sd_l_cpn,notifier);
 $setup (posedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_h_cpn,notifier);
 $setup (negedge SC &&& (SDN==1'b1),negedge CPN &&& (SDN==1'b1),tsu_sc_l_cpn,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_h_cpn,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),negedge CPN &&& (SDN==1'b1),tsu_enn_l_cpn,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_h_cpn,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),negedge CPN &&& (vcond2==1'b1),tsu_d_l_cpn,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,negedge CPN,tsu_sdn_h_cpn,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cpn_sd_h,notifier);
 $hold  (negedge CPN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cpn_sd_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cpn_sc_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cpn_sc_l,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_h,notifier);
 $hold  (negedge CPN &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cpn_enn_l,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cpn_d_h,notifier);
 $hold  (negedge CPN &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cpn_d_l,notifier);
 $hold  (negedge CPN,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cpn_sdn_l,notifier);
`endif
 $width (posedge CPN &&& (SDN==1'b1),tpw_cpn_h,0,notifier);
 $width (negedge CPN &&& (SDN==1'b1),tpw_cpn_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (negedge CPN  => (Q +: D)) = (cpn_hl_q_lh_1,cpn_hl_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_7,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: seprq1.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto

module seprq1 (CP,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_SB #1 (Q,CP,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_SB_NO #1 (Q,CP,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.52,tsu_sd_l_cp=0.70,tsu_sc_h_cp=0.72,tsu_sc_l_cp=0.76,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.80,tsu_d_h_cp=0.37,tsu_d_l_cp=0.57,tsu_sdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.07,tpw_cp_h=0.23,
 tpw_cp_l=0.43,tpw_sdn_l=0.40,cp_lh_q_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_q_lh_7=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (posedge CP   => (Q+:D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_7,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: seprq2.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module seprq2 (CP,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_SB #1 (Q,CP,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_SB_NO #1 (Q,CP,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.52,tsu_sd_l_cp=0.69,tsu_sc_h_cp=0.72,tsu_sc_l_cp=0.76,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.80,tsu_d_h_cp=0.37,tsu_d_l_cp=0.57,tsu_sdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.07,tpw_cp_h=0.31,
 tpw_cp_l=0.43,tpw_sdn_l=0.46,cp_lh_q_hl_1=0,sdn_hl_q_lh_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (posedge CP   => (Q+:D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: seprq4.v
// Description  	:  Muxed Scan Enable D Flip-Flop with Preset and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// Added posedge to CP 
// at delay path        : 20Dec05 assafma & bengil 
// Added source to above : 29Jun06 tamasto
// Add `+` for veritime usage  : 11July06 tamasto


module seprq4 (CP,SDN,ENN,D,SC,SD,Q);

output  Q;
input   CP,SDN,ENN,D,SC,SD;

wire not_CPN,SDN_buf,SC_buf,ENN_buf;

`ifdef neg_tchk
wire d_CP,d_SDN,d_ENN,d_D,d_SC,d_SD;
`endif

`ifdef functional
U_FD_SC_EN_P_SB #1 (Q,CP,ENN,SC,SDN,D,SD);
`else
reg notifier;
`ifdef neg_tchk
U_FD_SC_EN_P_SB_NO #1 (Q,d_CP,d_ENN,d_SC,d_SDN,d_D,d_SD,notifier);
`else
U_FD_SC_EN_P_SB_NO #1 (Q,CP,ENN,SC,SDN,D,SD,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (SC_buf,d_SC);
buf (ENN_buf,d_ENN);
`else
buf (SDN_buf,SDN);
buf (SC_buf,SC);
buf (ENN_buf,ENN);
`endif


wire vcond1 = ((SDN_buf==1'b1) && (SC_buf==1'b1));
wire vcond_SDN_vio = ((ENN_buf==1'b0) || (SC_buf==1'b1));
wire vcond_ENN_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0));
wire vcond_D_vio = ((SDN_buf==1'b1) && (SC_buf==1'b0) && (ENN_buf==1'b0));
wire vcond2 = ((SDN_buf==1'b1) && (SC_buf==1'b0));
specify
// Parameter declarations
 specparam tsu_sd_h_cp=0.52,tsu_sd_l_cp=0.70,tsu_sc_h_cp=0.72,tsu_sc_l_cp=0.76,
 tsu_enn_h_cp=0.52,tsu_enn_l_cp=0.80,tsu_d_h_cp=0.37,tsu_d_l_cp=0.57,tsu_sdn_h_cp=0.00,
 th_cp_sd_h=0.00,th_cp_sd_l=0.00,th_cp_sc_h=0.00,th_cp_sc_l=0.00,th_cp_enn_h=0.00,
 th_cp_enn_l=0.00,th_cp_d_h=0.00,th_cp_d_l=0.00,th_cp_sdn_l=0.07,tpw_cp_h=0.23,
 tpw_cp_l=0.43,tpw_sdn_l=0.40,cp_lh_q_hl_1=0,cp_lh_q_lh_1=0,sdn_hl_q_lh_7=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_h_cp,th_cp_enn_l,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),tsu_enn_l_cp,th_cp_enn_h,notifier,,,d_CP,d_ENN);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),tsu_d_h_cp,th_cp_d_l,notifier,,,d_CP,d_D);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),tsu_d_l_cp,th_cp_d_h,notifier,,,d_CP,d_D);
 $recrem (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_h_cp,notifier);
 $setup (negedge ENN &&& (vcond_ENN_vio==1'b1),posedge CP &&& (SDN==1'b1),tsu_enn_l_cp,notifier);
 $setup (posedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_h_cp,notifier);
 $setup (negedge D &&& (vcond_D_vio==1'b1),posedge CP &&& (vcond2==1'b1),tsu_d_l_cp,notifier);
 $recovery (posedge SDN &&& (vcond_SDN_vio==1'b1) ,posedge CP,tsu_sdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge SC &&& (SDN==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge SC &&& (SDN==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),negedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_h,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge ENN &&& (vcond_ENN_vio==1'b1),th_cp_enn_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge D &&& (vcond_D_vio==1'b1),th_cp_d_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge D &&& (vcond_D_vio==1'b1),th_cp_d_l,notifier);
 $hold  (posedge CP,posedge SDN &&& (vcond_SDN_vio==1'b1) ,th_cp_sdn_l,notifier);
`endif
 $width (posedge CP &&& (SDN==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (SDN==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN,tpw_sdn_l,0,notifier);
// Delays
 (posedge CP   => (Q+:D)) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge SDN  => (Q +: 1'b1)) = (sdn_hl_q_lh_7,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: skbrb1.v
// Description          : Scan JKZ Flip-Flop with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//

module skbrb1 (J,KZ,SD,SC,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,SD,SC,CP,SDN,CDN;

wire temp,not_temp_2,temp_2;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp_2,temp_2);

`ifdef functional
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_RB_SB_QN #1 (QN,not_temp_2,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp_2,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (temp_2,temp,not_SD,d_SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,d_CP,d_CDN,d_SDN,notifier);
`else
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SD,d_SD);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.32,tsu_j_l_cp=0.26,
 tsu_sd_h_cp=0.00,tsu_sd_l_cp=0.00,tsu_sc_h_cp=0.00,tsu_sc_l_cp=0.00,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.18,th_cp_cdn_l=0.26,tpw_cp_h=0.28,tpw_cp_l=0.41,
 th_cp_sd_l=0.28,th_cp_sd_h=0.28,th_cp_sc_l=0.28,th_cp_sc_h=0.28,
 tpw_sdn_l=0.47,tpw_cdn_l=0.38,cdn_hl_qn_lh_1=0,cdn_hl_q_hl_1=0,sdn_lh_qn_lh_3=0,
 cdn_lh_q_lh_3=0,sdn_hl_qn_hl_5=0,sdn_hl_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_3,cdn_hl_q_hl_1);
 (        SDN +=> QN) = (sdn_lh_qn_lh_3,sdn_hl_qn_hl_5);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: skbrb2.v
// Description          : Scan JKZ Flip-Flop with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//

module skbrb2 (J,KZ,SD,SC,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,SD,SC,CP,SDN,CDN;

wire temp,not_temp_2,temp_2;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp_2,temp_2);

`ifdef functional
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_RB_SB_QN #1 (QN,not_temp_2,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp_2,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (temp_2,temp,not_SD,d_SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,d_CP,d_CDN,d_SDN,notifier);
`else
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SD,d_SD);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.32,tsu_j_l_cp=0.26,
 tsu_sd_h_cp=0.00,tsu_sd_l_cp=0.00,tsu_sc_h_cp=0.00,tsu_sc_l_cp=0.00,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.18,th_cp_cdn_l=0.26,tpw_cp_h=0.28,tpw_cp_l=0.41,
 th_cp_sd_l=0.28,th_cp_sd_h=0.28,th_cp_sc_l=0.28,th_cp_sc_h=0.28,
 tpw_sdn_l=0.47,tpw_cdn_l=0.38,cdn_hl_qn_lh_1=0,cdn_hl_q_hl_1=0,sdn_lh_qn_lh_3=0,
 cdn_lh_q_lh_3=0,sdn_hl_qn_hl_5=0,sdn_hl_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_3,cdn_hl_q_hl_1);
 (        SDN +=> QN) = (sdn_lh_qn_lh_3,sdn_hl_qn_hl_5);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: skbrb4.v
// Description          : Scan JKZ Flip-Flop with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.5
//
//

module skbrb4 (J,KZ,SD,SC,CP,Q,QN,SDN,CDN);

output  Q,QN;
input   J,KZ,SD,SC,CP,SDN,CDN;

wire temp,not_temp_2,temp_2;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_J,d_KZ,d_SD,d_SC,d_CP,d_SDN,d_CDN;
`endif

U_MUX_2_1 (temp,not_J,not_KZ,Q);
not (not_temp_2,temp_2);

`ifdef functional
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_RB_SB_QN #1 (QN,not_temp_2,not_CP,CDN,SDN);
U_FD_P_RB_SB #1 (Q,not_temp_2,CP,CDN,SDN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (temp_2,temp,not_SD,d_SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,d_CP,d_CDN,d_SDN,notifier);
`else
U_MUX_2_1 (temp_2,temp,not_SD,SC);
U_FD_N_R_S_NO_QN #1 (QN,not_temp_2,not_CP,not_CDN,not_SDN,notifier);
U_FD_P_RB_SB_NO #1 (Q,not_temp_2,CP,CDN,SDN,notifier);
`endif
`endif

`ifdef functional
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_CP,CP);
`else
`ifdef neg_tchk
not (not_J,d_J);
not (not_KZ,d_KZ);
not (not_SD,d_SD);
not (not_SDN,d_SDN);
not (not_CDN,d_CDN);
not (not_CP,d_CP);
`else
not (not_J,J);
not (not_KZ,KZ);
not (not_SD,SD);
not (not_SDN,SDN);
not (not_CDN,CDN);
not (not_CP,CP);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SDN_buf,d_SDN);
buf (CDN_buf,d_CDN);
buf (SC_buf,d_SC);
`else
buf (SDN_buf,SDN);
buf (CDN_buf,CDN);
buf (SC_buf,SC);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_kz_h_cp=0.22,tsu_kz_l_cp=0.33,tsu_j_h_cp=0.32,tsu_j_l_cp=0.26,
 tsu_sd_h_cp=0.00,tsu_sd_l_cp=0.00,tsu_sc_h_cp=0.00,tsu_sc_l_cp=0.00,
 tsu_sdn_h_cp=0.00,tsu_cdn_h_cp=0.00,th_cp_kz_h=0.00,th_cp_kz_l=0.00,th_cp_j_h=0.00,
 th_cp_j_l=0.00,th_cp_sdn_l=0.18,th_cp_cdn_l=0.26,tpw_cp_h=0.28,tpw_cp_l=0.41,
 th_cp_sd_l=0.28,th_cp_sd_h=0.28,th_cp_sc_l=0.28,th_cp_sc_h=0.28,
 tpw_sdn_l=0.47,tpw_cdn_l=0.38,cdn_hl_qn_lh_1=0,cdn_hl_q_hl_1=0,sdn_lh_qn_lh_3=0,
 cdn_lh_q_lh_3=0,sdn_hl_qn_hl_5=0,sdn_hl_q_lh_1=0,cp_lh_qn_lh_1=0,cp_lh_q_hl_1=0,cp_lh_qn_hl_1=0,cp_lh_q_lh_1=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_cp,th_cp_sd_l,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_cp,th_cp_sd_h,notifier,,,d_CP,d_SD);
 $setuphold (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_cp,th_cp_sc_l,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_cp,th_cp_sc_h,notifier,,,d_CP,d_SC);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),tsu_kz_h_cp,th_cp_kz_l,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),tsu_kz_l_cp,th_cp_kz_h,notifier,,,d_CP,d_KZ);
 $setuphold (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),tsu_j_h_cp,th_cp_j_l,notifier,,,d_CP,d_J);
 $setuphold (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),tsu_j_l_cp,th_cp_j_h,notifier,,,d_CP,d_J);
 $recrem (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,th_cp_sdn_l,notifier,,,d_SDN,d_CP);
 $recrem (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,th_cp_cdn_l,notifier,,,d_CDN,d_CP);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_h_cp,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge CP &&& (vcond1==1'b1),tsu_sd_l_cp,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_h_cp,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),posedge CP &&& (vcond2==1'b1),tsu_sc_l_cp,notifier);
 $setup (posedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_h_cp,notifier);
 $setup (negedge KZ &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_kz_l_cp,notifier);
 $setup (posedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_h_cp,notifier);
 $setup (negedge J &&& (vcond3==1'b1),posedge CP &&& (vcond3==1'b1),tsu_j_l_cp,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),posedge CP &&& (CDN==1'b1),tsu_sdn_h_cp,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),posedge CP &&& (SDN==1'b1),tsu_cdn_h_cp,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_cp_sd_h,notifier);
 $hold  (posedge CP &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_cp_sd_l,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_cp_sc_h,notifier);
 $hold  (posedge CP &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_cp_sc_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge KZ &&& (vcond3==1'b1),th_cp_kz_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge KZ &&& (vcond3==1'b1),th_cp_kz_l,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),negedge J &&& (vcond3==1'b1),th_cp_j_h,notifier);
 $hold  (posedge CP &&& (vcond3==1'b1),posedge J &&& (vcond3==1'b1),th_cp_j_l,notifier);
 $hold  (posedge CP &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_cp_sdn_l,notifier);
 $hold  (posedge CP &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_cp_cdn_l,notifier);
`endif
 $width (posedge CP &&& (vcond2==1'b1),tpw_cp_h,0,notifier);
 $width (negedge CP &&& (vcond2==1'b1),tpw_cp_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
// Delays
 (        CDN +=> Q ) = (cdn_lh_q_lh_3,cdn_hl_q_hl_1);
 (        SDN +=> QN) = (sdn_lh_qn_lh_3,sdn_hl_qn_hl_5);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (QN -: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_qn_lh_1,cp_lh_qn_hl_1);
 if ((SDN==1'b1) && (CDN==1'b1))
 (posedge CP   => (Q  +: ((((J && ~Q) || (KZ && Q)) && ~SC) || (SD && SC)))) = (cp_lh_q_lh_1,cp_lh_q_hl_1);
 (negedge CDN  => (QN +: 1'b1)) = (cdn_hl_qn_lh_1,0);
 (negedge SDN  => (Q  +: 1'b1)) = (sdn_hl_q_lh_1,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slbhb1.v
// Description  	: Muxed Scan Latch with Clear, Preset, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slbhb1 (E,SC,D,SD,CDN,SDN,Q,QN,SO);

output  Q,QN,SO;
input   E,SC,D,SD,CDN,SDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SC,d_SD,d_CDN,d_SDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN #1 (QN,mux_out,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,mux_out,E,CDN,SDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,E,CDN,SDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.13,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,tpw_e_l=0.00,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,tpw_sc_h=0.00,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
tsu_sc_l_e=0,th_e_sc_h=0,cdn_hl_qn_lh_6=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_l_e,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (vcond1==1'b1),tpw_e_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 (        CDN -=> QN) = (cdn_hl_qn_lh_6,cdn_lh_qn_hl_5);
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => QN ) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  -=> QN ) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  -=> QN ) = (sd_hl_qn_lh,sd_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: ((D && ~SC) || (SD && SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slbhb2.v
// Description  	: Muxed Scan Latch with Clear, Preset, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slbhb2 (E,SC,D,SD,CDN,SDN,Q,QN,SO);

output  Q,QN,SO;
input   E,SC,D,SD,CDN,SDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SC,d_SD,d_CDN,d_SDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN #1 (QN,mux_out,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,mux_out,E,CDN,SDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,E,CDN,SDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.13,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,tpw_e_l=0.00,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,tpw_sc_h=0.00,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
tsu_sc_l_e=0,th_e_sc_h=0,cdn_hl_qn_lh_6=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_l_e,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (vcond1==1'b1),tpw_e_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 (        CDN -=> QN) = (cdn_hl_qn_lh_6,cdn_lh_qn_hl_5);
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => QN ) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  -=> QN ) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  -=> QN ) = (sd_hl_qn_lh,sd_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: ((D && ~SC) || (SD && SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slbhb4.v
// Description  	: Muxed Scan Latch with Clear, Preset, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slbhb4 (E,SC,D,SD,CDN,SDN,Q,QN,SO);

output  Q,QN,SO;
input   E,SC,D,SD,CDN,SDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SC,d_SD,d_CDN,d_SDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN #1 (QN,mux_out,E,CDN,SDN);
U_LD_P_SB_RB #1 (Q,mux_out,E,CDN,SDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,d_E,d_CDN,d_SDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_SB_RB_QN_NO #1 (QN,mux_out,E,CDN,SDN,notifier);
U_LD_P_SB_RB_NO #1 (Q,mux_out,E,CDN,SDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
buf (SDN_buf,d_SDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
buf (SDN_buf,SDN);
`endif


wire vcond1 = ((SC_buf==1'b1) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SDN_buf==1'b1) && (CDN_buf==1'b1));
wire vcond3 = ((SC_buf==1'b0) && (SDN_buf==1'b1) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.14,tsu_d_l_e=0.21,tsu_sdn_h_e=0.00,tsu_cdn_h_e=0.13,
 th_e_d_h=0.00,th_e_d_l=0.00,th_e_sdn_l=0.08,th_e_cdn_l=0.00,tpw_e_h=0.24,tpw_e_l=0.00,
 tpw_sdn_l=0.22,tpw_cdn_l=0.27,tpw_sc_h=0,cdn_hl_q_hl_1=0,sdn_hl_q_lh_1=0,sdn_lh_q_hl_1=0,
 sdn_lh_qn_lh=0,e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
tsu_sc_l_e=0,th_e_sc_h=0,cdn_hl_qn_lh_6=0,cdn_lh_q_lh=0,cdn_lh_qn_hl_5=0,
 d_hl_q_hl=0,d_hl_qn_lh=0,sdn_hl_qn_hl_2=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $recrem (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,th_e_sdn_l,notifier,,,d_SDN,d_E);
 $recrem (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_sc_l_e,notifier);
 $setup (posedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond3==1'b1),negedge E &&& (vcond3==1'b1),tsu_d_l_e,notifier);
 $recovery (posedge SDN &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sdn_h_e,notifier);
 $recovery (posedge CDN &&& (SDN==1'b1),negedge E &&& (SDN==1'b1),tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge SC &&& (vcond2==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge SC &&& (vcond2==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),negedge D &&& (vcond3==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (vcond3==1'b1),posedge D &&& (vcond3==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SDN &&& (CDN==1'b1),th_e_sdn_l,notifier);
 $hold  (negedge E &&& (SDN==1'b1),posedge CDN &&& (SDN==1'b1),th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (vcond1==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (vcond1==1'b1),tpw_e_l,0,notifier);
 $width (negedge SDN &&& (CDN==1'b1),tpw_sdn_l,0,notifier);
 $width (negedge CDN &&& (SDN==1'b1),tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 (        SDN -=> Q ) = (sdn_hl_q_lh_1,sdn_lh_q_hl_1);
 (        CDN -=> QN) = (cdn_hl_qn_lh_6,cdn_lh_qn_hl_5);
 if (SDN==1'b1)
 (        CDN +=> Q ) = (cdn_lh_q_lh,cdn_hl_q_hl_1);
 if (CDN==1'b1)
 (        SDN +=> QN) = (sdn_lh_qn_lh,sdn_hl_qn_hl_2);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1))
 (        SC  => QN ) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b0))
 (        D  -=> QN ) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SDN==1'b1) && (SC==1'b1))
 (        SD  -=> QN ) = (sd_hl_qn_lh,sd_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (Q  +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (posedge E    => (QN -: ((D && ~SC) || (SD && SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 if ((CDN==1'b1) && (SDN==1'b1))
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slchq1.v
// Description          : Muxed Scan High Enable Latch with Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slchq1 (E,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   E,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SD,d_SC,d_CDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,E,CDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,d_E,d_CDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,E,CDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.03,tsu_d_l_e=0.16,tsu_cdn_h_e=0.03,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.15,tpw_cdn_l=0.25,e_lh_q_lh=0,
 tpw_e_l=0.00,tpw_sc_h=0,e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
 tsu_sc_l_e=0,th_e_sc_h=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_l_e,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (CDN==1'b1),tpw_e_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (posedge E    => (Q +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if (CDN==1'b1)
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slchq2.v
// Description          : Muxed Scan High Enable Latch with Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slchq2 (E,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   E,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SD,d_SC,d_CDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,E,CDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,d_E,d_CDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,E,CDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.03,tsu_d_l_e=0.16,tsu_cdn_h_e=0.03,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.15,tpw_cdn_l=0.25,e_lh_q_lh=0,
 tpw_e_l=0.00,tpw_sc_h=0,e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
 tsu_sc_l_e=0,th_e_sc_h=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_l_e,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (CDN==1'b1),tpw_e_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (posedge E    => (Q +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if (CDN==1'b1)
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slchq4.v
// Description          : Muxed Scan High Enable Latch with Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slchq4 (E,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   E,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf;

`ifdef neg_tchk
wire d_E,d_D,d_SD,d_SC,d_CDN;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,E,CDN);
U_LD_N (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,d_E,d_CDN,notifier);
U_LD_N_NO (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,E,CDN,notifier);
U_LD_N_NO (SO,Q,E,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_e=0.03,tsu_d_l_e=0.16,tsu_cdn_h_e=0.03,th_e_d_h=0.00,
 th_e_d_l=0.00,th_e_cdn_l=0.00,tpw_e_h=0.15,tpw_cdn_l=0.25,e_lh_q_lh=0,
 tpw_e_l=0.00,tpw_sc_h=0,e_lh_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_e=0,th_e_sd_l=0,tsu_sd_l_e=0,th_e_sd_h=0,tsu_sc_h_e=0,th_e_sc_l=0,
 tsu_sc_l_e=0,th_e_sc_h=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $recrem (posedge CDN,negedge E,tsu_cdn_h_e,th_e_cdn_l,notifier,,,d_CDN,d_E);
`else
 $setup (posedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),negedge E &&& (vcond1==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_h_e,notifier);
 $setup (negedge D &&& (vcond2==1'b1),negedge E &&& (vcond2==1'b1),tsu_d_l_e,notifier);
 $setup (posedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_h_e,notifier);
 $setup (negedge SC &&& (CDN==1'b1),negedge E &&& (CDN==1'b1),tsu_sc_l_e,notifier);
 $recovery (posedge CDN,negedge E,tsu_cdn_h_e,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_e_d_l,notifier);
 $hold  (negedge E &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_e_d_h,notifier);
 $hold  (negedge E &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_e_sc_l,notifier);
 $hold  (negedge E &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_e_sc_h,notifier);
 $hold  (negedge E,posedge CDN,th_e_cdn_l,notifier);
`endif
 $width (posedge E &&& (CDN==1'b1),tpw_e_h,0,notifier);
 $width (negedge E &&& (CDN==1'b1),tpw_e_l,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((E==1'b1) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (posedge E    => (Q +: ((D && ~SC) || (SD && SC)))) = (e_lh_q_lh,e_lh_q_hl);
 if (CDN==1'b1)
 (negedge E    => (SO +: ((D && ~SC) || (SD && SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slclq1.v
// Description          : Muxed Scan Latch with Low Enable, Clear and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slclq1 (EN,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   EN,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_SD,d_SC,d_CDN;
`endif


`ifdef functional
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,not_EN,CDN);
U_LD_P (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
not (not_EN,d_EN);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,d_CDN,notifier);
U_LD_P_NO (SO,Q,d_EN,notifier);
`else
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,CDN,notifier);
U_LD_P_NO (SO,Q,EN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_en=0.03,tsu_d_l_en=0.16,tsu_cdn_h_en=0.03,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.15,tpw_cdn_l=0.25,en_hl_q_lh=0,
 tpw_en_h=0.00,tpw_sc_h=0,en_hl_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_en=0,th_en_sd_l=0,tsu_sd_l_en=0,th_en_sd_h=0,tsu_sc_h_en=0,th_en_sc_l=0,
 tsu_sc_l_en=0,th_en_sc_h=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_l_en,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_h_en,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_en_sc_l,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_en_sc_h,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (posedge EN &&& (CDN==1'b1),tpw_en_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((EN==1'b0) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN    => (Q +: ((D && ~SC) || (SD && SC)))) = (en_hl_q_lh,en_hl_q_hl);
 if (CDN==1'b1)
 (posedge EN    => (SO +: ((D && ~SC) || (SD && SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slclq2.v
// Description          : Muxed Scan Latch with Low Enable, Clear and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slclq2 (EN,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   EN,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_SD,d_SC,d_CDN;
`endif


`ifdef functional
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,not_EN,CDN);
U_LD_P (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
not (not_EN,d_EN);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,d_CDN,notifier);
U_LD_P_NO (SO,Q,d_EN,notifier);
`else
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,CDN,notifier);
U_LD_P_NO (SO,Q,EN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_en=0.03,tsu_d_l_en=0.16,tsu_cdn_h_en=0.03,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.15,tpw_cdn_l=0.25,en_hl_q_lh=0,
 en_hl_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 tpw_en_h=0.00,tpw_sc_h=0,sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_en=0,th_en_sd_l=0,tsu_sd_l_en=0,th_en_sd_h=0,tsu_sc_h_en=0,th_en_sc_l=0,
 tsu_sc_l_en=0,th_en_sc_h=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_l_en,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_h_en,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_en_sc_l,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_en_sc_h,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (posedge EN &&& (CDN==1'b1),tpw_en_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((EN==1'b0) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN    => (Q +: ((D && ~SC) || (SD && SC)))) = (en_hl_q_lh,en_hl_q_hl);
 if (CDN==1'b1)
 (posedge EN    => (SO +: ((D && ~SC) || (SD && SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slclq4.v
// Description          : Muxed Scan Latch with Low Enable, Clear and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slclq4 (EN,D,SD,SC,CDN,Q,SO);

output  Q,SO;
input   EN,D,SD,SC,CDN;

wire temp,not_temp_2,temp_2,mux_out;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_EN,d_D,d_SD,d_SC,d_CDN;
`endif


`ifdef functional
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB #1 (Q,mux_out,not_EN,CDN);
U_LD_P (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
not (not_EN,d_EN);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,d_CDN,notifier);
U_LD_P_NO (SO,Q,d_EN,notifier);
`else
not (not_EN,EN);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_RB_NO #1 (Q,mux_out,not_EN,CDN,notifier);
U_LD_P_NO (SO,Q,EN,notifier);
`endif
`endif

`ifdef functional
`else
`ifdef neg_tchk
buf (SC_buf,d_SC);
buf (CDN_buf,d_CDN);
`else
buf (SC_buf,SC);
buf (CDN_buf,CDN);
`endif

wire vcond1 = ((SC_buf==1'b1) && (CDN_buf==1'b1));
wire vcond2 = ((SC_buf==1'b0) && (CDN_buf==1'b1));
specify
// Parameter declarations
 specparam tsu_d_h_en=0.03,tsu_d_l_en=0.16,tsu_cdn_h_en=0.03,th_en_d_h=0.00,
 th_en_d_l=0.00,th_en_cdn_l=0.00,tpw_en_l=0.15,tpw_cdn_l=0.25,en_hl_q_lh=0,
 tpw_en_h=0.00,tpw_sc_h=0,en_hl_q_hl=0,d_lh_q_lh=0,d_hl_q_hl=0,cdn_lh_q_lh=0,cdn_hl_q_hl_3=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 tsu_sd_h_en=0,th_en_sd_l=0,tsu_sd_l_en=0,th_en_sd_h=0,tsu_sc_h_en=0,th_en_sc_l=0,
 tsu_sc_l_en=0,th_en_sc_h=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $recrem (posedge CDN,posedge EN,tsu_cdn_h_en,th_en_cdn_l,notifier,,,d_CDN,d_EN);
`else
 $setup (posedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (vcond1==1'b1),posedge EN &&& (vcond1==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_h_en,notifier);
 $setup (negedge D &&& (vcond2==1'b1),posedge EN &&& (vcond2==1'b1),tsu_d_l_en,notifier);
 $setup (posedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_h_en,notifier);
 $setup (negedge SC &&& (CDN==1'b1),posedge EN &&& (CDN==1'b1),tsu_sc_l_en,notifier);
 $recovery (posedge CDN,posedge EN,tsu_cdn_h_en,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),posedge SD &&& (vcond1==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN &&& (vcond1==1'b1),negedge SD &&& (vcond1==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),posedge D &&& (vcond2==1'b1),th_en_d_l,notifier);
 $hold  (posedge EN &&& (vcond2==1'b1),negedge D &&& (vcond2==1'b1),th_en_d_h,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),posedge SC &&& (CDN==1'b1),th_en_sc_l,notifier);
 $hold  (posedge EN &&& (CDN==1'b1),negedge SC &&& (CDN==1'b1),th_en_sc_h,notifier);
 $hold  (posedge EN,posedge CDN,th_en_cdn_l,notifier);
`endif
 $width (negedge EN &&& (CDN==1'b1),tpw_en_l,0,notifier);
 $width (posedge EN &&& (CDN==1'b1),tpw_en_h,0,notifier);
 $width (negedge CDN,tpw_cdn_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if ((EN==1'b0) && (CDN==1'b1))
 (        SC   => Q) = (sc_lh_q_lh,sc_hl_q_hl);
 (        CDN +=> Q) = (cdn_lh_q_lh,cdn_hl_q_hl_3);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b0))
 (        D   +=> Q) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (CDN==1'b1) && (SC==1'b1))
 (        SD   +=> Q) = (sd_lh_q_lh,sd_hl_q_hl);
 if (CDN==1'b1)
 (negedge EN    => (Q +: ((D && ~SC) || (SD && SC)))) = (en_hl_q_lh,en_hl_q_hl);
 if (CDN==1'b1)
 (posedge EN    => (SO +: ((D && ~SC) || (SD && SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhb1.v
// Description          : Muxed Scan Latch, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhb1 (D,SD,SC,E,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,E;

wire temp,not_temp_2,temp_2,mux_out,buf_Q;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (buf_Q,mux_out,E);
U_LD_N #1 (SO,buf_Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (buf_Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,buf_Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (buf_Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,buf_Q,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if (E==1'b1)
 (        SC => QN) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhb2.v
// Description          : Muxed Scan Latch, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhb2 (D,SD,SC,E,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,E;

wire temp,not_temp_2,temp_2,mux_out,buf_Q;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (buf_Q,mux_out,E);
U_LD_N #1 (SO,buf_Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (buf_Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,buf_Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (buf_Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,buf_Q,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if (E==1'b1)
 (        SC => QN) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhb4.v
// Description          : Muxed Scan Latch, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhb4 (D,SD,SC,E,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,E;

wire temp,not_temp_2,temp_2,mux_out,buf_Q;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (buf_Q,mux_out,E);
U_LD_N #1 (SO,buf_Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (buf_Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,buf_Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (buf_Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,buf_Q,E,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 e_lh_q_hl=0,e_lh_qn_lh=0,e_lh_q_lh=0,e_lh_qn_hl=0,
 sc_lh_q_lh=0,sc_hl_q_hl=0,sc_lh_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_lh_q_lh,sc_hl_q_hl);
 if (E==1'b1)
 (        SC => QN) = (sc_lh_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhn1.v
// Description          : Muxed Scan Latch with QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhn1 (D,SD,SC,E,QN,SO);

output  QN,SO;
input   D,SD,SC,E;

wire temp,not_temp_2,temp_2,mux_out,buf_Q,mux,mux_not,Q;
wire not_J,not_KZ,not_SD,not_CDN,not_SDN,not_CP,SDN_buf,CDN_buf,SC_buf,not_EN;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P #1 (QN,mux_not,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux,d_D,d_SD,d_SC);
U_LD_P_NO #1 (QN,mux_not,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P_NO #1 (QN,mux_not,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif

not (mux_not,mux);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,
 sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 e_lh_qn_lh=0,e_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => QN) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhn2.v
// Description          : Muxed Scan Latch with QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhn2 (D,SD,SC,E,QN,SO);

output  QN,SO;
input   D,SD,SC,E;

wire mux,mux_not,Q;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P #1 (QN,mux_not,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux,d_D,d_SD,d_SC);
U_LD_P_NO #1 (QN,mux_not,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P_NO #1 (QN,mux_not,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif
                                                                                                                
not (mux_not,mux);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,
 sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 e_lh_qn_lh=0,e_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => QN) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhn4.v
// Description          : Muxed Scan Latch with QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhn4 (D,SD,SC,E,QN,SO);

output  QN,SO;
input   D,SD,SC,E;


wire mux,mux_not,Q;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P #1 (QN,mux_not,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux,d_D,d_SD,d_SC);
U_LD_P_NO #1 (QN,mux_not,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux,D,SD,SC);
U_LD_P_NO #1 (QN,mux_not,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif
                                                                                                                
not (mux_not,mux);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,
 sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 e_lh_qn_lh=0,e_lh_qn_hl=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => QN) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (posedge E  => (QN -: ((SD && SC) || (D && ~SC)))) = (e_lh_qn_lh,e_lh_qn_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhq1.v
// Description          : Muxed Scan Latch with Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhq1 (D,SD,SC,E,Q,SO);

output  Q,SO;
input   D,SD,SC,E;

wire mux,mux_out,Q;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 e_lh_q_hl=0,e_lh_q_lh=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhq2.v
// Description          : Muxed Scan Latch with Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhq2 (D,SD,SC,E,Q,SO);

output  Q,SO;
input   D,SD,SC,E;

wire mux_out;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 e_lh_q_hl=0,e_lh_q_lh=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnhq4.v
// Description          : Muxed Scan Latch with Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnhq4 (D,SD,SC,E,Q,SO);

output  Q,SO;
input   D,SD,SC,E;

wire mux_out;

`ifdef neg_tchk
wire d_D,d_E,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.00,tsu_d_l_e=0.13,th_e_d_h=0.00,th_e_d_l=0.15,
 tsu_sd_h_e=0.00,tsu_sd_l_e=0.13,tsu_sc_h_e=0.00,tsu_sc_l_e=0.13,
 th_e_sd_h=0.00,th_e_sd_l=0.15,th_e_sc_h=0.00,th_e_sc_l=0.15,
 tpw_e_l=0.00,tpw_e_h=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 e_lh_q_hl=0,e_lh_q_lh=0,e_hl_so_hl=0,e_hl_so_lh=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (E==1'b1)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((E==1'b1) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((E==1'b1) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (posedge E  => (Q  +: ((SD && SC) || (D && ~SC)))) = (e_lh_q_lh,e_lh_q_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnht1.v
// Description          : Muxed Scan Latch with Z-output only and Active Higher Enable, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module slnht1 (D,SD,SC,E,OE,Z,SO);

output  Z,SO;
input   D,SD,SC,E,OE;

wire mux_out,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_E;
`endif


`ifdef functional
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;
`ifdef neg_tchk
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.18,th_e_d_h=0.00,th_e_d_l=0.01,
 tpw_e_l=0.00,tpw_e_h=0.25,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zl_1=0,d_hl_z_hl=0,
 tsu_sd_h_e=0.04,tsu_sd_l_e=0.18,tsu_sc_h_e=0.04,tsu_sc_l_e=0.18,
 th_e_sd_h=0.00,th_e_sd_l=0.01,th_e_sc_h=0.00,th_e_sc_l=0.01,
 sd_lh_z_lh=0,sd_hl_z_hl=0,sc_hl_z_lh=0,sc_hl_z_hl=0,e_hl_so_hl=0,e_hl_so_lh=0,
 e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0,oe_lh_z_zh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_2,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (SD   *> Z) = (sd_lh_z_lh,sd_hl_z_hl);
 (SC   *> Z) = (sc_hl_z_lh,sc_hl_z_hl);
 (E   *> Z) = (e_lh_z_lh,e_lh_z_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif



endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnht2.v
// Description          : Muxed Scan Latch with Z-output only and Active Higher Enable, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module slnht2 (D,SD,SC,E,OE,Z,SO);

output  Z,SO;
input   D,SD,SC,E,OE;

wire mux_out,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_E;
`endif


`ifdef functional
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;
`ifdef neg_tchk
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.18,th_e_d_h=0.00,th_e_d_l=0.01,
 tpw_e_l=0.00,tpw_e_h=0.25,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zl_1=0,d_hl_z_hl=0,
 tsu_sd_h_e=0.04,tsu_sd_l_e=0.18,tsu_sc_h_e=0.04,tsu_sc_l_e=0.18,
 th_e_sd_h=0.00,th_e_sd_l=0.01,th_e_sc_h=0.00,th_e_sc_l=0.01,
 sd_lh_z_lh=0,sd_hl_z_hl=0,sc_hl_z_lh=0,sc_hl_z_hl=0,e_hl_so_lh=0,e_hl_so_hl=0,
 e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0,oe_lh_z_zh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_2,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (SD   *> Z) = (sd_lh_z_lh,sd_hl_z_hl);
 (SC   *> Z) = (sc_hl_z_lh,sc_hl_z_hl);
 (E   *> Z) = (e_lh_z_lh,e_lh_z_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif



endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnht4.v
// Description          : Muxed Scan Latch with Z-output only and Active Higher Enable, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.10
//
//


module slnht4 (D,SD,SC,E,OE,Z,SO);

output  Z,SO;
input   D,SD,SC,E,OE;

wire mux_out,OE_buf,Q;

`ifdef neg_tchk
wire d_D,d_SD,d_SC,d_E;
`endif


`ifdef functional
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P #1 (Q,mux_out,E);
U_LD_N #1 (SO,Q,E);
bufif1 b1(Z,Q,OE_buf);
`else
reg notifier;
`ifdef neg_tchk
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_P_NO #1 (Q,mux_out,d_E,notifier);
U_LD_N_NO #1 (SO,Q,d_E,notifier);
bufif1 b1(Z,Q,OE_buf);
`else
buf b_OE (OE_buf,OE);
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_P_NO #1 (Q,mux_out,E,notifier);
U_LD_N_NO #1 (SO,Q,E,notifier);
bufif1 b1(Z,Q,OE_buf);
`endif
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_e=0.04,tsu_d_l_e=0.18,th_e_d_h=0.00,th_e_d_l=0.01,
 tpw_e_l=0.00,tpw_e_h=0.25,d_lh_z_lh=0,oe_hl_z_hz_1=0,oe_lh_z_zl_1=0,d_hl_z_hl=0,
 tsu_sd_h_e=0.04,tsu_sd_l_e=0.18,tsu_sc_h_e=0.04,tsu_sc_l_e=0.18,
 th_e_sd_h=0.00,th_e_sd_l=0.01,th_e_sc_h=0.00,th_e_sc_l=0.01,
 sd_lh_z_lh=0,sd_hl_z_hl=0,sc_hl_z_lh=0,sc_hl_z_hl=0,e_hl_so_lh=0,e_hl_so_hl=0,
 e_lh_z_lh=0,e_lh_z_hl=0,oe_hl_z_lz_1=0,oe_lh_z_zh_2=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_e,th_e_sd_l,notifier,,,d_E,d_SD);
 $setuphold (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_e,th_e_sd_h,notifier,,,d_E,d_SD);
 $setuphold (negedge E,posedge SC,tsu_sc_h_e,th_e_sc_l,notifier,,,d_E,d_SC);
 $setuphold (negedge E,negedge SC,tsu_sc_l_e,th_e_sc_h,notifier,,,d_E,d_SC);
 $setuphold (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_e,th_e_d_l,notifier,,,d_E,d_D);
 $setuphold (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_e,th_e_d_h,notifier,,,d_E,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_h_e,notifier);
 $setup (negedge SD &&& (SC==1'b1),negedge E &&& (SC==1'b1),tsu_sd_l_e,notifier);
 $setup (posedge SC,negedge E,tsu_sc_h_e,notifier);
 $setup (negedge SC,negedge E,tsu_sc_l_e,notifier);
 $setup (posedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_h_e,notifier);
 $setup (negedge D &&& (SC==1'b0),negedge E &&& (SC==1'b0),tsu_d_l_e,notifier);
 $hold  (negedge E &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_e_sd_h,notifier);
 $hold  (negedge E &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_e_sd_l,notifier);
 $hold  (negedge E,negedge SC,th_e_sc_h,notifier);
 $hold  (negedge E,posedge SC,th_e_sc_l,notifier);
 $hold  (negedge E &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_e_d_h,notifier);
 $hold  (negedge E &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_e_d_l,notifier);
`endif 
 $width (posedge E,tpw_e_h,0,notifier);
 $width (negedge E,tpw_e_l,0,notifier);
// Delays
 (        OE  => Z) = (oe_hl_z_lz_1,oe_hl_z_hz_1,oe_hl_z_lz_1,oe_lh_z_zh_2,oe_hl_z_hz_1,oe_lh_z_zl_1);
 (D   *> Z) = (d_lh_z_lh,d_hl_z_hl);
 (SD   *> Z) = (sd_lh_z_lh,sd_hl_z_hl);
 (SC   *> Z) = (sc_hl_z_lh,sc_hl_z_hl);
 (E   *> Z) = (e_lh_z_lh,e_lh_z_hl);
 (negedge E  => (SO +: ((SD && SC) || (D && ~SC)))) = (e_hl_so_lh,e_hl_so_hl);
endspecify
`endif



endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlb1.v
// Description          : Muxed Scan Latch with Low Enable, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlb1 (D,SD,SC,EN,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (buf_Q,mux_out,EN);
U_LD_P #1 (SO,buf_Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (buf_Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (buf_Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0,
 sc_hl_q_lh=0,sc_hl_q_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if (EN==1'b0)
 (        SC => QN ) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlb2.v
// Description          : Muxed Scan Latch with Low Enable, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlb2 (D,SD,SC,EN,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (buf_Q,mux_out,EN);
U_LD_P #1 (SO,buf_Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (buf_Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (buf_Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0,
 sc_hl_q_lh=0,sc_hl_q_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if (EN==1'b0)
 (        SC => QN ) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlb4.v
// Description          : Muxed Scan Latch with Low Enable, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlb4 (D,SD,SC,EN,Q,QN,SO);

output  Q,QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (buf_Q,mux_out,EN);
U_LD_P #1 (SO,buf_Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (buf_Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (buf_Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,buf_Q,EN,notifier);
`endif
`endif

buf (Q,buf_Q);
not (QN,buf_Q);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_hl_qn_lh=0,d_lh_q_lh=0,d_lh_qn_hl=0,
 en_hl_q_hl=0,en_hl_qn_lh=0,en_hl_q_lh=0,en_hl_qn_hl=0,
 sc_hl_q_lh=0,sc_hl_q_hl=0,sc_hl_qn_lh=0,sc_hl_qn_hl=0,sd_lh_q_lh=0,
 sd_hl_q_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if (EN==1'b0)
 (        SC => QN ) = (sc_hl_qn_lh,sc_hl_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnln1.v
// Description          : Muxed Scan Latch with Low Enable and QN only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnln1 (D,SD,SC,EN,QN,SO);

output  QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (QN,mux_not,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (QN,mux_not,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (QN,mux_not,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif

not (mux_not, mux_out);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_lh_qn_lh=0,sc_lh_qn_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 en_hl_qn_lh=0,en_hl_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => QN) = (sc_lh_qn_lh,sc_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnln2.v
// Description          : Muxed Scan Latch with Low Enable and QN only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnln2 (D,SD,SC,EN,QN,SO);

output  QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (QN,mux_not,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (QN,mux_not,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (QN,mux_not,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif
                                                                                                                
not (mux_not, mux_out);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_lh_qn_lh=0,sc_lh_qn_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 en_hl_qn_lh=0,en_hl_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => QN) = (sc_lh_qn_lh,sc_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnln4.v
// Description          : Muxed Scan Latch with Low Enable and QN only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnln4 (D,SD,SC,EN,QN,SO);

output  QN,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (QN,mux_not,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (QN,mux_not,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (QN,mux_not,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif
                                                                                                                
not (mux_not, mux_out);
not (Q,QN);

`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_qn_lh=0,d_lh_qn_hl=0,sc_lh_qn_lh=0,sc_lh_qn_hl=0,sd_hl_qn_lh=0,sd_lh_qn_hl=0,
 en_hl_qn_lh=0,en_hl_qn_hl=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => QN) = (sc_lh_qn_lh,sc_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D -=> QN) = (d_hl_qn_lh,d_lh_qn_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD -=> QN) = (sd_hl_qn_lh,sd_lh_qn_hl);
 (negedge EN  => (QN -: ((SD && SC) || (D && ~SC)))) = (en_hl_qn_lh,en_hl_qn_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlq1.v
// Description          : Muxed Scan Latch with Low Enable and Q only, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlq1 (D,SD,SC,EN,Q,SO);

output  Q,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (Q,mux_out,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 en_hl_q_hl=0,en_hl_q_lh=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlq2.v
// Description          : Muxed Scan Latch with Low Enable and Q only, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlq2 (D,SD,SC,EN,Q,SO);

output  Q,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (Q,mux_out,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 en_hl_q_hl=0,en_hl_q_lh=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: slnlq4.v
// Description          : Muxed Scan Latch with Low Enable and Q only, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.9
// Added $width for SC  : 18Dec05 bengil & assafma 
//


module slnlq4 (D,SD,SC,EN,Q,SO);

output  Q,SO;
input   D,SD,SC,EN;

wire mux_out,OE_buf,Q,buf_Q,mux_not;

`ifdef neg_tchk
wire d_D,d_EN,d_SD,d_SC;
`endif

`ifdef functional
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N #1 (Q,mux_out,EN);
U_LD_P #1 (SO,Q,EN);
`else
reg notifier;
`ifdef neg_tchk
U_MUX_2_1 (mux_out,d_D,d_SD,d_SC);
U_LD_N_NO #1 (Q,mux_out,d_EN,notifier);
U_LD_P_NO #1 (SO,Q,d_EN,notifier);
`else
U_MUX_2_1 (mux_out,D,SD,SC);
U_LD_N_NO #1 (Q,mux_out,EN,notifier);
U_LD_P_NO #1 (SO,Q,EN,notifier);
`endif
`endif


`ifdef functional
`else
specify
// Parameter declarations
 specparam tsu_d_h_en=0.00,tsu_d_l_en=0.13,th_en_d_h=0.00,th_en_d_l=0.15,
 tsu_sd_h_en=0.00,tsu_sd_l_en=0.13,tsu_sc_h_en=0.00,tsu_sc_l_en=0.13,
 th_en_sd_h=0.00,th_en_sd_l=0.15,th_en_sc_h=0.00,th_en_sc_l=0.15,
 tpw_en_h=0.00,tpw_en_l=0.21,tpw_sc_h=0,d_hl_q_hl=0,d_lh_q_lh=0,sc_hl_q_lh=0,sc_hl_q_hl=0,sd_lh_q_lh=0,sd_hl_q_hl=0,
 en_hl_q_hl=0,en_hl_q_lh=0,en_lh_so_lh=0,en_lh_so_hl=0;
// Violation constraints
`ifdef neg_tchk
 $setuphold (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),tsu_sd_h_en,th_en_sd_l,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),tsu_sd_l_en,th_en_sd_h,notifier,,,d_EN,d_SD);
 $setuphold (posedge EN,posedge SC,tsu_sc_h_en,th_en_sc_l,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN,negedge SC,tsu_sc_l_en,th_en_sc_h,notifier,,,d_EN,d_SC);
 $setuphold (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),tsu_d_h_en,th_en_d_l,notifier,,,d_EN,d_D);
 $setuphold (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),tsu_d_l_en,th_en_d_h,notifier,,,d_EN,d_D);
`else
 $setup (posedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_h_en,notifier);
 $setup (negedge SD &&& (SC==1'b1),posedge EN &&& (SC==1'b1),tsu_sd_l_en,notifier);
 $setup (posedge SC,posedge EN,tsu_sc_h_en,notifier);
 $setup (negedge SC,posedge EN,tsu_sc_l_en,notifier);
 $setup (posedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_h_en,notifier);
 $setup (negedge D &&& (SC==1'b0),posedge EN &&& (SC==1'b0),tsu_d_l_en,notifier);
 $hold  (posedge EN &&& (SC==1'b1),negedge SD &&& (SC==1'b1),th_en_sd_h,notifier);
 $hold  (posedge EN &&& (SC==1'b1),posedge SD &&& (SC==1'b1),th_en_sd_l,notifier);
 $hold  (posedge EN,negedge SC,th_en_sc_h,notifier);
 $hold  (posedge EN,posedge SC,th_en_sc_l,notifier);
 $hold  (posedge EN &&& (SC==1'b0),negedge D &&& (SC==1'b0),th_en_d_h,notifier);
 $hold  (posedge EN &&& (SC==1'b0),posedge D &&& (SC==1'b0),th_en_d_l,notifier);
`endif
 $width (negedge EN,tpw_en_l,0,notifier);
 $width (posedge EN,tpw_en_h,0,notifier);
 $width (posedge SC,tpw_sc_h,0,notifier);
// Delays
 if (EN==1'b0)
 (        SC => Q ) = (sc_hl_q_lh,sc_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b0))
 (        D +=> Q ) = (d_lh_q_lh,d_hl_q_hl);
 if ((EN==1'b0) && (SC==1'b1))
 (        SD +=> Q ) = (sd_lh_q_lh,sd_hl_q_hl);
 (negedge EN  => (Q  +: ((SD && SC) || (D && ~SC)))) = (en_hl_q_lh,en_hl_q_hl);
 (posedge EN  => (SO +: ((SD && SC) || (D && ~SC)))) = (en_lh_so_lh,en_lh_so_hl);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: srlab1.v
// Description  	:  SetN ResetN Latch, (NAND Inputs) 1X
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module srlab1 (RN,SN,Q,QN);

output  Q,QN;
input   RN,SN;

wire RN_buf,SN_buf;

buf b_RN (RN_buf,RN);
buf b_SN (SN_buf,SN);

`ifdef functional
U_L_SB_RB #1 srlab1_Q(Q,SN_buf,RN_buf);
U_L_SB_RB_QN #1 srlab1_QN(QN,SN_buf,RN_buf);
`else
reg notifier;
U_L_SB_RB_NO #1 srlab1_Q(Q,SN_buf,RN_buf,notifier);
U_L_SB_RB_QN_NO #1 srlab1_QN(QN,SN_buf,RN_buf,notifier);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tpw_sn_l=0.28,tpw_rn_l=0.29,rn_hl_qn_lh=0,sn_hl_qn_hl_1=0,
 rn_lh_q_lh=0,sn_lh_qn_lh=0,rn_hl_q_hl_2=0,sn_hl_q_lh=0;
// Violation constraints
 $width (negedge SN,tpw_sn_l,0,notifier);
 $width (negedge RN,tpw_rn_l,0,notifier);
// Delays
 (        SN +=> QN) = (sn_lh_qn_lh,sn_hl_qn_hl_1);
 (        RN +=> Q ) = (rn_lh_q_lh,rn_hl_q_hl_2);
 (negedge RN  => (QN +: 1'b1)) = (rn_hl_qn_lh,0);
 (negedge SN  => (Q  +: 1'b1)) = (sn_hl_q_lh,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: srlab2.v
// Description  	:  SetN ResetN Latch, (NAND Inputs) 2X
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.6
//
//


module srlab2 (RN,SN,Q,QN);

output  Q,QN;
input   RN,SN;

wire RN_buf,SN_buf;

buf b_RN (RN_buf,RN);
buf b_SN (SN_buf,SN);

`ifdef functional
U_L_SB_RB #1 srlab2_Q(Q,SN_buf,RN_buf);
U_L_SB_RB_QN #1 srlab2_QN(QN,SN_buf,RN_buf);
`else
reg notifier;
U_L_SB_RB_NO #1 srlab2_Q(Q,SN_buf,RN_buf,notifier);
U_L_SB_RB_QN_NO #1 srlab2_QN(QN,SN_buf,RN_buf,notifier);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tpw_sn_l=0.28,tpw_rn_l=0.29,rn_hl_qn_lh=0,sn_hl_qn_hl_1=0,
 rn_lh_q_lh=0,sn_lh_qn_lh=0,rn_hl_q_hl_2=0,sn_hl_q_lh=0;
// Violation constraints
 $width (negedge SN,tpw_sn_l,0,notifier);
 $width (negedge RN,tpw_rn_l,0,notifier);
// Delays
 (        SN +=> QN) = (sn_lh_qn_lh,sn_hl_qn_hl_1);
 (        RN +=> Q ) = (rn_lh_q_lh,rn_hl_q_hl_2);
 (negedge RN  => (QN +: 1'b1)) = (rn_hl_qn_lh,0);
 (negedge SN  => (Q  +: 1'b1)) = (sn_hl_q_lh,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: srlab4.v
// Description  	:  SetN ResetN Latch, (NAND Inputs) 4X
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.8
//
//


module srlab4 (RN,SN,Q,QN);

output  Q,QN;
input   RN,SN;

wire RN_buf,SN_buf;

buf b_RN (RN_buf,RN);
buf b_SN (SN_buf,SN);

`ifdef functional
U_L_SB_RB #1 srlab4_Q(Q,SN_buf,RN_buf);
U_L_SB_RB_QN #1 srlab4_QN(QN,SN_buf,RN_buf);
`else
reg notifier;
U_L_SB_RB_NO #1 srlab4_Q(Q,SN_buf,RN_buf,notifier);
U_L_SB_RB_QN_NO #1 srlab4_QN(QN,SN_buf,RN_buf,notifier);
`endif

`ifdef functional
`else
specify
// Parameter declarations
 specparam tpw_sn_l=0.28,tpw_rn_l=0.29,rn_hl_qn_lh=0,sn_hl_qn_hl_1=0,
 rn_lh_q_lh=0,sn_lh_qn_lh=0,rn_hl_q_hl_2=0,sn_hl_q_lh=0;
// Violation constraints
 $width (negedge SN,tpw_sn_l,0,notifier);
 $width (negedge RN,tpw_rn_l,0,notifier);
// Delays
 (        SN +=> QN) = (sn_lh_qn_lh,sn_hl_qn_hl_1);
 (        RN +=> Q ) = (rn_lh_q_lh,rn_hl_q_hl_2);
 (negedge RN  => (QN +: 1'b1)) = (rn_hl_qn_lh,0);
 (negedge SN  => (Q  +: 1'b1)) = (sn_hl_q_lh,0);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: su01d0.v
// Description          : 1-Bit Subtractor, 0.5X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module su01d0 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_SUB2_D #1 (S,A,B,CI);
U_SUB2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  -=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: su01d1.v
// Description  	:  1-Bit Subtractor, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module su01d1 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_SUB2_D #1 (S,A,B,CI);
U_SUB2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  -=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: su01d2.v
// Description          : 1-Bit Subtractor, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module su01d2 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_SUB2_D #1 (S,A,B,CI);
U_SUB2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  -=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: su01d4.v
// Description  	:  1-Bit Subtractor, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module su01d4 (A,B,CI,S,CO);

output  S,CO;
input   A,B,CI;

U_SUB2_D #1 (S,A,B,CI);
U_SUB2_C #1 (CO,A,B,CI);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((CI == 1'b0) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (B == 1'b1))
	(A => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (B == 1'b0))
	(A => S) = (default_rise,default_fall);
ifnone (A => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b0) && (A == 1'b0))
	(B => S) = (default_rise,default_fall);
if ((CI == 1'b1) && (A == 1'b1))
	(B => S) = (default_rise,default_fall);
ifnone (B => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b0) && (A == 1'b1))
	(CI => S) = (default_rise,default_fall);
if ((B == 1'b1) && (A == 1'b0))
	(CI => S) = (default_rise,default_fall);
ifnone (CI => S) = (default_rise,default_fall);

 (        A  +=> CO) = (default_rise,default_fall);
 (        B  -=> CO) = (default_rise,default_fall);
 (        CI +=> CO) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xn02d1.v
// Description  	:  2-Input Exclusive NOR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xn02d1 (A1,A2,ZN);

output  ZN;
input   A1,A2;

xnor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => ZN) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => ZN) = (default_rise,default_fall);
ifnone (A1 => ZN) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => ZN) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => ZN) = (default_rise,default_fall);
ifnone (A2 => ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xn02d2.v
// Description  	:  2-Input Exclusive NOR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xn02d2 (A1,A2,ZN);

output  ZN;
input   A1,A2;

xnor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => ZN) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => ZN) = (default_rise,default_fall);
ifnone (A1 => ZN) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => ZN) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => ZN) = (default_rise,default_fall);
ifnone (A2 => ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xn02d4.v
// Description  	:  2-Input Exclusive NOR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xn02d4 (A1,A2,ZN);

output  ZN;
input   A1,A2;

xnor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => ZN) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => ZN) = (default_rise,default_fall);
ifnone (A1 => ZN) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => ZN) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => ZN) = (default_rise,default_fall);
ifnone (A2 => ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xn02d7.v
// Description  	:  2-Input Exclusive NOR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xn02d7 (A1,A2,ZN);

output  ZN;
input   A1,A2;

xnor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => ZN) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => ZN) = (default_rise,default_fall);
ifnone (A1 => ZN) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => ZN) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => ZN) = (default_rise,default_fall);
ifnone (A2 => ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xn02da.v
// Description          : 2-Input Exclusive NOR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module xn02da (A1,A2,ZN);

output  ZN;
input   A1,A2;

xnor #1 (ZN,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => ZN) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => ZN) = (default_rise,default_fall);
ifnone (A1 => ZN) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => ZN) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => ZN) = (default_rise,default_fall);
ifnone (A2 => ZN) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
///////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr02d1.v
// Description  	:  2-Input Exclusive OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr02d1 (A1,A2,Z);

output  Z;
input   A1,A2;

xor #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => Z) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => Z) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);

endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr02d2.v
// Description  	:  2-Input Exclusive OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr02d2 (A1,A2,Z);

output  Z;
input   A1,A2;

xor #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => Z) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => Z) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr02d4.v
// Description  	:  2-Input Exclusive OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr02d4 (A1,A2,Z);

output  Z;
input   A1,A2;

xor #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => Z) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => Z) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);

endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr02d7.v
// Description  	:  2-Input Exclusive OR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr02d7 (A1,A2,Z);

output  Z;
input   A1,A2;

xor #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => Z) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => Z) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);

endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr02da.v
// Description          : 2-Input Exclusive OR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr02da (A1,A2,Z);

output  Z;
input   A1,A2;

xor #1 (Z,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if (A2 == 1'b0)
	(A1 => Z) = (default_rise,default_fall);
if (A2 == 1'b1)
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if (A1 == 1'b0)
	(A2 => Z) = (default_rise,default_fall);
if (A1 == 1'b1)
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);

endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr03d1.v
// Description  	:  3-Input Exclusive OR, 1X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr03d1 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

xor #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((A3 == 1'b0) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
ifnone (A3 => Z) = (default_rise,default_fall);

endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr03d2.v
// Description  	:  3-Input Exclusive OR, 2X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr03d2 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

xor #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((A3 == 1'b0) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
ifnone (A3 => Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr03d4.v
// Description  	:  3-Input Exclusive OR, 4X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr03d4 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

xor #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((A3 == 1'b0) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
ifnone (A3 => Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr03d7.v
// Description  	:  3-Input Exclusive OR, 7X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.3
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr03d7 (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

xor #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((A3 == 1'b0) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
ifnone (A3 => Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
////////////////////////////////////////////////////////////////////
// Copyright (c) 2003 Synopsys, Inc.  All Rights Reserved       //
// This information is provided pursuant to a license agreement //
// that grants limited rights of access/use and requires that   //
// the information be treated as confidential.                  //
////////////////////////////////////////////////////////////////////

`celldefine
`suppress_faults
`enable_portfaults

`ifdef functional
 `timescale 1ns / 1ns
 `delay_mode_distributed
 `delay_mode_unit
`else
 `timescale 1ns / 1ps
 `delay_mode_path
`endif 


// Model type   	: zero timing
// Filename     	: xr03da.v
// Description          : 3-Input Exclusive OR, 10X Drive
// Library      	: tsl18fs120
// Programmer   	: ycui
// Date                 : 08-Oct-2003
// Product version	: Rev. main.1 
// Master version	: Rev. main.4
// STDP arcs            : 14Aug05 ben gilboa 
//


module xr03da (A1,A2,A3,Z);

output  Z;
input   A1,A2,A3;

xor #1 (Z,A3,A2,A1);

`ifdef functional
`else
specify
// Parameter declarations
 specparam default_rise=0,default_fall=0;
// Delays
if ((A3 == 1'b0) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b0))
	(A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A2 == 1'b1))
	(A1 => Z) = (default_rise,default_fall);
ifnone (A1 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b0) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b0))
	(A2 => Z) = (default_rise,default_fall);
if ((A3 == 1'b1) && (A1 == 1'b1))
	(A2 => Z) = (default_rise,default_fall);
ifnone (A2 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b0) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b0))
	(A3 => Z) = (default_rise,default_fall);
if ((A2 == 1'b1) && (A1 == 1'b1))
	(A3 => Z) = (default_rise,default_fall);
ifnone (A3 => Z) = (default_rise,default_fall);
endspecify
`endif

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
